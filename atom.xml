<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TBH个人博客</title>
  
  <subtitle>记录点滴生活</subtitle>
  <link href="https://tbghg.top/atom.xml" rel="self"/>
  
  <link href="https://tbghg.top/"/>
  <updated>2024-10-20T10:31:05.000Z</updated>
  <id>https://tbghg.top/</id>
  
  <author>
    <name>tbghg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>国庆日本独行旅游小记</title>
    <link href="https://tbghg.top/2024-10-20/22a0b6fbf912/"/>
    <id>https://tbghg.top/2024-10-20/22a0b6fbf912/</id>
    <published>2024-10-20T10:31:05.000Z</published>
    <updated>2024-10-20T10:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>之前看邻居朋友圈，有点被他丰富的生活震撼到了，各种出国旅游 日本、新西兰、马来西亚…各种经历潜水、蹬雪山、跳伞…</p><p>看完后觉得自己的生活是不是有些太单调了，是不是该趁着自己年轻多去体验下外面的世界</p><p>吃饭时和同事聊天，同事问我国庆什么安排，我随口答到没啥安排，国内旅游哪都是人，看人也没啥意思，还不如去国外串串。之后一想，已经工作俩月了，也有些积蓄，干脆出国旅游见见世面吧</p><p>8月27号和同事聊天产生的想法，29号去办理护照，以前总感觉出国是件遥不可及的事，没想到自己这么短时间就下了决定</p><p>计划去日本旅游，因为自己平常会看些日本的动漫、漫画之类的，所以对那里有些感兴趣，接着就开始了自己的准备工作</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>和朋友聊这件事情时，朋友表示巧了，他也打算去日本旅游，不过他是中秋去，时间不太一致。之后做旅游攻略时，也受到了朋友和邻居的一些帮助</p><p>第一次出国 + 自己一个人 + 不会日语，还是有些担心的吧，所以在做攻略时比较慎重</p><p>时间：10.1出发，无锡转机，10.2下午五点到大阪 —– 10.10凌晨两点东京出发，凌晨六点到北京，收拾下东西，上班去(没错，很特种兵)</p><p>提前做的准备：</p><ul><li>办理护照、签证，注册日本入境QR码</li><li>日本流量卡</li><li>学习ICOCA交通卡办理攻略</li><li>开通手机卡国际漫游</li><li>兑换日元</li><li>提前订旅馆</li><li>新旧手机(想着带俩手机，和别人沟通使用翻译软件时会不会更方便些，其实没必要)</li><li>充电转接头(其实没必要)</li><li>硬币收纳套(挺有用的)</li><li>充电宝(很必要)</li><li>手机下载各种软件：订旅馆、地图、翻译、打滴</li><li>目前只记得这些吧，之后想到了再补充…</li></ul><h2 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h2><p>落地在大阪，返程在东京，计划两边都简单转转，但其实正常旅游攻略是关西转6-7天，关东转6-7天，我打算8天把两边都逛逛，注定是一场特种兵旅行</p><p>特殊背景：</p><ul><li>10.2-10.6 大阪的旅馆(6号早上十点前需要退房)</li><li>10.6-10.10 东京的旅馆(10号早上十点前需要退房)</li><li>10.5 晚上 东京有场大烟花<ul><li>如果去看 需要5号早晨乘坐新干线出发</li><li>在关西的时间只有2号一晚上，3 4号两天，可能关西逛不全</li><li>大阪的旅馆亏一天，到了东京没地方住</li></ul></li><li>10.6 晚上 东京有场小烟花<ul><li>6号早上乘坐新干线来东京</li><li>海灯祭看不到了</li><li>关西能多逛一天</li></ul></li><li>10.5-10.6 晚上 台场公园举办海灯祭(在东京)</li></ul><p>初版旅游攻略：</p><ul><li>10.2 下午五点 到大阪，旅馆办入住，收拾行李，晚上简单逛逛心斋桥、道顿堀</li><li>10.3 去京都，伏见稻荷大社 - 清水寺 - 二条城，回大阪简单逛逛</li><li>10.4 去奈良，奈良公园 - 春日大社 - 若草山，回大阪简单转转</li><li>10.5 弹性时间，方案多选一<ul><li>环球影城</li><li>大阪城+温泉</li><li>京都没转够的话再去京都看看</li><li>去东京看花火大会</li></ul></li><li>10.5 IF<ul><li>没去东京看烟花：10.6 去东京，行李寄存地铁站，看花火大会，取行李回秋叶原，宾馆办理入住</li><li>去了东京看烟花：10.6 早上逛东京，下午去台场公园逛，晚上看海灯祭</li></ul></li><li>10.7-10.9 秋叶原 下北泽 涉谷 新宿 歌舞伎町 东京塔 银座 台场公园</li></ul><p>到10.4时，觉得比起固定的景点，反而是体验日本的活动更加吸引我一些，于是5号出发去了东京</p><p>实际旅游行程：</p><ul><li>10.2 下午五点 到大阪，旅馆办入住，收拾行李，晚上简单逛逛心斋桥、道顿堀</li><li>10.3 去京都，清水寺 - 二条城，回大阪简单逛逛</li><li>10.4 去奈良，伏见稻荷大社 - 奈良公园 - 若草山，回大阪简单转转</li><li>10.5 乘坐新干线，去东京，看花火大会</li><li>10.6 早上逛秋叶原，下午去台场公园，晚上看海灯祭</li><li>10.7-10.9 秋叶原 下北泽 涉谷 新宿 歌舞伎町 东京塔 银座 台场公园</li></ul><p>具体行程明天补充吧</p><h2 id="关西"><a href="#关西" class="headerlink" title="关西"></a>关西</h2><h3 id="Day1-大阪"><a href="#Day1-大阪" class="headerlink" title="Day1 大阪"></a>Day1 大阪</h3><h3 id="Day2-京都"><a href="#Day2-京都" class="headerlink" title="Day2 京都"></a>Day2 京都</h3><h3 id="Day3-京都-奈良"><a href="#Day3-京都-奈良" class="headerlink" title="Day3 京都 + 奈良"></a>Day3 京都 + 奈良</h3><h2 id="关东"><a href="#关东" class="headerlink" title="关东"></a>关东</h2><h3 id="Day4-去东京-花火大会"><a href="#Day4-去东京-花火大会" class="headerlink" title="Day4 去东京 + 花火大会"></a>Day4 去东京 + 花火大会</h3><h3 id="Day5-秋叶原-台场公园-海灯祭"><a href="#Day5-秋叶原-台场公园-海灯祭" class="headerlink" title="Day5 秋叶原 + 台场公园 + 海灯祭"></a>Day5 秋叶原 + 台场公园 + 海灯祭</h3><h3 id="Day6-涉谷-下北泽"><a href="#Day6-涉谷-下北泽" class="headerlink" title="Day6 涉谷 + 下北泽"></a>Day6 涉谷 + 下北泽</h3><h3 id="Day7-新宿-东京铁塔"><a href="#Day7-新宿-东京铁塔" class="headerlink" title="Day7 新宿 + 东京铁塔"></a>Day7 新宿 + 东京铁塔</h3><h3 id="Day8-收拾行李-逛秋叶原"><a href="#Day8-收拾行李-逛秋叶原" class="headerlink" title="Day8 收拾行李 + 逛秋叶原"></a>Day8 收拾行李 + 逛秋叶原</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h2&gt;&lt;p&gt;之前看邻居朋友圈，有点被他丰富的生活震撼到了，各种出国旅游 日本、新西兰、马来西亚…各种经历潜水、蹬雪山、跳伞…&lt;/p&gt;
&lt;p&gt;看完</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>2024-09月记</title>
    <link href="https://tbghg.top/2024-10-12/eab561283843/"/>
    <id>https://tbghg.top/2024-10-12/eab561283843/</id>
    <published>2024-10-12T10:43:04.000Z</published>
    <updated>2024-10-12T10:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一个月最大的两件事：试用期转正答辩、出国旅游，旅游打算单独拆一篇出来，这里就简单写下答辩的事</p><p>试用期转正答辩其实还挺怵的，实习时的转正答辩答的太差了</p><p>之后总结反思了下那场答辩：</p><ol><li>准备不充分：明明自己知道HR会在场，却对HR常问问题一点准备没有，提问环节被问到了很多类似的问题，自己的临场发挥又很糟糕</li><li>思考的角度不对：<ul><li>表达的不应该是自己做了什么，而是对方想听什么，准备时应该按照STAR原则来说，才能让HR更简介的了解自己的成绩</li><li>STAR原则：Situation（情景）、Task（任务）、Action（行动）和Result（结果）</li></ul></li></ol><p>这次转正答辩时，提前准备了很多可能会问的问题，准备的比较充分（虽然一个都没被问到，但起码有个壮士气的作用，哈哈），这次问的问题偏向于具体业务，具体实现，自己临场答的也还可以吧</p><p>最后同事提了个点，自己在紧张时会有很多口癖，不管是这次转正答辩还是上次知识分享。说真的，我一直没意识到这点，当时都不知道他指的是什么，直到回去看了这两场的录像，发现自己紧张时，或者不知道下面接什么时，口癖多的离谱，很影响体验</p><p>（挑的是Prometheus的知识分享会，没有具体的业务内容，不会涉及到公司机密之类的）</p><p>刚开始讲的时候口癖特别严重，可能是第一次在组内进行发言有些紧张，后续进状态后慢慢就少了</p><p>example1：嘛</p><p>这个就是暴漏的指标嘛，格式的话比较同样，上面都要两行注释嘛….下面如果有多个标签，就是有多条数据嘛</p><p>example2：那个</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202410201805630.png"                                        ></p><p>example3：这个</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202410201805790.png"                                        ></p><p>example4：的话</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202410201806748.png"                                        ></p><p>重新看一遍录播，找自己在答辩&#x2F;分享会上出现的问题还挺重要的，以后多总结多注意这方面吧，下次自己发言时刻意注意下这块</p><p>总结下：</p><ul><li>会前要做好准备</li><li>从听众的角度思考，考虑使用STAR原则</li><li>日常生活中多注意，刻意减少口癖</li><li>发言可以看录播复盘，兴许会发现些自己没注意到的问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一个月最大的两件事：试用期转正答辩、出国旅游，旅游打算单独拆一篇出来，这里就简单写下答辩的事&lt;/p&gt;
&lt;p&gt;试用期转正答辩其实还挺怵的，实习时的转正答辩答的太差了&lt;/p&gt;
&lt;p&gt;之后总结反思了下那场答辩：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备不充分：明明自己知道HR会在场，却对</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="月记" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E6%9C%88%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2024-08月记</title>
    <link href="https://tbghg.top/2024-09-08/55ae2675b830/"/>
    <id>https://tbghg.top/2024-09-08/55ae2675b830/</id>
    <published>2024-09-08T12:46:17.000Z</published>
    <updated>2024-09-08T12:46:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>拖了十天，终于来补了</p><p>这个月发生的最大的事为养了个小祖宗，名曰“薄荷”</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082053372.jpg"                                        ></p><p>这个月也在赚钱攒猫粮，请小祖宗放心😤<br><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082055599.jpg"                                        ></p><p>6月22出生的（又多了个要记的纪念日），8月29日领回来的，目前养了十天，但是感悟还是挺多的</p><p>现在回想起来，养猫这个决定做的有些随意，因为它会对自己的生活带来较大的变化，并且会持续十几年，可能当时应该再慎重考虑下（不过以我对猫猫的执念最终可能变成慎重考虑后养猫吧，哈哈）</p><p>自己的生活中突然多了个要照顾的猫猫，做事前需要同时考虑它的情况，最近也正好在看漫画《真的要结婚吗》，总感觉处境有些相像，家庭成员变多的同时意味着自己需要一同成长，大多美好的事物后面都伴随着要承担的责任</p><p>但是话说回来，一味地害怕未知的麻烦也是不行的，一直待在自己的舒适区当然可以，我以前也是这样干的，但当回忆往事时，总觉得自己的生活应该更加丰富一些</p><p>以前（或者说包括现在），对于不太想做的事（或是出于麻烦，或是出于害怕），当出现一个说的过去的借口时，便会直接把它当成挡箭牌，并在心中觉得，毕竟xxx了，没办法，于是放弃了这个念头。</p><p>就像博客主页的那句话：“丰富多彩的生活需要强大的执行力”，时间过的很快，我不希望自己回忆往事时会再次后悔，所以想趁着年轻，趁着现在肩上没有太大的担子，趁着自己还有一些学生的稚嫩，让自己的生活中出现一些波澜~</p><hr><p>工作方面的话正式走向正规，已经能慢慢处理了，下周会进行转正答辩，祝自己顺利</p><hr><p>下一步的计划，目前发现自己空闲时无所事事、浑浑噩噩占比较大，对打游戏有些提不起兴趣了，也没有什么其它爱好，于是决定买些推理小说看看，单是下了，但自己会不会好好看，喜不喜欢看 都还是未知数，等下个月回顾吧</p><hr><p>再晒几张<br><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082056412.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082056236.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082056495.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202409082057032.jpg"                                        ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拖了十天，终于来补了&lt;/p&gt;
&lt;p&gt;这个月发生的最大的事为养了个小祖宗，名曰“薄荷”&lt;/p&gt;
&lt;p&gt;&lt;img  
                       lazyload
                       alt=&quot;image&quot;
             </summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="月记" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E6%9C%88%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>20240817-外出(看电影)小记</title>
    <link href="https://tbghg.top/2024-08-17/4b02c15f4a6d/"/>
    <id>https://tbghg.top/2024-08-17/4b02c15f4a6d/</id>
    <published>2024-08-17T19:14:37.000Z</published>
    <updated>2024-08-17T19:14:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电影评价"><a href="#电影评价" class="headerlink" title="电影评价"></a>电影评价</h2><p>周六日有些不知道做什么，游戏也不想打，身边的人也有事约不出来，听学弟说《异形-夺命舰》还可以，就去看了看</p><p>毕竟是科幻恐怖类的，特地挑的晚上九点半看的，正常看下来还算可以，很常规的剧情但又有些小爽，并且还适当关联了下前几部，另外就是最后，以为还是第四部那种母子的桥段，结果并不是</p><p>异形设计的怎么看都觉得有些小帅</p><p><img                         lazyload                       alt="image"                       data-src="https://tbh-image.oss-cn-beijing.aliyuncs.com/blog202408180321538.jpg"                                        ></p><p>总结一下，我对它的评价是，剧情没什么亮点，很中规中矩但是比较爽的电影</p><h2 id="路途小记"><a href="#路途小记" class="headerlink" title="路途小记"></a>路途小记</h2><p>然后吐槽下去电影院过程中发生的一些事</p><p>首先是出发的时，其实发现天气预报有说过段时间会下雨了，但是自己出发时间有些晚，还想在开播前买杯奶茶，怕赶不上，最后还是骑着山地车出发了，停车时找了个有棚子的地方</p><p>看完电影后，好多人聚在狭小且昏暗的走廊，外面瓢泼大雨，时不时飘来几道闪电，还是在看完一部科幻恐怖片之后，这种感觉还是挺奇妙的，有些有趣</p><p><img                         lazyload                       alt="image"                       data-src="https://tbh-image.oss-cn-beijing.aliyuncs.com/blog202408180332245.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://tbh-image.oss-cn-beijing.aliyuncs.com/blog202408180332783.jpg"                                        ></p><p>打车回来倒也没问题，但是山地车是最近新买的，有些担心，所以就等了段时间，并且毕竟回去了也有些无聊，在这里吹吹风也不错</p><p>过了段时间雨没那么大了就骑着回去了，但回去的路上没那么平淡，中间要过一个地下桥，地下桥被水淹了，好多汽车都停在外面不敢过去，我这个小小山地车就更加不知所措了</p><p><img                         lazyload                       alt="image"                       data-src="https://tbh-image.oss-cn-beijing.aliyuncs.com/blog202408180354351.jpg"                                        ></p><p>问了下旁边的大哥，大哥说可以绕路，从旁边的桥上上去，推着车子慢慢走，再下来，但是上面车比较多，走的时候小心点。</p><p>听完之后便打开高德开始看怎么上桥，定睛一看，好家伙，京沪高速！我说咋一堆大货车在上面飞速疾驰，合着是高速啊，果断放弃了这个方案。</p><p>之后问了下路过的小哥，小哥说从右边那个小区进去，怎么怎么绕，之后抬上去，应该能过</p><p>那个小区里面也是较为昏暗，里面七拐八拐的，道路也很狭小(可能其实是街道吧，也没太注意)，跟上面一样，感觉特别有氛围，可惜的是在那个小区绕了半天，也没能找到。</p><p>便利店老板倒是告知了个路线，说是比较远但能过，便决定往那块走了。</p><p>结果刚一出小区，发现工人拿着抽水泵已经把地下桥中的水抽干净了😂，最后还是走的桥下，走的时候发现桥旁边有个拦路的车杆，后面有个小道(在绿化带后面)，里面可以过桥，估计就是小哥说的那个地方，也确实算是在小区里面</p><p>整个过程还是很有趣的，多出去逛逛挺不错的，算是不虚此行吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;电影评价&quot;&gt;&lt;a href=&quot;#电影评价&quot; class=&quot;headerlink&quot; title=&quot;电影评价&quot;&gt;&lt;/a&gt;电影评价&lt;/h2&gt;&lt;p&gt;周六日有些不知道做什么，游戏也不想打，身边的人也有事约不出来，听学弟说《异形-夺命舰》还可以，就去看了看&lt;/p&gt;
&lt;p&gt;毕竟</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA博客模板</title>
    <link href="https://tbghg.top/2024-08-17/d360aeb3cc84/"/>
    <id>https://tbghg.top/2024-08-17/d360aeb3cc84/</id>
    <published>2024-08-17T18:54:42.000Z</published>
    <updated>2024-08-17T18:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>我自己是用hexo写博客的，<code>categories</code>是直接创建了对应的目录，不同目录下放对应分类，例如这个文件就在<code>source\_posts\技术\杂项\IDEA博客模板.md</code></p><p>每次创建时都需要手动填写<code>categories</code>，并且要加上<code>code_block_shrink: false</code>让代码默认不折叠，就想着干脆创建个IDEA的模板吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: $&#123;title&#125;</span><br><span class="line">code_block_shrink: false</span><br><span class="line">date: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;:$&#123;SECOND&#125;</span><br><span class="line">categories: </span><br><span class="line">#set($trimmedDir = $DIR_PATH.replace(&quot;source/_posts/&quot;, &quot;&quot;))</span><br><span class="line">#set($segments = $trimmedDir.split(&quot;/&quot;))</span><br><span class="line">#set($segment = &quot;&quot;)</span><br><span class="line">#foreach($segment in $segments)</span><br><span class="line">  - $&#123;segment&#125;</span><br><span class="line">#end</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog202408180312277.png"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog202408180313794.png"                                        ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我自己是用hexo写博客的，&lt;code&gt;categories&lt;/code&gt;是直接创建了对应的目录，不同目录下放对应分类，例如这个文件就在&lt;code&gt;source&#92;_posts&#92;技术&#92;杂项&#92;IDEA博客模板.md&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每次创建时都需要手动填写&lt;code</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="杂项" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>监控平台搭建(6)-日志告警</title>
    <link href="https://tbghg.top/2024-08-14/6647ff29bfaf/"/>
    <id>https://tbghg.top/2024-08-14/6647ff29bfaf/</id>
    <published>2024-08-14T12:54:14.000Z</published>
    <updated>2024-08-14T12:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控平台搭建-6-日志告警"><a href="#监控平台搭建-6-日志告警" class="headerlink" title="监控平台搭建(6)-日志告警"></a>监控平台搭建(6)-日志告警</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日志告警通常是使用ELK(Elasticsearch、Logstash 和 Kibana)来做的</p><ul><li>ELK：查看日志、日志告警</li><li>Prometheus：查看指标、指标告警</li></ul><p>两个系统负责的不是同一种东西，按理说应该上ELK，但是它的体量太大</p><p>此次需求需要对日志进行监控，同时项目较为小型，使用轻量化的mtail监控日志即可</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>mtail是一个google开发的日志提取工具，它从 应用程序日志 中提取指标以导出到 时间序列数据库 或 时间序列计算器，用于警报和仪表板</p><p>简单来说，整个过程为：mtail实时读取应用程序的日志，根据用户编写的脚本实时分析，最终生成时间序列指标了，Prometheus拉取mtail暴露的指标</p><p><a class="link"   href="https://github.com/google/mtail" >官方地址<i class="fas fa-external-link-alt"></i></a></p><h2 id="配置与使用"><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/google/mtail/releases/download/v3.0.7/mtail_3.0.7_linux_amd64.tar.gz</span><br><span class="line">tar -xzf mtail_3.0.7_linux_amd64.tar.gz</span><br><span class="line">sudo mv mtail_3.0.7_linux_amd64/ /usr/local/mtail/</span><br><span class="line">mkdir mtails</span><br><span class="line">cd mtails</span><br><span class="line"></span><br><span class="line">vim test.mtail</span><br><span class="line"></span><br><span class="line">counter error_log_count by file,date,info</span><br><span class="line"></span><br><span class="line">/\[(?P&lt;date&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)\]\[error\],(?P&lt;info&gt;.*)/ &#123;</span><br><span class="line"><span class="meta prompt_">  error_log_count[getfilename()][$</span><span class="language-bash"><span class="built_in">date</span>][<span class="variable">$info</span>]++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来逐行解释下<code>test.mtail</code>的内容，具体的mtail语法可参考：<a class="link"   href="https://blog.csdn.net/bluuusea/article/details/105508897" >mtail详解<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="https://github.com/google/mtail" >官方文档<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">声明error_log_count，指出类型counter，说明包含file,<span class="built_in">date</span>,info三种标签</span></span><br><span class="line">counter error_log_count by file,date,info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正则匹配日期，?P&lt;<span class="built_in">date</span>&gt;接收日期，之后通过<span class="variable">$date</span>使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">?P&lt;info&gt;匹配这行后面的所有内容</span></span><br><span class="line">/\[(?P&lt;date&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)\]\[error\],(?P&lt;info&gt;.*)/ &#123;</span><br><span class="line"><span class="meta prompt_">  error_log_count[getfilename()][$</span><span class="language-bash"><span class="built_in">date</span>][<span class="variable">$info</span>]++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置自启动，<strong>注意此处的logs需要根据实际情况替换</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/mtail.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=mtail</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/usr/local/mtail</span><br><span class="line">ExecStart=/usr/local/mtail/mtail -port 9150 --progs /usr/local/mtail/mtails/ --logs /usr/local/mtail/logs/*.log</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;[2088-11-09 23:25:31][error],[object Promise] reason:TypeError: Cannot read properties of undefined (reading &#x27;area&#x27;)</span><br><span class="line">    at /data/server/server-2022-11-02-19-49-41-627-ver-07b1a29930153101e4feb0ff39e760903d9e5cbe/Project/Servers/wbScene/worldScene/EntityComponent/ComponentTrade.js:139:64</span><br><span class="line">    at Array.forEach (&lt;anonymous&gt;)</span><br><span class="line">    at ComponentTrade.autoTradeAction (/data/server/server-2022-11-02-19-49-41-627-ver-07b1a29930153101e4feb0ff39e760903d9e5cbe/Project/Servers/wbScene/worldScene/EntityComponent/ComponentTrade.js:133:16)</span><br><span class="line">    at runMicrotasks (&lt;anonymous&gt;)</span><br><span class="line">    at processTicksAndRejections (node:internal/process/task_queues:96:5)&quot; &gt;&gt; apple.log</span><br></pre></td></tr></table></figure><p><a class="link"   href="http://192.168.227.129:9150/" >http://192.168.227.129:9150/<i class="fas fa-external-link-alt"></i></a></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408142059878.png"                                        ></p><p>发现mtail文件编译通过</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408142100606.png"                                        ></p><p>指标中有 时间、错误信息、日志文件、mtail文件，配置告警时，可以简单阐述错误情况</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a class="link"   href="https://github.com/google/mtail" >官方文档<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/bluuusea/article/details/105508897" >mtail详解<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://oskr.cn/archives/mtailprometheus%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97error%E8%A7%A6%E5%8F%91%E5%91%8A%E8%AD%A6" >mtail + prometheus 监控日志error触发告警<i class="fas fa-external-link-alt"></i></a>【重点】</li><li><a class="link"   href="https://www.cnblogs.com/lifuqiang/articles/16880624.html" >matil采集错误日志并通过prometheus告警<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监控平台搭建-6-日志告警&quot;&gt;&lt;a href=&quot;#监控平台搭建-6-日志告警&quot; class=&quot;headerlink&quot; title=&quot;监控平台搭建(6)-日志告警&quot;&gt;&lt;/a&gt;监控平台搭建(6)-日志告警&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Prometheus" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/Prometheus/"/>
    
    
    <category term="Prometheus" scheme="https://tbghg.top/tags/Prometheus/"/>
    
    <category term="监控" scheme="https://tbghg.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>监控平台搭建(3)-Springboot埋点</title>
    <link href="https://tbghg.top/2024-08-04/739cd10a2ee5/"/>
    <id>https://tbghg.top/2024-08-04/739cd10a2ee5/</id>
    <published>2024-08-04T10:53:14.000Z</published>
    <updated>2024-08-04T10:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控平台搭建-3-Springboot埋点"><a href="#监控平台搭建-3-Springboot埋点" class="headerlink" title="监控平台搭建(3)-Springboot埋点"></a>监控平台搭建(3)-Springboot埋点</h1><h2 id="采集需求"><a href="#采集需求" class="headerlink" title="采集需求"></a>采集需求</h2><p>Springboot应用需要监控的场景：</p><ol><li>JVM的具体情况</li><li>接口的TP90、最大响应时长、平均响应时长、QPS</li><li>监控接口的进阶要求<ol><li>根据入参进行分类</li><li>内部调用其他接口（如外部数据源），监控指标同上</li><li>接口http响应码，内部业务code码，根据code统计失败率</li></ol></li><li>项目出现问题，发送自定义指标，配置告警，帮助快速发现问题</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求一：<code>Springboot Actuator</code>可以直接监控JVM信息</p><p>需求四：可以通过<code>打印错误日志 -&gt; mtail监控 -&gt; 监控到指定日志，发送Metrics -&gt; 告警</code> 来实现，所以暂时不讨论</p><p>所以本篇文章主要讨论 需求二、需求三 的实现</p><h3 id="Metrics类型选择"><a href="#Metrics类型选择" class="headerlink" title="Metrics类型选择"></a>Metrics类型选择</h3><p>有四种数据类型：Counter(单增)，Gauge(可增可减)，Histogram(桶&#x2F;直方图)，Summary(摘要)</p><ul><li>Summary(摘要) 是 客户端 直接计算出 用户指定的分位点，然后上报Prometheus</li><li>Histogram(桶&#x2F;直方图) 是 Prometheus 根据 桶分布情况 <strong>估算</strong> 分位点<ul><li><a class="link"   href="https://www.rectcircle.cn/posts/observability-2-metrics-prometheus/#histogram-%E7%9B%B4%E6%96%B9%E5%9B%BE" >Histogram计算过程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/prometheus/prometheus/blob/main/promql/quantile.go#L151" >Histogram分位点计算逻辑-源码<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><p>数据上报：</p><ul><li>Histogram类型上报的数据：桶、max、count、sum</li><li>Summary类型上报的数据：分位点、max、count、sum</li></ul><p>Histogram VS Summary</p><ul><li>Histogram<ul><li>客户端性能消耗小，服务端查询分位数时消耗大。</li><li>可以在查询期间自由计算各种不同的分位数。</li><li>分位数的精度无法保证，其精确度受桶的配置、数据分布、数据量大小情况影响。</li><li>可聚合，可以计算全局分位数。</li><li>客户端兼容性好。</li></ul></li><li>Summary<ul><li>客户端性能消耗大（因为分位数计算发生在客户端），服务端查询分位数时消耗小。</li><li>只能查询客户端上报的哪些分位数。</li><li>分位数的精度可以得到保证，精度会影响客户端的消耗。</li><li>不可聚合，无法计算全局分位数（因此不支持多实例，平行扩展的 http 服务）。</li><li>客户端兼容性不好。</li></ul></li></ul><p>大多数场景使用 Histogram 更为灵活。</p><p>现在来分析下需求二、三：</p><p>如果我们只使用Histogram类型统计接口</p><ul><li>通过max可以统计最大响应时间</li><li>Prometheus可以根据桶估算分位点</li><li>根据区间内的sum和count可以计算平均响应时长</li></ul><p>综上，对于我们的需求，只采用Histogram即可解决</p><h2 id="埋点实现"><a href="#埋点实现" class="headerlink" title="埋点实现"></a>埋点实现</h2><p>下面会从头介绍我个人的探索过程，省流：方案一不可用，不感兴趣可以直接从方案二开始看起</p><blockquote><p>留着 方案一 是因为确实写了一篇文档，也打算这么来搞，但最终发现不可行，也无法通过其它方式补救</p></blockquote><h3 id="方案一-Timed"><a href="#方案一-Timed" class="headerlink" title="方案一 @Timed"></a>方案一 @Timed</h3><p>我们可以使用<code>springboot actuator</code>进行监控，而它底层按照micrometer的规范实行，导入<code>micrometer-registry-prometheus</code>即可将数据转为Prometheus的Metrics格式进行上报</p><p>同时，我们可以使用<code>micrometer</code>提供的<code>@Timed</code>进行监控埋点，它是通过<code>AOP</code>来实现的，所以需要导入<code>spring-boot-starter-aop</code>，同时也记得开启<code>@EnableAspectJAutoProxy</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着添加相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 监控指标暴漏在8092端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8092</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 允许访问所有监控端点</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="comment"># 添加标签 应用名称</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>启动后，查看<code>localhost:8092/actuator</code>即可查看所有的监控指标，而<code>localhost:8092/actuator/prometheus</code>则是要上报Prometheus的指标</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408021727469.png"                                        ></p><p>下面是关于<code>@Timed</code>的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.micrometer.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Repeatable(TimedSet.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Timed &#123;</span><br><span class="line">    <span class="comment">// 指标名称</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 自己想要添加的额外标签</span></span><br><span class="line">    String[] extraTags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// A long task timer is used to track the total duration of all in-flight long-running tasks and the number of such tasks.</span></span><br><span class="line">    <span class="comment">// 长任务计时器用于跟踪所有正在进行的长时间运行任务的总持续时间以及此类任务的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">longTask</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 摘要类型时，要计算的分位数</span></span><br><span class="line">    <span class="type">double</span>[] percentiles() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 是否为直方图类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">histogram</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 指标的注释</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用前我们需要将包内提供的<code>TimeAspect</code>创建为<code>bean</code>，详细参考：<a class="link"   href="https://blog.csdn.net/weixin_42182797/article/details/102614969" >Timer（一）之@Timed初探<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TimedAspect <span class="title function_">timedAspect</span><span class="params">(MeterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TimedAspect</span>(registry, tagsBasedOnJoinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Timed(value = &quot;apple.timed1&quot; ,description = &quot;测试timed注解&quot;, histogram = true, extraTags = &#123;&quot;tag1&quot;,&quot;tbg&quot;,&quot;tag2&quot;,&quot;hg&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>名称默认会以<code>.</code>进行分割然后转换，到Prometheus后，为apple_timed1</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408021738366.png"                                        ></p><p>上报的指标包括bucket、count、sum、max四种</p><p>但是只有这些指标，肯定没有办法满足需求，例如：</p><ol><li>如何动态的指定标签，或者说如何将接口的入参作为标签</li><li>如何将header中的字段添加到标签中</li></ol><p>首先看源码上的注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AspectJ aspect for intercepting types or methods annotated with @Timed. The aspect supports programmatic customizations through constructor-injectable custom logic.</span><br><span class="line">You might want to add tags programmatically to the Timer. In this case, the tags provider function (Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt;) can help. It receives a ProceedingJoinPoint and returns the Tags that will be attached to the Timer.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TimedAspect</span><span class="params">(MeterRegistry registry, Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(registry, tagsBasedOnJoinPoint, DONT_SKIP_ANYTHING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>tagsBasedOnJoinPoint</code>，我们可以自行添加标签，入参为<code>ProceedingJoinPoint</code>，我们可以轻松的获得方法的具体信息，下面给个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TimedAspect <span class="title function_">timedAspect</span><span class="params">(MeterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TimedAspect</span>(registry, tagsBasedOnJoinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数，根据ProceedingJoinPoint生成相应的Tags</span></span><br><span class="line">    Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint = joinPoint -&gt; &#123;</span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加方法名的Tag</span></span><br><span class="line">        tags.add(Tag.of(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;i&#x27;m method&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法签名</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String[] parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找参数名为inter的参数 并添加相应的Tag</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;inter&quot;</span>.equals(parameterNames[i])) &#123;</span><br><span class="line">                tags.add(Tag.of(<span class="string">&quot;inter&quot;</span>, args[i].toString()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202407311518199.png"                                        ></p><p>可以看到，标签成功打上去了，<code>inter</code>中是我们传入的参数</p><p>至于<code>header</code>，可以从入参中取<code>HttpServletRequest</code>类型，从中取数据</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>但是后面发现，这种方式无法获取到方法返回值，那么就无法获取返回的业务code或者http状态码等等，无法根据返回结果打标签，但是这种场景又很必须，例如根据业务code统计失败率，出现某些业务code后进行告警等等</p><p>该部分源码如下：</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408021758428.png"                                        ></p><p>过程如下：执行原方法 -&gt; 调用我们自定义的<code>tagsBasedOnJoinPoint.apply</code>方法 -&gt;上报指标</p><p>因为自定义方法中含有<code>ProceedingJoinPoint</code>连接点，还是有一定操作空间，所以现在的目标就变成了：对于一个已执行完毕的方法，通过反射等途径，获取之前的执行结果并使用</p><p>当时考虑了下面的方法：</p><ul><li>方法执行完成后 再通过一个切面(如<code>@AfterReturning</code>)来获取返回值</li><li>将返回值记录，保证之后可以通过连接点取到返回值</li><li>如何记录：通过反射，在方法中添加参数</li></ul><p>实现时发现，反射获取到参数后为数组类型，只能修改，无法添加，所以引申出一种自暴自弃式做法：</p><p>所有要监控的方法多一个result参数，统一写到这个里面【这个方案一旦交上去，估计第二天就从公司毕业了，所以就废弃掉了】</p><h3 id="方案二-自行实现AOP"><a href="#方案二-自行实现AOP" class="headerlink" title="方案二 自行实现AOP"></a>方案二 自行实现AOP</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>虽说是自行实现，但是可以注意到，<code>TimedAspect</code>是以<code>Bean</code>的形式注入的，我们只要自行实现一个<code>@Timed</code>的切面即可，并且<code>TimedAspect</code>中大部分实现可以参考，我们只需要在<code>result</code>小修一下。</p><p>既然要重新实现，那就实现一个更为完善的吧，对于自定义标签，我们可以分为两类：</p><ul><li>Before：根据入参打标签</li><li>After：根据返回值打标签</li></ul><p>先来看<code>Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint</code>，它虽然能用但却不好用，需要把所有要监控的方法的入参添加标签校验都放到这里，很容易出现彼此间的干扰，可读性较差，且后续维护会比较困难，这种类型已经无法满足我们的需求，所以直接删除相关代码</p><p>这里考虑使用策略模式，入参处理方式有各自的策略，出参处理方式有各自的策略，监控一个方法时通过注解配置它的入参出参策略标识。策略顶层定义一个抽象类，编写经常被复用的方法，权限设置为<code>protected</code>，对外提供<code> public List&lt;Tag&gt; getTags</code>供获取标签结果，所有的策略注入到策略工厂中</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>既然要在注解中定义标识，那原本的<code>@Timed</code>就不能用了，我们可以重新定义一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomTimed &#123;</span><br><span class="line">    <span class="comment">// 指标名称</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 指标描述</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 额外标签</span></span><br><span class="line">    String[] extraTags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 摘要类型时，需要计算的分位点</span></span><br><span class="line">    <span class="type">double</span>[] percentiles() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 是否为直方图类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">histogram</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 额外处理标识，主要处理获取结果后</span></span><br><span class="line">    String <span class="title function_">afterKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 额外处理标识，主要处理入参</span></span><br><span class="line">    String <span class="title function_">beforeKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来编写Before策略的抽象类，注释比较详细就不过多解释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MonitorBeforeStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Tag&gt; <span class="title function_">applyStrategy</span><span class="params">(ProceedingJoinPoint pjp)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] parameterNames;</span><br><span class="line">    <span class="keyword">protected</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Tag&gt; <span class="title function_">getTags</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        parameterParsing(pjp);</span><br><span class="line"></span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tags.add(Tag.of(<span class="string">&quot;class&quot;</span>, pjp.getStaticPart().getSignature().getDeclaringTypeName()));</span><br><span class="line">        tags.add(Tag.of(<span class="string">&quot;method&quot;</span>, pjp.getStaticPart().getSignature().getName()));</span><br><span class="line"></span><br><span class="line">        List&lt;Tag&gt; customTags = applyStrategy(pjp);</span><br><span class="line">        tags.addAll(customTags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录 http 相关标签</span></span><br><span class="line"><span class="comment">     * 需要监控方法中携带 HttpServletRequest 入参</span></span><br><span class="line"><span class="comment">     * 如果需要记录Header中的内容，可重写该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Tag&gt; <span class="title function_">httpTags</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">                request = (HttpServletRequest) args[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String userAgent = request.getHeader(&quot;xxx&quot;);</span></span><br><span class="line">        tags.add(Tag.of(<span class="string">&quot;requestMethod&quot;</span>, request.getMethod()));</span><br><span class="line">        tags.add(Tag.of(<span class="string">&quot;uri&quot;</span>, request.getRequestURI()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp 连接点对象，提供对目标方法的访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@function</span> 解析方法参数 获取参数名称和对应的参数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parameterParsing</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) pjp.getSignature();</span><br><span class="line">        <span class="built_in">this</span>.parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        <span class="built_in">this</span>.args = pjp.getArgs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> names 需要匹配的参数名称数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@function</span> 获取返回与参数名称匹配的对象数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> 与入参顺序对应的对象组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] getTargetArgs(String... names) &#123;</span><br><span class="line">        Object[] targetArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[names.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (names[j].equals(parameterNames[i])) &#123;</span><br><span class="line">                    <span class="comment">// Object索引与names相对应，可省略 查询不到时赋 Null 操作</span></span><br><span class="line">                    targetArgs[j] = args[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> targetArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看一个Before策略类的具体实现，可以发现现在添加标签就容易一些了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpMonitorBeforeStrategy</span> <span class="keyword">extends</span> <span class="title class_">MonitorBeforeStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 此处 interface_code 算是例子，按照实际情况更改</span></span><br><span class="line">    <span class="comment">// 要处理的入参参数名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTERFACE_CODE</span> <span class="operator">=</span> <span class="string">&quot;interfaceCode&quot;</span>;</span><br><span class="line">    <span class="comment">// 该参数上报时的标签名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTERFACE_CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;interface_code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Tag&gt; <span class="title function_">applyStrategy</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Object[] targetArgs = getTargetArgs(INTERFACE_CODE);</span><br><span class="line">        <span class="keyword">if</span> (targetArgs[<span class="number">0</span>] != <span class="literal">null</span> &amp;&amp; !targetArgs[<span class="number">0</span>].toString().isEmpty()) &#123;</span><br><span class="line">            tags.add(Tag.of(INTERFACE_CODE_TAG, targetArgs[<span class="number">0</span>].toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// URI、requestMethod标签 封装至 protected List&lt;Tag&gt; httpTags(ProceedingJoinPoint pjp) 中，根据业务情况自定调用</span></span><br><span class="line">        tags.addAll(httpTags(pjp));</span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是After的抽象类，这里需要注意，只写个泛型肯定不行，会存在泛型擦除的情况，导致我们取出result中的参数较为困难，所以需要传递实际类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MonitorAfterStrategy</span>&lt;R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Tag&gt; tags = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> R result;</span><br><span class="line">    <span class="comment">// 泛型擦除，这里需要传递实际类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;R&gt; resultType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MonitorAfterStrategy</span><span class="params">(Class&lt;R&gt; resultType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resultType = resultType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Tag&gt; <span class="title function_">applyStrategy</span><span class="params">(ProceedingJoinPoint pjp)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Tag&gt; <span class="title function_">getTags</span><span class="params">(ProceedingJoinPoint pjp, Object result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tags;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resultType.isInstance(result)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.result = resultType.cast(result);</span><br><span class="line">            <span class="built_in">this</span>.tags = applyStrategy(pjp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;result is not of type &#123;&#125;, result: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.result.getClass(), result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现中我们来举两个例子，先是常规简单的，可以看到现在从结果中取数据极为方便，直接取就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RespBodyVoMonitorAfterStrategy</span> <span class="keyword">extends</span> <span class="title class_">MonitorAfterStrategy</span>&lt;RespBodyVo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RespBodyVoMonitorAfterStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(RespBodyVo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Tag&gt; <span class="title function_">applyStrategy</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// result不为null已经判断过了，这里直接处理即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> result.getCode();</span><br><span class="line">        tags.add(Tag.of(CODE_TAG, code));</span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是在外面包裹了一层，并且内部使用了泛型(<code>ResponseEntity&lt;RespBodyVo&gt;</code>)，在上报类型时复杂一些，首先上报一般的class，然后强转指定对应的泛型即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrappedRespBodyVoMonitorAfterStrategy</span> <span class="keyword">extends</span> <span class="title class_">MonitorAfterStrategy</span>&lt;ResponseEntity&lt;RespBodyVo&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STATUS_CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;status_code&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUSINESS_CODE_TAG</span> <span class="operator">=</span> <span class="string">&quot;business_code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrappedRespBodyVoMonitorAfterStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>((Class&lt;ResponseEntity&lt;RespBodyVo&gt;&gt;) (Class&lt;?&gt;) ResponseEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Tag&gt; <span class="title function_">applyStrategy</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        List&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tags.add(Tag.of(STATUS_CODE_TAG, String.valueOf(result.getStatusCode().value())));</span><br><span class="line"></span><br><span class="line">        <span class="type">RespBodyVo</span> <span class="variable">body</span> <span class="operator">=</span> result.getBody();</span><br><span class="line">        <span class="keyword">if</span> (body == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tags;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> body.getCode();</span><br><span class="line">        tags.add(Tag.of(BUSINESS_CODE_TAG, code));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是抽象策略工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, Object&gt;&gt; beforeStrategyMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, Object&gt;&gt; afterStrategyMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MonitorAfterStrategy <span class="title function_">getAfterStrategy</span><span class="params">(String strategy)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (MonitorAfterStrategy) afterStrategyMap.get(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MonitorBeforeStrategy <span class="title function_">getBeforeStrategy</span><span class="params">(String strategy)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (MonitorBeforeStrategy) beforeStrategyMap.get(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeforeStrategyMap</span><span class="params">(Map beforeStrategyMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beforeStrategyMap = beforeStrategyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAfterStrategyMap</span><span class="params">(Map afterStrategyMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.afterStrategyMap = afterStrategyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是自己定义的<code>TimedAspect</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomTimedAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 所监控方法未出现异常时标签的赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_EXCEPTION_TAG_VALUE</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    <span class="comment">// 记录监控方法异常的标签</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCEPTION_TAG</span> <span class="operator">=</span> <span class="string">&quot;exception&quot;</span>;</span><br><span class="line">    <span class="comment">// 监控策略工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorStrategyFactory monitorStrategyFactory;</span><br><span class="line">    <span class="comment">// 指标仓库，自动装配</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MeterRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomTimedAspect</span><span class="params">(MeterRegistry registry, MonitorStrategyFactory monitorStrategyFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.registry = registry;</span><br><span class="line">        <span class="built_in">this</span>.monitorStrategyFactory = monitorStrategyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@within(top.tbghg.demo.monitor.aop.CustomTimed)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">timedClass</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">        Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">        <span class="type">CustomTimed</span> <span class="variable">timed</span> <span class="operator">=</span> declaringClass.getAnnotation(CustomTimed.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> perform(pjp, timed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution (@top.tbghg.demo.monitor.aop.CustomTimed * *.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">timedMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">        <span class="type">CustomTimed</span> <span class="variable">timed</span> <span class="operator">=</span> method.getAnnotation(CustomTimed.class);</span><br><span class="line">        <span class="keyword">return</span> perform(pjp, timed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">perform</span><span class="params">(ProceedingJoinPoint pjp, CustomTimed timed)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Timer.<span class="type">Sample</span> <span class="variable">sample</span> <span class="operator">=</span> Timer.start(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">exceptionClass</span> <span class="operator">=</span> DEFAULT_EXCEPTION_TAG_VALUE;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = pjp.proceed();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            exceptionClass = ex.getClass().getSimpleName();</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            record(pjp, timed, sample, exceptionClass, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(ProceedingJoinPoint pjp, CustomTimed timed, Timer.Sample sample, String exceptionClass, Object result)</span> &#123;</span><br><span class="line">        List&lt;Tag&gt; customTags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取自定义标签</span></span><br><span class="line">            customTags = getCustomTags(pjp, timed, result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;自定义标签运行异常, pjp: &#123;&#125;, CustomTimed: &#123;&#125;, result: &#123;&#125;&quot;</span>, pjp, timed, result, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 记录指标</span></span><br><span class="line">            sample.stop(</span><br><span class="line">                    Timer.builder(timed.value())</span><br><span class="line">                            .description(timed.description())</span><br><span class="line">                            .tags(timed.extraTags())</span><br><span class="line">                            .tags(EXCEPTION_TAG, exceptionClass)</span><br><span class="line">                            .tags(customTags)</span><br><span class="line">                            .publishPercentileHistogram(timed.histogram())</span><br><span class="line">                            .publishPercentiles(timed.percentiles())</span><br><span class="line">                            .register(registry));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;指标记录失败, pjp: &#123;&#125;, CustomTimed: &#123;&#125;, customTags: &#123;&#125;&quot;</span>, pjp, timed, customTags, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自定义标签</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tag&gt; <span class="title function_">getCustomTags</span><span class="params">(ProceedingJoinPoint pjp, CustomTimed timed, Object result)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Tag&gt; customTags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 处理入参相关标签</span></span><br><span class="line">        <span class="type">MonitorBeforeStrategy</span> <span class="variable">beforeStrategy</span> <span class="operator">=</span> monitorStrategyFactory.getBeforeStrategy(timed.beforeKey());</span><br><span class="line">        <span class="keyword">if</span> (beforeStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">            customTags.addAll(beforeStrategy.getTags(pjp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理返回值相关标签</span></span><br><span class="line">        <span class="type">MonitorAfterStrategy</span> <span class="variable">afterStrategy</span> <span class="operator">=</span> monitorStrategyFactory.getAfterStrategy(timed.afterKey());</span><br><span class="line">        <span class="keyword">if</span> (afterStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">            customTags.addAll(afterStrategy.getTags(pjp, result));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> customTags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，实现完毕，下面就是一些配置了</p><p>导入包、<code>application.yaml</code>添加配置 和之前的相同，不多赘述</p><p>springboot中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ImportResource(locations = &#123;&quot;classpath:spring-application.xml&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>下面就是写创建Bean的xml了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;respBodyVoMonitorAfterStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.tbghg.demo.monitor.Strategy.impl.RespBodyVoMonitorAfterStrategy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;wrappedRespBodyVoMonitorAfterStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.tbghg.demo.monitor.Strategy.impl.WrappedRespBodyVoMonitorAfterStrategy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;httpMonitorBeforeStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.tbghg.demo.monitor.Strategy.impl.HttpMonitorBeforeStrategy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;noHttpMonitorBeforeStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.tbghg.demo.monitor.Strategy.impl.NoHttpMonitorBeforeStrategy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monitorStrategyFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.tbghg.demo.monitor.Strategy.MonitorStrategyFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beforeStrategyMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;http&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;httpMonitorBeforeStrategy&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;noHttp&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;noHttpMonitorBeforeStrategy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;afterStrategyMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;respBodyVo&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;respBodyVoMonitorAfterStrategy&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;wrappedRespBodyVo&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;wrappedRespBodyVoMonitorAfterStrategy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在就已经彻底完成了，下面添加一个试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CustomTimed(value = &quot;http.server.requests.custom&quot;, description = &quot;公共API请求&quot;, histogram = true, afterKey = &quot;wrappedRespBodyVo&quot;, beforeKey = &quot;http&quot;)</span></span><br></pre></td></tr></table></figure><p>下面打开<code>http://localhost:8092/actuator/prometheus</code>结果如下（部分）：</p><p>（涉及具体业务，不方便贴图，就简单摘了一点，主要看指标的标签）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_server_requests_custom_seconds 公共API请求</span><br><span class="line"># TYPE http_server_requests_custom_seconds histogram</span><br><span class="line">http_server_requests_custom_seconds_bucket&#123;application=&quot;demo&quot;,business_code=&quot;1001&quot;,class=&quot;top.tbghg.controller.OpenApiController&quot;,exception=&quot;none&quot;,method=&quot;commonApi&quot;,requestMethod=&quot;POST&quot;,status_code=&quot;200&quot;,uri=&quot;/common_api&quot;,le=&quot;0.001&quot;,&#125; 0.0</span><br></pre></td></tr></table></figure><p>可以看到对于直方图类型，最终上报了 bucket、max、sount、sum四类数据，并且指标中包含如下标签：应用名、业务code、类、方法、http方法、异常、URI</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监控平台搭建-3-Springboot埋点&quot;&gt;&lt;a href=&quot;#监控平台搭建-3-Springboot埋点&quot; class=&quot;headerlink&quot; title=&quot;监控平台搭建(3)-Springboot埋点&quot;&gt;&lt;/a&gt;监控平台搭建(3)-Springboot埋点</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Prometheus" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/Prometheus/"/>
    
    
    <category term="Prometheus" scheme="https://tbghg.top/tags/Prometheus/"/>
    
    <category term="监控" scheme="https://tbghg.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>监控平台搭建(2)-环境搭建</title>
    <link href="https://tbghg.top/2024-08-04/e97aae35e0da/"/>
    <id>https://tbghg.top/2024-08-04/e97aae35e0da/</id>
    <published>2024-08-04T08:50:14.000Z</published>
    <updated>2024-08-04T08:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控平台搭建-2-环境搭建"><a href="#监控平台搭建-2-环境搭建" class="headerlink" title="监控平台搭建(2)-环境搭建"></a>监控平台搭建(2)-环境搭建</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>记录搭建的命令，只提供基本的注释</p><p>系统：ubuntu-24.04-amd64</p><p>镜像：ubuntu-24.04-live-server-amd64.iso</p><h2 id="初步搭建"><a href="#初步搭建" class="headerlink" title="初步搭建"></a>初步搭建</h2><p>查看ubuntu时区是否正确，否则发送告警模板时时间对不上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看时区</span></span><br><span class="line">date -R</span><br></pre></td></tr></table></figure><p>参考文章：<a class="link"   href="https://cloud.tencent.com/developer/article/1721457" >修改时区<i class="fas fa-external-link-alt"></i></a></p><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">export VERSION=2.53.1</span><br><span class="line">curl -LO https://github.com/prometheus/prometheus/releases/download/v2.53.1/prometheus-$VERSION.linux-amd64.tar.gz</span><br><span class="line">tar -xzf prometheus-$&#123;VERSION&#125;.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo mv prometheus-$&#123;VERSION&#125;.linux-amd64/ /usr/local/prometheus</span><br><span class="line">cd /usr/local/prometheus</span><br><span class="line"></span><br><span class="line">mkdir -p data</span><br><span class="line"></span><br><span class="line">sudo chmod +x prom*</span><br><span class="line">sudo cp -rp promtool /usr/bin/</span><br><span class="line"></span><br><span class="line">sudo vim /usr/lib/systemd/system/prometheus.service</span><br></pre></td></tr></table></figure><p><code>/usr/lib/systemd/system/prometheus.service</code>如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Prometheus server daemon</span><br><span class="line">Documentation=https://prometheus.io/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.yml --storage.tsdb.path=/usr/local/prometheus/data --web.enable-lifecycle</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start prometheus</span><br><span class="line">sudo systemctl status prometheus</span><br><span class="line">sudo systemctl enable prometheus</span><br></pre></td></tr></table></figure><p><code>localhost:9090</code>验证</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408041648185.png"                                        ></p><h3 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node exporter"></a>node exporter</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">curl -OL https://github.com/prometheus/node_exporter/releases/download/v1.8.2/node_exporter-1.8.2.linux-amd64.tar.gz</span><br><span class="line">tar -xzf node_exporter-1.8.2.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo mv node_exporter-1.8.2.linux-amd64/ /usr/local/node_exporter</span><br><span class="line"></span><br><span class="line">sudo vim /usr/lib/systemd/system/node_exporter.service</span><br></pre></td></tr></table></figure><p><code>/usr/lib/systemd/system/node_exporter.service</code>配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter --web.listen-address=:9100 --collector.systemd --collector.systemd.unit-whitelist=&quot;(ssh|docker|rsyslog|redis-server).service&quot; --collector.textfile.directory=/usr/local/node_exporter/textfile.collected</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start node_exporter</span><br><span class="line">sudo systemctl status node_exporter</span><br><span class="line">sudo systemctl enable node_exporter</span><br></pre></td></tr></table></figure><p>将node exporter添加到Prometheus中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/prometheus/prometheus.yml</span><br><span class="line">......</span><br><span class="line">  - job_name: &quot;node_exporter&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9100&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新Prometheus配置</span></span><br><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure><p>访问<code>localhost:9100</code></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408041958955.png"                                        ></p><p>在Prometheus中输入<code>up</code>，查看服务是否正确连接</p><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y adduser libfontconfig1 musl</span><br><span class="line">wget https://dl.grafana.com/enterprise/release/grafana-enterprise_11.1.0_amd64.deb</span><br><span class="line">sudo dpkg -i grafana-enterprise_11.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start grafana-server</span><br><span class="line">sudo systemctl status grafana-server</span><br><span class="line">sudo systemctl enable grafana-server</span><br></pre></td></tr></table></figure><ol><li>访问<code>localhost:3000</code></li><li>账号密码均为admin</li><li>导入Prometheus数据源</li><li>导入模板12633，查看系统状况</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408041959461.png"                                        ></p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install mysql-server</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl status mysql</span><br><span class="line">sudo systemctl enable mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看初始的账号密码</span></span><br><span class="line">sudo cat /etc/mysql/debian.cnf</span><br><span class="line">mysql -u&lt;账号&gt; -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root密码(mysql8.0)</span></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新使用root登录</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户目前的权限</span></span><br><span class="line">use mysql;</span><br><span class="line">select Host,User from user where user=&#x27;root&#x27;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要将root修改为外网可访问，之后的localhost换为%</span></span><br><span class="line">[该SQL根据情况可选] update user set Host=&#x27;%&#x27; where User =&#x27;root&#x27;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权【前面改为%的话就要跟着变】</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新账号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：为用户设置最大连接限制，以避免在重负载下监控抓取使服务器过载。</span></span><br><span class="line">CREATE USER &#x27;exporter&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;prometheus&#x27; WITH MAX_USER_CONNECTIONS 3;</span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#x27;exporter&#x27;@&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="mysqld-exporter"><a href="#mysqld-exporter" class="headerlink" title="mysqld exporter"></a>mysqld exporter</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">curl -LO https://github.com/prometheus/mysqld_exporter/releases/download/v0.15.1/mysqld_exporter-0.15.1.linux-amd64.tar.gz</span><br><span class="line">tar -xzf mysqld_exporter-0.15.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo mv mysqld_exporter-0.15.1.linux-amd64/ /usr/local/mysqld_exporter/</span><br><span class="line">cd /usr/local/mysqld_exporter</span><br><span class="line"></span><br><span class="line">cat &gt; .my.cnf &lt;&lt;EOF</span><br><span class="line">[client]</span><br><span class="line">user=exporter</span><br><span class="line">password=prometheus</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 默认端口9104</span></span><br><span class="line">./mysqld_exporter --config.my-cnf=.my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用systemd方式启动</span></span><br><span class="line">sudo vim /usr/lib/systemd/system/mysqld_exporter.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Prometheus</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnf</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start mysqld_exporter</span><br><span class="line">sudo systemctl enable mysqld_exporter</span><br><span class="line">sudo systemctl status mysqld_exporter</span><br></pre></td></tr></table></figure><p>配置到Prometheus中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/prometheus/prometheus.yml</span><br><span class="line">......</span><br><span class="line">  - job_name: &#x27;mysqld_exporter&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9104&#x27;]</span><br><span class="line">      labels:</span><br><span class="line">        app: mysqld_exporter</span><br><span class="line">        node: node1</span><br><span class="line">        role: mysqld_exporter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新Prometheus配置</span></span><br><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure><p>Grafana导入模板7362</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408041959965.png"                                        ></p><h2 id="Grafana配置"><a href="#Grafana配置" class="headerlink" title="Grafana配置"></a>Grafana配置</h2><p>根据需要 导入相关模板，监控Springboot应用可以使用：21319 模板</p><p>模板虽然好用 但大多情况无法满足我们的具体需求，尤其是具体应用，需要根据埋点上报的具体指标 灵活改动，并且模板中的信息堆放比较杂，我们需要把它们合并到一块方便查看</p><p>关于Grafana的具体配置会在 [4. 可视化](.&#x2F;4. 可视化.md) 详细介绍</p><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><h3 id="AlertManager"><a href="#AlertManager" class="headerlink" title="AlertManager"></a>AlertManager</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/prometheus/alertmanager/releases/download/v0.27.0/alertmanager-0.27.0.linux-amd64.tar.gz</span><br><span class="line">tar -xzf alertmanager-0.27.0.linux-amd64.tar.gz</span><br><span class="line">sudo mv alertmanager-0.27.0.linux-amd64/ /usr/local/alertmanager/</span><br></pre></td></tr></table></figure><p>下面是构建集群，<a class="link"   href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/alertmanager-high-availability#gossip-xie-yi" >Gossip协议<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机1</span></span><br><span class="line">./alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.129:8101&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机2</span></span><br><span class="line">./alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.128:8101&quot; --cluster.peer=192.168.227.129:8101</span><br></pre></td></tr></table></figure><p>检查一下运行是否正常</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/202408142047327.png"                                        ></p><p>没问题后设置自启动</p><p>P1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/alertmanager.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=AlertManager</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/alert_manager/alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.129:8101&quot; --config.file=alertmanager.yml --log.level=debug --log.format=json</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start alertmanager</span><br><span class="line">sudo systemctl enable alertmanager</span><br><span class="line">sudo systemctl status alertmanager</span><br></pre></td></tr></table></figure><p>P2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/alertmanager.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=AlertManager</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/alert_manager/alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.128:8101&quot; --cluster.peer=192.168.227.129:8101  --config.file=alertmanager.yml --log.level=debug --log.format=json</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start alertmanager</span><br><span class="line">sudo systemctl enable alertmanager</span><br><span class="line">sudo systemctl status alertmanager</span><br></pre></td></tr></table></figure><p>具体告警配置：[5. 告警配置](.&#x2F;5. 告警配置.md)</p><h3 id="mtail监控日志"><a href="#mtail监控日志" class="headerlink" title="mtail监控日志"></a>mtail监控日志</h3><ul><li><a class="link"   href="https://github.com/google/mtail" >官方地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://google.github.io/mtail/" >官方文档<i class="fas fa-external-link-alt"></i></a></li></ul><p>具体日志告警配置：不出意外的话，会在“监控平台搭建(6)-日志告警”文章中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监控平台搭建-2-环境搭建&quot;&gt;&lt;a href=&quot;#监控平台搭建-2-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;监控平台搭建(2)-环境搭建&quot;&gt;&lt;/a&gt;监控平台搭建(2)-环境搭建&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; c</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Prometheus" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/Prometheus/"/>
    
    
    <category term="Prometheus" scheme="https://tbghg.top/tags/Prometheus/"/>
    
    <category term="监控" scheme="https://tbghg.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>监控平台搭建-总纲</title>
    <link href="https://tbghg.top/2024-08-04/8e582b7771d9/"/>
    <id>https://tbghg.top/2024-08-04/8e582b7771d9/</id>
    <published>2024-08-04T07:50:14.000Z</published>
    <updated>2024-08-04T07:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控平台搭建-总纲"><a href="#监控平台搭建-总纲" class="headerlink" title="监控平台搭建-总纲"></a>监控平台搭建-总纲</h1><h2 id="【TODO】"><a href="#【TODO】" class="headerlink" title="【TODO】"></a>【TODO】</h2><ul><li>环境搭建：缺少 AlertManager集群搭建</li><li>可视化：未填写</li><li>告警配置：HTTP待改写 应用未填写</li><li>日志告警：配置与使用 未填写</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>监控平台的搭建较为繁琐，下面分为一下几个部分进行讲解：</p><ul><li>基础知识</li><li>环境搭建</li><li>springboot埋点</li><li>可视化</li><li>告警配置</li><li>日志告警</li></ul><h2 id="监控平台结构"><a href="#监控平台结构" class="headerlink" title="监控平台结构"></a>监控平台结构</h2><ul><li>Prometheus</li><li>Exporter<ul><li>mysql - mysqld exporter</li><li>主机 - node exporter</li><li>Java应用<ul><li><code>Springboot Actuator</code>上报JVM信息        </li><li>自行实现HTTP相关埋点(AOP)</li><li>mtail监控日志</li></ul></li></ul></li><li>AlertManager(集群 - Gossip协议 告警去重)<ul><li>Prometheus</li><li>主机</li><li>mysql</li><li>http</li><li>日志(mtail)</li></ul></li><li>Grafana<ul><li>能用模板用模板</li><li>用不了自己配吧</li></ul></li></ul><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Pushgateway"><a href="#Pushgateway" class="headerlink" title="Pushgateway"></a>Pushgateway</h3><p>Q1：需要使用Pushgateway吗？</p><p>不使用，也不需要使用。</p><p>首先来举个使用Pushgateway场景的例子：</p><p>我现在有一个临时任务脚本或批处理脚本，如果要上报Prometheus则需要开启对应http接口，按照对应格式编写，持续等待，直到Prometheus将该数据拉取才能停止</p><p>当然我们可以直接使用Pushgateway，任务完成后将要上报的数据主动上报给Pushgateway，也就是从拉模式变成了推模式，实现则更为简单了一些</p><p>同时注意，Pushgateway并不会将我们上推的数据按照时间序列的形式保存，同一个指标在不同时间上传多次会被覆盖，只留下最新的</p><p>对于当前的需求来说，完全不需要使用Pushgateway</p><h3 id="拉取时间间隔"><a href="#拉取时间间隔" class="headerlink" title="拉取时间间隔"></a>拉取时间间隔</h3><p>Q2：假设Prometheus拉取时间是15s一次，而应用的数据是每秒计算一次，这样会导致中间14s的数据丢失吗，例如max、平均响应时长、TP90</p><p>A2：并不会，首先需要明确下面几点：</p><ul><li>不管是 摘要 还是 直方图，它们都会累计的去记录max、count、sum</li><li>直方图 中的桶是累计的，并不是每秒之类的</li></ul><p>下面分类型讨论一下，同样我们假设Prometheus每隔15s拉取一次</p><ul><li>最大响应时长：max是累计更新的，肯定是准确的，不需要考虑</li><li>平均响应时长：计算方式为 选定一段区间，总时长的差值&#x2F;这段时间的响应数量，得到的就是这个时间段的平均响应时长，并且上报的数据中 总时长和总共数量也都有</li></ul><p>最后则是分位点：</p><ul><li>摘要：摘要计算分位点有一个滑动窗口，默认的滑动窗口时间长度是 2 分钟，滑动时间间隔是 1 秒。分位点计算基于最近 2 分钟内收集的数据，并且每秒钟更新一次，如果出现极端数据，还是会反映到Prometheus中的，除非拉取时间比滑动窗口时间还长</li><li>直方图：它的桶是累积的，Prometheus是根据桶来估算出分位点的，所以也没有影响。但是需要注意，计算一段时间内的TP90时，指定的时间窗口要大于向Prometheus上报的时间间隔</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监控平台搭建-总纲&quot;&gt;&lt;a href=&quot;#监控平台搭建-总纲&quot; class=&quot;headerlink&quot; title=&quot;监控平台搭建-总纲&quot;&gt;&lt;/a&gt;监控平台搭建-总纲&lt;/h1&gt;&lt;h2 id=&quot;【TODO】&quot;&gt;&lt;a href=&quot;#【TODO】&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Prometheus" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/Prometheus/"/>
    
    
    <category term="Prometheus" scheme="https://tbghg.top/tags/Prometheus/"/>
    
    <category term="监控" scheme="https://tbghg.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2024-07月记</title>
    <link href="https://tbghg.top/2024-07-28/806f146494d1/"/>
    <id>https://tbghg.top/2024-07-28/806f146494d1/</id>
    <published>2024-07-28T11:25:35.000Z</published>
    <updated>2024-07-28T11:25:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是7月28日，日子正好挺特殊，入职刚好满一个月，正好记录一下这一个月的打工生活。主观感想方便比较多</p><h2 id="近期状况"><a href="#近期状况" class="headerlink" title="近期状况"></a>近期状况</h2><p>先简单列一下想聊的几个方面：公司、同事、工作、自身状态、北京、生活(衣食住行之类)</p><h3 id="自身状态"><a href="#自身状态" class="headerlink" title="自身状态"></a>自身状态</h3><p>首先是自身状态吧，入职前其实挺焦虑的，分三个方面：</p><ul><li>自己的眼睛太差了，不知道能不能接受互联网公司的强度</li><li>自己是从go转java的，java的基础比较差，相关的代码写的也不多，不知道能不能干好</li><li>不知道自己能不能和同事打好交道，希望自己不要表现的太内向</li></ul><p>这一个月待下来，感觉还是可以接受的，或者说比我想象中预期好太多了。</p><ul><li>首先是眼睛这块，字体调大些，平常眼睛累了就擦擦眼镜休息下，或者上个厕所，还算可以接受吧</li><li>之后是转语言这里，没自己想象中那么困难，代码看多了慢慢就会了，并且刚接触的需求都是较为基础的，不需要太多的知识量，这段时间按照自己的节奏慢慢来就行，没啥好担心的</li><li>最后是人际关系这里(其实一开始最担心的是这个，其次是眼睛)，比起之前实习的时候，这次不怎么紧张了，或者说更加自然了吧，不想太多正常交流就行</li></ul><p>有时认为很麻烦或者很难处理的事，其实到了面前会觉得也就那样</p><p>之前焦虑的事，现在发现都没什么，有点松了口气，逐渐适应这个生活节奏了</p><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>上班时间比我想象中久了些，但算是完全可以接受吧，或者说有种回到高中的感觉(作息听起来很累，但当时没觉得什么)？或许等我老了后会感慨“哇，我以前精力这么旺盛的吗”哈哈。</p><p>公司带食堂确实太方便了，并且饭菜也较为可口，样式也挺丰富，还是挺喜欢的。</p><p>连接AB座的玻璃桥，每次经过的时候总会往下望，很有意思</p><p>电梯也还可以，不算太挤吧，可以接受，相比之下之前实习的公司等电梯太折磨了</p><p>通勤也比较方便，公交车或者共享单车，现在买了个山地车，更没啥问题了，就是之后停车场要维护一段时间，雨天停车估计会麻烦些</p><p>总体来说可以接受吧</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>该怎么形容呢，逐渐走向正轨？比起在上海的那段时间，现在过的更加舒适吧，做对比的话就是一下几个方面：</p><ul><li>通勤<ul><li>上海租的那间，通勤较为麻烦，只能共享单车或者打车，并且早上共享单车经常没有，并且进入大夏天后再也不想骑车，就变成了天天打车的情况，开销很大</li><li>北京租的这间，门口有公交站，旁边有一堆共享单车，并且自己还买了山地车，通勤很方便，并且距离比之前近了一公里</li></ul></li><li>屋子<ul><li>上海租的那间，六平米的小窝，住的比较憋屈吧，完全没有多余的活动空间</li><li>北京租的这间，带独卫，早上没有人抢占卫生间，并且用洗衣机、淋浴都很方便(体验过之后已经不有些离不开独卫了，哈哈)。并且屋子比较大，买了个折叠柜，收拾完之后有很充足的空间，甚至现在有养猫的打算(房东已经同意了，就看自己啥时候下决心了)</li></ul></li></ul><p>租的房子好坏与否 还是很重要的，很直观的决定了一个人的生活幸福指数</p><p>贴一下屋子吧</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/room1.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/room2.jpg"                                        ></p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/resource/bed.jpg"                                        ></p><p>吃饭方面的话，稍微有些不方便，租的地方旁边没有饭店，只有个大马路，得骑车子去别的地方吃，或者直接点外卖，当然也可以直接去公司吃</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>比较满意现在的生活吧，公司可以、同事很棒、租的房很合适、通勤方便，不过没啥时间打罪恶装备了，毕竟是格斗游戏，打起来手刚热就该睡觉了(挨了半天的揍，手感来了，要睡了orz)，还是发展些别的兴趣爱好吧</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>希望能顺利通过试用期吧，踏踏实实的干，生活稳定之后养个猫猫🐱</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是7月28日，日子正好挺特殊，入职刚好满一个月，正好记录一下这一个月的打工生活。主观感想方便比较多&lt;/p&gt;
&lt;h2 id=&quot;近期状况&quot;&gt;&lt;a href=&quot;#近期状况&quot; class=&quot;headerlink&quot; title=&quot;近期状况&quot;&gt;&lt;/a&gt;近期状况&lt;/h2&gt;&lt;p&gt;先简单</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="月记" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E6%9C%88%E8%AE%B0/"/>
    
    
    <category term="月记" scheme="https://tbghg.top/tags/%E6%9C%88%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>做菜笔记</title>
    <link href="https://tbghg.top/2024-06-24/d32a6df577a8/"/>
    <id>https://tbghg.top/2024-06-24/d32a6df577a8/</id>
    <published>2024-06-24T18:01:35.000Z</published>
    <updated>2024-06-24T18:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在外租房，不咋做饭，但想着还是记录下，尽量学一道记一道吧</p><p>同租的室友做饭好香啊啊啊，不想天天吃外卖了</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>炒鸡蛋🥚：多放油，要不会粘锅，多油+大火</li><li>番茄炒蛋：先放蛋！油可以少些，放了蛋液后开搅，然后放🍅，做卤子就加点水滚滚</li></ul><h2 id="菜类"><a href="#菜类" class="headerlink" title="菜类"></a>菜类</h2><h2 id="肉类"><a href="#肉类" class="headerlink" title="肉类"></a>肉类</h2><ul><li>炖鸡块：拿水焯一遍，油锅中放 姜 花椒 八角 ，放鸡块，放葱蒜，加水没过去，加生抽 老抽 料酒 盐 香叶，全放高压锅里，压一压</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在外租房，不咋做饭，但想着还是记录下，尽量学一道记一道吧&lt;/p&gt;
&lt;p&gt;同租的室友做饭好香啊啊啊，不想天天吃外卖了&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>与外界沟通</title>
    <link href="https://tbghg.top/2024-06-24/026cc86f1a34/"/>
    <id>https://tbghg.top/2024-06-24/026cc86f1a34/</id>
    <published>2024-06-24T17:08:53.000Z</published>
    <updated>2024-06-24T17:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面这篇文章写的十分主观，也是第一次写这种性质的随笔，算是对以前的自己做个小吐槽</p><p>—————————分界线—————————</p><p>我一直以来都过分在乎别人是怎么看我的，好多事做的都很小心，说话发消息前也会确认好多遍用词确保不会让对方反感。</p><p>渐渐地养成了稍微内向些的性格，特别是和不熟悉的人接触时，做的任何事都会特别小心。</p><p>当和别人混熟后，各种行为都会变得大胆起来，或者说放得开了吧。但这种性格肯定不合适，这个世界上大多数人只会见到几面，畏手畏脚下去 只会给别人一个内向的印象 然后被对方忘掉。</p><p>曾经在B站实习时，杰哥说我性格太内向了，最好做做改变。</p><p>我听到的第一反应其实是不甘心，想让大家知道其实我是一个十分闹腾的人，然而我在那里就算待了八个月，还是小心翼翼的，不敢放开。</p><p>回到学校之后，我开始关注我和熟悉的人到底是怎么沟通的，吃饭时在聊什么，走路时在聊什么，但反而发现根本没什么规律，形容起来有些天马行空吧，想到什么话题就抛什么，就算抛出来大家没啥想法也会直接过去，比较重要的是，我们并非一直有话题，此时大家只是一起吃着饭一起散着步。</p><p>再对比我在B站的情况，和同事吃饭时，总觉得应该说些什么，显得自己不那么内向，然后绞尽脑汁想着话题，说话也小心翼翼的，抛出话题没人回应后还多少有些苦恼。</p><p>其实说错话也没什么的吧，大家根本不会在乎的，就像让我想“有谁哪个时间说错了什么话让我十分反感”，我这种十分敏感的人也只会想到一两次。随心所欲一些自己会轻松不少，没必要过分在乎别人对自己的看法，自己在别人那算不上什么的，我这种属于与空气斗智斗勇了，哈哈。</p><p>在上海的那段时间没人陪着说话还是挺无聊的，有些憋坏了吧，之后向陌生人搭话越来越熟练了，像是出租车司机、便利店老板、群里的水友等等。</p><p>最近几天和别人搭话，这些无心之举却给我生活添了不少帮助，像是</p><ul><li>和快递站的阿姨唠嗑，了解到这个小区的具体情况，以及生活上的小知识</li><li>和宠物店老板询问门口猫猫的情况，了解到这个猫猫的故事</li><li>群里帮群友答疑，被另一位学长发现，互加好友后畅谈一番，聊了之后的人生规划</li><li>…等等</li></ul><p>这些看似无意义的简单的沟通，却多少对生活有些帮助，并且对比在上海的无聊自闭生活，这些对话也是给生活添了不少的色彩吧，至少我很喜欢这种无意义的沟通，和别人交流雀食是一件很有趣的事。</p><p>28号入职，会遇到新的同事，遇到新的朋友，希望自己之后的生活能更加多彩吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面这篇文章写的十分主观，也是第一次写这种性质的随笔，算是对以前的自己做个小吐槽&lt;/p&gt;
&lt;p&gt;—————————分界线—————————&lt;/p&gt;
&lt;p&gt;我一直以来都过分在乎别人是怎么看我的，好多事做的都很小心，说话发消息前也会确认好多遍用词确保不会让对方反感。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="生活" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="https://tbghg.top/categories/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>java学习笔记</title>
    <link href="https://tbghg.top/2023-11-27/bd32b3914914/"/>
    <id>https://tbghg.top/2023-11-27/bd32b3914914/</id>
    <published>2023-11-27T08:13:56.000Z</published>
    <updated>2023-11-27T08:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>记录一下学习<code>java</code>时觉得重点或一时没记住的知识点，方便日后复习，持续更新，有东西就加</p><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="认识java"><a href="#认识java" class="headerlink" title="认识java"></a>认识java</h3><p>Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。</p><p>解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。</p><p>而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。</p><p>对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p><ul><li>Java SE(Standard Edition): 标准版，包含标准的JVM和标准库 </li><li>Java EE(Enterprise Edition): 企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等 </li><li>Java ME(Micro Edition): 针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><ul><li>JRE(Java Runtime Environment): 运行Java字节码的虚拟机</li><li>JDK(Java Development Kit)</li></ul><p>如果只有Java源码，要编译成Java字节码，就需要JDK，JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─    ┌──────────────────────────────────┐</span><br><span class="line">│     │     Compiler, debugger, etc.     │</span><br><span class="line">│     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line">│   │  │                                  │</span><br><span class="line">│  JRE │      JVM + Runtime Library       │</span><br><span class="line">│   │  │                                  │</span><br><span class="line">└─  └─ └──────────────────────────────────┘</span><br><span class="line">┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">│Windows││ Linux ││ macOS ││others │</span><br><span class="line">└───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure><ul><li>JSR规范：Java Specification Request</li><li>JCP组织：Java Community Process</li></ul><p>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</p><p>所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。</p><p>一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：</p><ul><li>RI：Reference Implementation</li><li>TCK：Technology Compatibility Kit</li></ul><p>比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。<br>如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。</p><p>通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。</p><p>运行一个Demo，文件名为<code>Hello.java</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>javac</code>命令将<code>Hello.java</code>文件编译成字节码文件<code>Hello.class</code>，然后用<code>java</code>命令执行这个字节码文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Desktop</span>\<span class="title">Java_project</span>&gt;<span class="title">javac</span> <span class="title">Hello.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">Desktop</span>\<span class="title">Java_project</span>&gt;<span class="title">dir</span></span></span><br><span class="line"><span class="function">2023/11/30  16:05    &lt;<span class="title">DIR</span>&gt;          .</span></span><br><span class="line"><span class="function">2023/11/29  22:19    &lt;<span class="title">DIR</span>&gt;          ..</span></span><br><span class="line"><span class="function">2023/11/30  16:05               417 <span class="title">Hello.class</span></span></span><br><span class="line"><span class="function">2023/11/30  16:04               122 <span class="title">Hello.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">Desktop</span>\<span class="title">Java_project</span>&gt;<span class="title">java</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="function"><span class="title">Hello</span>, <span class="title">world</span>!</span></span><br></pre></td></tr></table></figure><p>注意：给虚拟机传递的参数Hello是我们定义的类名，虚拟机自动查找对应的class文件并执行,</p><p>Java 11之后，可以通过<code>java Hello.java</code>可以直接运行一个单文件源码，需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的。<br>所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。</p><ul><li>一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致； </li><li>使用<code>javac</code>可以将.java源码编译成.class字节码； </li><li>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>Java是面向对象的语言，一个程序的基本单位就是class，类名要求：必须以英文字母开头(大写)，后接字母，数字和下划线的组合</p><p>Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</p><p>方法名也有命名规则，命名和class一样，但是首字母小写，在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 方法名是main</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// 语句分号结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释有三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">这是个注释</span></span><br><span class="line"><span class="comment">还是个注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> tbghg</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>第三种以<code>/**</code>开头，以<code>*/</code>结束，如果有多行，每行通常以星号开头，需要写在类和方法的定义处，可以用于自动创建文档。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>基本类型如下：</p><ul><li>整数类型：byte，short，int，long </li><li>浮点数类型：float，double </li><li>字符类型：char </li><li>布尔类型：boolean</li></ul><p>计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit，不同数据类型所占字节数：</p><ul><li>byte      1字节    -128 ~ 127</li><li>short     2字节    -32768 ~ 32767</li><li>char      2字节</li><li>int       4字节    -2147483648 ~ 2147483647</li><li>float     4字节</li><li>long      8字节    -9223372036854775808 ~ 9223372036854775807</li><li>double    8字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">2_000_000_000</span>; <span class="comment">// 加下划线更容易识别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">0xff0000</span>; <span class="comment">// 十六进制表示的16711680</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">0b1000000000</span>; <span class="comment">// 二进制表示的512</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">9000000000000000000L</span>; <span class="comment">// long型的结尾需要加L</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">900</span>; <span class="comment">// 没有加L，此处900为int，但int类型可以赋值给long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">900L</span>; <span class="comment">// 错误：不能把long型赋值给int</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 错误：不带f结尾的是double类型，不能赋值给float</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.79e308</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> -<span class="number">1.79e308</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isGreater</span> <span class="operator">=</span> <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// 计算结果为true</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span>; <span class="comment">// 计算结果为false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符类型char表示一个字符。字符使用单引号。一个char保存一个Unicode字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;    <span class="comment">// Unicode编码，都占用两字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">zh</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;  <span class="comment">// Unicode编码，都占用两字节</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(zh);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以直接用转义字符\u+Unicode编码来表示一个字符，必须使用十六进制</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>; <span class="comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数运算：</p><ul><li>整数的除法对于除数为0时运行时将报错，但编译不会报错</li><li>整数除法不能整除会舍弃小数</li><li>溢出不会出错，却会得到一个奇怪的结果</li><li><code>i++ ++i &lt;&lt; &gt;&gt; &gt;&gt;&gt;无符号右移 &amp; | ~非 ^异或</code></li><li>类型不统一时，会自动转换：在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型</li><li>支持强制转换，如<code>short s = (short) i</code></li></ul><p>浮点数运算：</p><ul><li>只能进行加减乘除这些数值计算，不能做位运算和移位运算</li><li>浮点数常常无法精确表示，如0.1，二进制是无限循环小数，但0.5又可以精确地表示，因此，浮点数比较大小有时是不准确的(见下方代码)</li><li>其他与整形运算相似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0.1在二进制是无限循环小数，只能存储一个近似值，所以x与y不相等</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 观察x和y是否相等:</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0.5在二进制中可精确表示，所以x与y相等</span></span><br><span class="line">        x = <span class="number">5.0</span> / <span class="number">10</span>;</span><br><span class="line">        y = <span class="number">1</span> - <span class="number">5.0</span> / <span class="number">10</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">0.1</span></span><br><span class="line"><span class="comment">0.09999999999999998</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">0.5</span></span><br><span class="line"><span class="comment">0.5</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果非要比较，可以设置一个阈值，看二者相差是否在这之间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较x和y是否相等，先计算其差的绝对值:</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布尔运算：</p><ul><li>短路运算：如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果</li><li>支持三元运算符：<code>b ? x : y</code></li></ul><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>除了基本类型，剩下的都是引用类型，最常用的是<code>String</code>，引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</p><p><code>String</code>，用双引号”…”表示字符串。一个字符串可以存储0个到任意个字符，转义：</p><ul><li>&quot; 表示字符”</li><li>&#39; 表示字符’</li><li>\ 表示字符\</li><li>\n 表示换行符</li><li>\r 表示回车符</li><li>\t 表示Tab</li><li>\u#### 表示一个Unicode编码的字符</li></ul><p>字符串拼接可直接使用<code>+</code>。如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。</p><p>从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 末尾会带上换行，总共五行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 末尾没换行，共四行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC&quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// s1是null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1; <span class="comment">// s2也是null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// s3指向空字符串，不是null</span></span><br></pre></td></tr></table></figure><p>常量：定义变量的时候，如果加上final修饰符，这个变量就变成了常量，常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> PI * r * r;</span><br><span class="line">PI = <span class="number">300</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>有些时候，类型的名字太长，写起来比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>这个时候，如果想省略变量类型，可以使用var关键字，编译器会根据赋值语句自动推断出变量sb的类型是<code>StringBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>多行语句用{ }括起来，括号内部是自身的范围，在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 变量i从这里开始定义</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 变量x从这里开始定义</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">// 变量s从这里开始定义</span></span><br><span class="line">                &#125; <span class="comment">// 变量s作用域到此结束</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">//                System.out.println(s);  // 报错，无法解析符号 &#x27;s&#x27;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 注意，这是一个新的变量s，它和上面的变量同名，</span></span><br><span class="line">                <span class="comment">// 但是因为作用域不同，它们是两个不同的变量:</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="comment">// 变量x和s作用域到此结束</span></span><br><span class="line">        &#125; <span class="comment">// 变量i作用域到此结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以进一步简写为</span></span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false</li><li>数组一旦创建后，大小就不可改变</li></ul><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>&#x2F;&#x2F; todo 输入输出<br>输入输出：这块之后系统整理下</p><p>if判断语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件满足时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用类型判断内容相等要使用equals()，注意避免NullPointerException【重点】</li><li>浮点数判断相等不能直接用&#x3D;&#x3D;运算符</li><li>不推荐省略花括号{}  一条语句时大括号可以省，但不推荐</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        <span class="comment">// 引用类型 使用equals判断相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 equals s2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 必须先判断null，否则会报NullPointerException错误</span></span><br><span class="line">        <span class="keyword">if</span> (s3 != <span class="literal">null</span> &amp;&amp; s3.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch-case语句</p><ul><li>switch的计算结果必须是整型、字符串或枚举类型</li><li>case语句具有穿透性，要带break，可以打开fall-through警告</li><li>不要漏掉default，可以打开missing default警告</li><li>Java 14开始，switch语句正式升级为表达式，使用<code>-&gt;</code>格式时，不再需要break，允许携带返回值，通过yield提前中断(类似于return)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="comment">// 直接返回1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 直接返回2</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 整个代码块用&#123;&#125;包裹，yield可提前结束switch-case语句，并返回结果</span></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">                <span class="keyword">yield</span> code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">    循环语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    执行循环语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (初始条件; 循环检测条件; 循环后更新计数器) &#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组时可使用for-each，n为ns中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也是支持break、continue的</span></span><br></pre></td></tr></table></figure><p>数组操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接打印，打印出来的是JVM中的地址，如</span></span><br><span class="line">        System.out.println(ns);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.print(n+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// java提供了Arrays.toString方法便于打印</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* output:</span></span><br><span class="line"><span class="comment">        [I@b4c966a</span></span><br><span class="line"><span class="comment">        1 1 8 3 5 4 </span></span><br><span class="line"><span class="comment">        [1, 1, 8, 3, 5, 4]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 排序</span></span><br><span class="line">        </span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        <span class="keyword">if</span> (Arrays.toString(ns).equals(<span class="string">&quot;[1, 1, 3, 4, 5, 8]&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 二维数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] ns2 = &#123;</span><br><span class="line">                &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">                &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以两层for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : ns2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">                System.out.print(n);</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以Arrays.deepToString()打印</span></span><br><span class="line">        System.out.println(Arrays.deepToString(ns2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* output:</span></span><br><span class="line"><span class="comment">        1 2 3 4 </span></span><br><span class="line"><span class="comment">        5 6 7 8 </span></span><br><span class="line"><span class="comment">        9 10 11 12 </span></span><br><span class="line"><span class="comment">        [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP</p><ul><li>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 </li><li>class和instance是“模版”和“实例”的关系，定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例 </li><li>class定义的field，在每个instance都会拥有各自的field，且互不干扰 </li><li>通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance</li><li>指向instance的变量都是引用变量</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法内部可以使用this访问当前实例</li><li>方法支持可变参数，如<code>public void setNames(String... names) &#123;&#125;</code><ul><li>可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null</li><li><code>setNames</code>此时的参数names是<code>String[]</code>类型</li></ul></li></ul><p>构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">15</span>); <span class="comment">// 既可以调用带参数的构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 也可以调用无参数构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例</li><li>没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法</li><li>可以定义多个构造方法，编译器根据参数自动判断</li><li>可以在一个构造方法内部调用另一个构造方法，便于代码复用</li></ul><p>方法重载(overload)：如果有一系列方法，它们的功能都是类似的，<strong>只有参数有所不同</strong>，那么，可以把这一组方法名做成同名方法。</p><p><strong>注意：方法重载的返回值类型通常都是相同的。</strong></p><p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。举个例子，String类提供了多个重载方法indexOf()，可以查找子串：</p><ul><li>int indexOf(int ch)：根据字符的Unicode码查找</li><li>int indexOf(String str)：根据字符串查找</li><li>int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置</li><li>int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li>继承是面向对象编程的一种强大的代码复用方式</li><li>Java只允许单继承，所有类最终的根类是Object</li><li>protected允许子类访问父类的字段和方法</li><li>子类的构造方法可以通过super()调用父类的构造方法</li><li>可以安全地向上转型为更抽象的类型</li><li>可以强制向下转型，最好借助instanceof判断</li><li>Java 14后instanceof判断完可直接赋值</li><li>子类和父类的关系是is，has关系不能用继承，可考虑组合</li></ul><p>使用extends关键字来实现继承。超类（super class），父类（parent class），基类（base class） | 子类（subclass），扩展类（extended class） </p><p><strong>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</strong></p><p>子类无法访问父类的private字段或者private方法，为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问</p><p>使用super可以指向父类（对应this），子类的构造方法必须调用父类的构造方法，方式为<code>super()</code>并携带上对应参数</p><p>正常情况下，只要某个class没有final修饰符，那么任何类都可以从该class继承。从Java 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称。</p><ul><li>向上转型：把一个子类型安全地变为更加抽象的父类型【没问题】</li><li>向下转型：把一个父类类型强制转型为子类类型【看原本是什么，如果原本就能转那没问题，否则会报错<code>ClassCastException</code>】</li></ul><p>向下转型举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure><p>Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。</p><p>为了防止向下转型发生问题，一般先通过<code>instanceof</code>方法判断是否为该实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(s.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// instanceof判断完成后转换并赋到s中</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            <span class="comment">// 可以直接使用变量s:</span></span><br><span class="line">            System.out.println(s.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为</li><li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态</li><li>final修饰符有多种作用<ul><li>final修饰的方法可以阻止被覆写</li><li>final修饰的class可以阻止被继承</li><li>final修饰的field必须在创建对象时初始化，随后不可修改</li></ul></li></ul><p>重载overload方法签名不同，覆写(重写)override方法签名不同相同</p><p>加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p><p>多态的特性就是，运行期才能动态决定调用的子类方法。多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        p.run(); <span class="comment">// 应该打印Person.run还是Student.run?</span></span><br><span class="line"></span><br><span class="line">        p.runTwice(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        <span class="comment">// run方法有可能会被重写，我们并不知道执行时是person的还是重写后student的，只有根据运行时期实际类型才知道</span></span><br><span class="line">        p.run();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被final修饰，无法重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的类无法被继承</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="comment">// 可直接赋值，也可在构造方法中赋值，之后不能再修改该字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。</p><p>必须把Person类本身也声明为abstract，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们无法实例化一个抽象类：<code>Person p = new Person(); // 编译错误</code>。抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。</p><p>当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例，这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）</li><li>不需要子类就可以实现业务逻辑（正常编译）</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code></p><p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>：<code>class Student implements Person, Hello &#123;...&#125;</code></p><table><thead><tr><th align="left"></th><th align="left">abstract class</th><th>interface</th></tr></thead><tbody><tr><td align="left">继承</td><td align="left">只能extends一个class</td><td>可以implements多个interface</td></tr><tr><td align="left">字段</td><td align="left">可以定义实例字段</td><td>不能定义实例字段，可定义静态字段且为<code>final</code>类型</td></tr><tr><td align="left">抽象方法</td><td align="left">可以定义抽象方法</td><td>可以定义抽象方法</td></tr><tr><td align="left">非抽象方法</td><td align="left">可以定义非抽象方法</td><td>可以定义default方法</td></tr></tbody></table><p>在接口中，可以定义default方法。实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p>default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;记录一下学习&lt;code&gt;java&lt;/code&gt;时觉得重点或一时没记住的知识点，方便日后复习，持续更新，有东西就加&lt;/p&gt;
&lt;h2 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#java基础&quot; class=&quot;headerlink&quot; title=&quot;jav</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="语言" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="java" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/java/"/>
    
    
    <category term="java" scheme="https://tbghg.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Go项目-持续部署-阿里云服务器</title>
    <link href="https://tbghg.top/2023-11-15/66090ced97fe/"/>
    <id>https://tbghg.top/2023-11-15/66090ced97fe/</id>
    <published>2023-11-15T12:25:05.000Z</published>
    <updated>2023-11-15T12:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>CI&#x2F;CD 这块自己一直都是一知半解的，最近有个七牛云的比赛，持续部署做的比较敷衍，webhooks + <a class="link"   href="https://hookdoo.com/" >hookdoo<i class="fas fa-external-link-alt"></i></a>，目前赛后复盘，把这块恶补一下</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>参考文章：<a class="link"   href="https://www.zhihu.com/question/23444990/answer/89426003" >持续集成、持续交付、持续部署 基本概念<i class="fas fa-external-link-alt"></i></a></p><ul><li>CI 持续集成（Continuous Integration）</li><li>CD 持续交付（Continuous Delivery）</li><li>CD 持续部署（Continuous Deployment）</li></ul><p>持续集成</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311151142375.png"                        alt="img"                 ></p><p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p><p>持续集成 (CI) 是一种需要频繁提交代码到共享仓库的软件实践。 频繁提交代码能较早检测到错误，减少在查找错误来源时开发者需要调试的代码量。 频繁的代码更新也更便于从软件开发团队的不同成员合并更改。 这对开发者非常有益，他们可以将更多时间用于编写代码，而减少在调试错误或解决合并冲突上所花的时间。</p><p>提交代码到仓库时，可以持续创建并测试代码，以确保提交未引入错误。 您的测试可以包括代码语法检查（检查样式格式）、安全性检查、代码覆盖率、功能测试及其他自定义检查。</p><p>持续交付</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311151143167.png"                        alt="img"                 ></p><p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（<em>production-like environments</em>）中。</p><p>持续部署</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311151146073.png"                        alt="img"                 ></p><p>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。</p><p>总结一下：持续集成是构建测试代码并检测与源代码是否存在冲突，持续交付是交付给QA，持续部署是尽快部署生产</p><h2 id="持续部署-实战练习"><a href="#持续部署-实战练习" class="headerlink" title="持续部署-实战练习"></a>持续部署-实战练习</h2><p>用最近做的七牛云1024比赛项目来练习吧，一个 Golang 后端项目，持续交付不需要做，持续集成参考 GitHub Action 的文档即可，在此简单看下持续部署</p><p>我们想把代码部署到阿里云服务器上，步骤如下：</p><ol><li>GitHub Action构建项目</li><li>将构建好的二进制文件传到阿里云服务器</li><li>服务器直接运行二进制文件</li></ol><p>首先，在 GitHub secrets 中配置阿里云服务器登录信息</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/image-20231115195158978.png"                                        ></p><p>然后开始编写 workflow 配置文件，我们可以直接选用 GitHub Actions 中的模板</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311151956399.png"                        alt="image-20231115195651255"                 ></p><p>基础的语法参考 GitHub Actions 的文档，我们想要部署到自己的服务器，需要用到 <a class="link"   href="https://github.com/easingthemes/ssh-deploy" >easingthemes&#x2F;ssh-deploy<i class="fas fa-external-link-alt"></i></a> 和  <a class="link"   href="https://github.com/appleboy/ssh-action/blob/master/README.zh-tw.md" >appleboy&#x2F;ssh-action<i class="fas fa-external-link-alt"></i></a>，前者是将文件通过 scp 命令传入，后者是直接执行命令</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This workflow will build a golang project</span></span><br><span class="line"><span class="comment"># For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-go</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Go</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;master&quot;</span> ]</span><br><span class="line"><span class="comment"># 持续部署时只跑主分支上的master，PR不用管</span></span><br><span class="line"><span class="comment">#  pull_request:</span></span><br><span class="line"><span class="comment">#    branches: [ &quot;master&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Go</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="string">&#x27;1.21&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">CGO_ENABLED=0</span> <span class="string">go</span> <span class="string">build</span> <span class="string">-o</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sent</span> <span class="string">to</span> <span class="string">ALIYUN</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@main</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment">#私钥</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment">#scp参数</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&quot;-rltgoDzvO --delete&quot;</span></span><br><span class="line">          <span class="comment">#源目录</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">&quot;./server ./cmd/run.sh&quot;</span></span><br><span class="line">          <span class="comment">#服务器IP</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span>  <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment">#用户</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_REMOTE_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment">#目标地址</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">&quot;/root/utopia-back&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">on</span> <span class="string">ALIYUN</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span>  <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_REMOTE_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_PWD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            cd /root/utopia-back</span></span><br><span class="line"><span class="string">            chmod +x ./run.sh</span></span><br><span class="line"><span class="string">            ./run.sh</span></span><br></pre></td></tr></table></figure><p>编译时尽量使用静态编译（<code>CGO_ENABLED=0</code>），保证服务器不用配置额外环境，可直接运行</p><p>scp 命令用到的参数如下：</p><ul><li><code>-r</code>: 递归复制整个目录结构，包括子目录和文件</li><li><code>-l</code>: 保持源文件和目标文件的链接关系</li><li><code>-t</code>: 在远程服务器上创建与源目录相同的目录结构</li><li><code>-g</code>: 保持文件的原始属性，包括所有者、组和权限</li><li><code>-o</code>: 保持源文件的时间戳</li><li><code>-D</code>: 启用调试模式，在传输过程中显示调试信息</li><li><code>-z</code>: 在传输过程中启用压缩，以减少数据传输的大小</li><li><code>-v</code>: 显示详细的传输信息，包括每个文件的名称和传输进度</li><li><code>-O</code>: 保持源文件的所有者和组</li><li><code>--delete</code>: 删除远程目标目录中存在但源目录中不存在的文件</li></ul><p><code>./cmd/run.sh</code>内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查8080端口的占用情况</span></span><br><span class="line">port=8080</span><br><span class="line">pid=$(lsof -t -i:$port)</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$pid&quot; ]; then</span><br><span class="line">  echo &quot;端口 $port 没有被占用。&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;端口 $port 被进程 $pid 占用。&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">终止占用8080端口的进程</span></span><br><span class="line">  echo &quot;终止进程 $pid ...&quot;</span><br><span class="line">  kill $pid</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;开始启动Go程序...&quot;</span><br><span class="line">nohup ./server &gt; output.log 2&gt;&amp;1 &amp;</span><br><span class="line">sleep 2 # 等待一段时间以确保程序已经启动</span><br><span class="line">pid=$!</span><br><span class="line">if [ -n &quot;$(ps -p $pid -o pid=)&quot; ]; then</span><br><span class="line">  echo &quot;Go程序已成功启动。&quot;</span><br><span class="line">  exit 0</span><br><span class="line">else</span><br><span class="line">  echo &quot;Go程序启动失败，请检查错误信息。&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>另外关于端口，可以在<code>appleboy/ssh-action</code>里指定，通过参数的形式写进<code>run.sh</code></p><p>现在当我们提交后，观察Github Actions，发现流程正常通过，且程序正常部署</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311152014142.png"                        alt="image-20231115201428014"                 ></p><blockquote><p>当然，上面实现的是比较繁琐的，直接用<code>docker</code>会好很多，以后有时间了补一下</p></blockquote><h2 id="Webhooks-实现"><a href="#Webhooks-实现" class="headerlink" title="Webhooks 实现"></a>Webhooks 实现</h2><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311152016697.png"                        alt="image-20231115201651587"                 ></p><p>当然，我们也可以通过 Webhooks 来实现部署，简单来说当我们进行相应操作后，Github 会向我们配置的 url 发起 POST 请求，服务器上编写相应的接口，收到请求后进行相应处理即可。例如，先通过 Github Actions 将构建好的文件 scp 到自己的服务器上，收到 POST 请求后再进行对应的处理。</p><p>如果比较懒的话，可以去看下 <a class="link"   href="https://hookdoo.com/" >hookdoo<i class="fas fa-external-link-alt"></i></a>(Hooks to automate webhooks)，这个使用较为简单，在此不多赘述</p><p>当然，也可以通过 Github Actions 触发 Webhooks，这样就不用去想二者先后顺序之类的了</p><p>可参考文章：<a class="link"   href="https://m0len.github.io/2021/03/28/github-actions-webhooks-chain" >GitHub Actions 和 Webhooks 的触发<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CI&amp;#x2F;CD 这块自己一直都是一知半解的，最近有个七牛云的比赛，持续部署做的比较敷衍，webhooks + &lt;a class=&quot;link&quot;   href=&quot;https://hookdoo.com/&quot; &gt;hookdoo&lt;i class=&quot;fas fa-external</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="语言" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="golang" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/golang/"/>
    
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://tbghg.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>七牛云1024比赛-web短视频</title>
    <link href="https://tbghg.top/2023-11-15/121c09e8413c/"/>
    <id>https://tbghg.top/2023-11-15/121c09e8413c/</id>
    <published>2023-11-15T07:27:41.000Z</published>
    <updated>2023-11-15T07:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><h3 id="比赛题目"><a href="#比赛题目" class="headerlink" title="比赛题目"></a>比赛题目</h3><p>网页短视频应用</p><p>使用七牛云存储、七牛视频相关产品（如视频截帧等）开发一款Web端短视频应用</p><p>基础功能（必须实现）</p><ol><li>视频播放：播放、暂停、进度条拖拽</li><li>内容分类：视频内容分类页，如热门视频、体育频道</li><li>视频切换：可通过上下键翻看视频</li></ol><p>高级功能（可选实现）</p><ol><li>账户系统：用户可登录，收藏视频</li><li>可参考常见短视频应用自由增加功能，提升完善度，如点赞、分享、关注、搜索等</li></ol><h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><p>Github地址：</p><ul><li>项目：<a class="link"   href="https://github.com/VideoUtopia" >VideoUtopia<i class="fas fa-external-link-alt"></i></a></li><li>后端地址：<a class="link"   href="https://github.com/VideoUtopia/utopia-back" >VideoUtopia&#x2F;utopia-back<i class="fas fa-external-link-alt"></i></a></li><li>前端地址：<a class="link"   href="https://github.com/VideoUtopia/utopia-front" >VideoUtopia&#x2F;utopia-front<i class="fas fa-external-link-alt"></i></a></li></ul><p>项目功能：</p><ul><li>存储模块<ul><li>使用七牛云kodo进行存储，存储 头像、封面、视频</li><li>支持视频预处理，自动截取封面，异步回调替换</li></ul></li><li>用户模块<ul><li>登录、注册、查看个人主页</li></ul></li><li>视频模块<ul><li>热门视频：根据三小时内点赞量动态替换</li><li>推荐视频：推送所关注用户发布的视频</li><li>上传视频</li><li>视频内容分类</li></ul></li><li>交互模块<ul><li>点赞、关注、收藏</li><li>查看自己曾收藏过的视频</li><li>查看自己关注的用户</li></ul></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>项目大体来说中规中矩，这里介绍几个稍微有意思的点</p><h3 id="存储模块"><a href="#存储模块" class="headerlink" title="存储模块"></a>存储模块</h3><p>这里先吐槽一句，七牛云的文档写的有些粗糙</p><p>通过kodo存储对象，服务端下发 带回调、带数据处理、带自定义参数 的凭证，客户端根据凭证上传视频，上传成功后七牛云回调服务端，服务端处理数据。时序图如下：</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202311151457831.png"                        alt="七牛云SDK使用.png"                 ></p><p>为保证访问密钥的安全性，采用服务端下发凭证的形式</p><p>上传文件主要集中于以下几个场景</p><ol><li>上传&#x2F;更换头像</li><li>上传视频</li><li>上传封面&#x2F;七牛云自动截取封面</li></ol><p>设计callback接口时，考虑到以下两方面</p><ol><li>文件上传调用次数相对其它接口较少，且回调方处理数据任务量不大</li><li>callback由七牛云调用，处理数据前会检测是否为七牛云发起</li><li>处理回调时，不同类型控制层代码相近</li></ol><p>所以选择将三种类型全部集中于一个回调接口</p><p>在处理数据时，如上传视频时，需要知道上传用户、标题、视频类型等信息，需要客户端上传时，携带自定义参数，callbackBody定义如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(key)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:file_type)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:uid)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cover_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:cover_url)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;describe&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:describe)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:title)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;video_type_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(x:video_type_id)&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>服务端根据<code>file_type</code>判断上传类型(视频-携带封面&#x2F;视频-不携带封面&#x2F;封面&#x2F;头像)，不同文件类型对应不同的参数校验，并单独处理</p><ul><li>封面：不做处理</li><li>视频-携带封面：插入视频</li><li>头像：修改user表</li></ul><p>对于视频-不携带封面：</p><ol><li>以用户头像做临时封面，插入视频</li><li>将视频key做键，值为视频id，存入redis，半小时过期时间</li><li>七牛云截取封面成功后，异步回调接口，根据视频key找到视频id，替换视频封面</li></ol><p>服务端在注册上传凭证时，携带了预转持久化参数：<code>vframe/jpg/offset/1|saveas/bucket:$&#123;etag&#125;.jpg</code>，七牛云会截取视频第一帧并持久化存储，在存储完成后，调用callback接口</p><p>callback在检测到请求中含有<code>inputKey</code>字段时，根据视频key从redis取出视频id，并替换视频封面</p><h2 id="热门视频"><a href="#热门视频" class="headerlink" title="热门视频"></a>热门视频</h2><h3 id="需解决的问题"><a href="#需解决的问题" class="headerlink" title="需解决的问题"></a>需解决的问题</h3><p>热门视频的选择体现在用户的点赞上，若只按照点赞数量排序，会出现以下问题：</p><ol><li>点赞量高的视频堆积，更换频率较低，用户经常刷到重复视频</li><li>新发出的有潜力的视频得不到推荐，无人问津</li></ol><p>因此，热门视频可采用 <strong>三小时内的点赞量</strong> 进行动态更换</p><p>另外当 <strong>突然更换热门视频榜单</strong> 时，用户当前观看热门视频位置无法记录，会推送曾经的视频，<strong>影响用户体验</strong>，这里下文会详细举例</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>开启协程，每隔三个小时异步拉取DB，获得三个小时内点赞量最多的100个视频，将视频id存入redis的zset中</li><li>用户获取视频时，把三小时内点赞数从高到低返回给用户，一次返回20个，同时给出当前最小score，做下一次的分页依据</li></ol><h4 id="score设计"><a href="#score设计" class="headerlink" title="score设计"></a>score设计</h4><p>直接将三小时内的点赞数作为score：无法根据score进行区分点赞数相同的视频，只能考虑 重复推送 或 忽略此类其他视频 两种方案，显然均不合理</p><p>所以需要在score侧将视频区分开，因此最终选用 float(三小时内点赞数.视频id) 做score，确保热门视频不重复、不丢失</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>对于更换热门视频导致用户体验下降的问题，我们采用版本控制的形式来解决</p><p>我们先看一个案例：</p><ol><li>redis异步拉取DB，获取前100个热门视频id，存入zset，我们记为版本A</li><li>两小时五十五分钟后，用户A分页刷取热门视频，获得版本A的前20个视频，并观看</li><li>五分钟后，redis异步拉取DB，更新zset</li><li>用户A获取下一分页视频</li></ol><p>此时虽然用户能正常获取视频，但因zset的改变，用户A可能会刷取到一些重复的视频，导致体验下降</p><p>为解决该问题，我们进行了热门视频缓存版本控制，总共有A、B两个版本，每隔三小时轮换更新一个版本，服务器中记录当前最新版本，当用户新发起查询热门视频请求时，返回当前最新版本，用户查询时携带了版本信息，就使用该版本</p><p>下面我们来看些例子</p><ol><li>redis异步拉取DB，获取前100个热门视频id，存入zset，我们记为版本A，当前版本是A</li><li>用户A刷取热门视频，获得20个视频、nextScore、版本号A</li><li>三小时后，redis异步拉取DB，更换版本B中的热门视频，当前版本是B</li><li>用户A刷取热门视频，请求参数中携带版本号A -&gt; 从版本A的zset中取出数据返回，用户体验无影响</li><li>用户B刷取热门视频，未携带版本号 -&gt; 给出当前版本号B返回值，并从版本B中取数据</li><li>三小时后，redis异步拉取DB，更换版本A中的热门视频，当前版本是A</li></ol><p>我们可以直观看出，从用户A获取版本A中的视频，到版本A中的热门视频变更，中间至少要间隔3个小时，这个时间差对业务而言完全可以接受</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>异步更新，从DB中读取写入redis</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热门视频缓存 每隔三小时更新一次版本</span></span><br><span class="line"><span class="comment">// 存入zset，通过score判断此时取到的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *videoJob)</span></span> updatePopularVideos() &#123;</span><br><span class="line"><span class="keyword">var</span> nums <span class="type">int64</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">3</span> * time.Hour)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">nums = (nums + <span class="number">1</span>) % <span class="number">2</span> <span class="comment">// nums控制当前版本</span></span><br><span class="line">common.PopularVideoVersion.Store(nums + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 刷DB，获取当前热门视频id</span></span><br><span class="line">videoIds, err := v.videoServer.VideoDal.GetPopularVideos(popularVideosNum)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Logger.Error(fmt.Sprintf(<span class="string">&quot;updatePopularVideos v.videoServer.VideoDal.GetPopularVideos err:%+v&quot;</span>, videoIds))</span><br><span class="line"><span class="comment">// 一分钟后重试</span></span><br><span class="line">&lt;-time.After(<span class="number">5</span> * time.Minute)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">popularItem := <span class="built_in">make</span>([]*cache.VideoPopularItem, <span class="built_in">len</span>(videoIds))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> videoIds &#123;</span><br><span class="line">sScore := fmt.Sprintf(<span class="string">&quot;%d.%d&quot;</span>, videoIds[i].Count, videoIds[i].VideoID)</span><br><span class="line"></span><br><span class="line">popularItem[i] = &amp;cache.VideoPopularItem&#123;Vid: videoIds[i].VideoID&#125;</span><br><span class="line">popularItem[i].Score, _ = strconv.ParseFloat(sScore, <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 将热门视频id写入当前版本</span></span><br><span class="line">key := cache.PopularVideoKey(common.GetPopularVideoVersion())</span><br><span class="line">cache.BuildPopularVideo(key, popularItem)</span><br><span class="line"></span><br><span class="line">&lt;-ticker.C</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从redis中分页获取当前热门视频</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetPopularVideo 获取当前热门视频</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPopularVideo</span><span class="params">(version <span class="type">int</span>, score <span class="type">float64</span>, count <span class="type">int64</span>)</span></span> (videoIds []<span class="type">uint</span>, nextScore <span class="type">float64</span>, nextVersion <span class="type">int</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">key      <span class="type">string</span></span><br><span class="line">maxScore <span class="type">string</span></span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> version == <span class="number">0</span> &#123; <span class="comment">// 未携带版本，赋为当前版本</span></span><br><span class="line">version = common.GetPopularVideoVersion()</span><br><span class="line">&#125;</span><br><span class="line">nextVersion = version</span><br><span class="line">key = PopularVideoKey(version)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">0</span> &#123; <span class="comment">// 首次请求，未携带score</span></span><br><span class="line">maxScore = <span class="string">&quot;+inf&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 小于传入score</span></span><br><span class="line">maxScore = fmt.Sprintf(<span class="string">&quot;(%f&quot;</span>, score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 ZSET 中按分数从大到小获取前 count 个成员</span></span><br><span class="line">result, err := RDB.ZRevRangeByScoreWithScores(Ctx, key, &amp;redis.ZRangeBy&#123;</span><br><span class="line">Max:    maxScore,</span><br><span class="line">Offset: <span class="number">0</span>,</span><br><span class="line">Count:  count - <span class="number">1</span>,</span><br><span class="line">&#125;).Result()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(result) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 错误处理，缓存侧错误不传递到上级，告知结果是否回源即可</span></span><br><span class="line">logger.Logger.Error(fmt.Sprintf(<span class="string">&quot;GetPopularVideo RDB.ZRevRangeByScoreWithScores err:%+v&quot;</span>, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">-1</span>, nextVersion, err == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> result &#123;</span><br><span class="line">vid, _ := strconv.Atoi(z.Member.(<span class="type">string</span>))</span><br><span class="line">videoIds = <span class="built_in">append</span>(videoIds, <span class="type">uint</span>(vid))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextScore = result[<span class="built_in">len</span>(result)<span class="number">-1</span>].Score</span><br><span class="line"><span class="keyword">return</span> videoIds, nextScore, nextVersion, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断用户是否点赞"><a href="#判断用户是否点赞" class="headerlink" title="判断用户是否点赞"></a>判断用户是否点赞</h2><p>判断用户是否为该视频点过赞，查询量较大，有以下三种应对方式</p><ol><li>不做缓存 -&gt; DB压力较大</li><li>全量缓存 -&gt; 随时间推移，缓存侧存储压力较大</li><li>部分缓存 -&gt; 如何判断是否回源？</li></ol><p>前两个基本是不能接受的，不予考虑。先说下结论，最终我们选择了下文的方案二</p><h3 id="方案一：缓存过期不回源"><a href="#方案一：缓存过期不回源" class="headerlink" title="方案一：缓存过期不回源"></a>方案一：缓存过期不回源</h3><p>对于部分缓存，判断何时回源是很重要的，若缓存过期时间很短，未查到缓存则接回源，那DB侧压力仍然很大</p><p>另一种方法是提高缓存时间，均不回源：</p><p>简单计算一下，如果设置30天过期时间，每天300万用户，每人点赞20个视频，假设一个是0.5kb <code>30*300</code>按10000，<code>10k*20*0.5kb</code>，大约是100Mb</p><ul><li>查询缓存成功：表示点过赞，返回true</li><li>查询缓存不成功：30天以前点过赞&#x2F;没点过赞，不回源，直接返回false</li></ul><p>DB存储点赞数据时，我们可以在uid与vid间添加唯一索引，插入数据使用<code>insert on duplicate key update</code>保证幂等</p><p>这个存储量，如果我们把时间过期时间拉到一年，其实也是可以接受的。但问题在于业务是否可以接受一年前点过赞的视频，再次打开时不显示点过赞。</p><p>并且因为要为不同的key设置不同过期时间，可以选用string和zset两种形式</p><ul><li>string形式：key分布较为分散，无法进行统一管理，较为不便</li><li>zset形式：要过期的时间记为score，异步清除 - 实现较为麻烦</li></ul><h3 id="方案二：用户维度存储点赞视频，冷热数据分离冷数据回源"><a href="#方案二：用户维度存储点赞视频，冷热数据分离冷数据回源" class="headerlink" title="方案二：用户维度存储点赞视频，冷热数据分离冷数据回源"></a>方案二：用户维度存储点赞视频，冷热数据分离冷数据回源</h3><p>该方案参考了 得物 的点赞设计，设计较为巧妙，缓存结构如下：</p><p><code>like:15</code>中15为用户uid，3454、723、645均为用户点过赞的视频vid，<code>minVid</code>是冷热数据的分界线，低于该值记为冷数据，<code>ttl</code>为过期时间</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;like:15&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ttl&quot;</span><span class="punctuation">:</span><span class="number">1653532653</span><span class="punctuation">,</span>    <span class="comment">// 缓存新建或更新时时间戳</span></span><br><span class="line">    <span class="attr">&quot;3454&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span>            <span class="comment">// 用户近一段时间点赞过的视频id</span></span><br><span class="line">    <span class="attr">&quot;723&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span>            <span class="comment">// 用户近一段时间点赞过的视频id</span></span><br><span class="line">    <span class="attr">&quot;645&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span>            <span class="comment">// 用户近一段时间点赞过的视频id</span></span><br><span class="line">    <span class="attr">&quot;minVid&quot;</span><span class="punctuation">:</span><span class="number">645</span>        <span class="comment">// 缓存中最小的视频id，用以区分冷热</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>设计思路如下：</p><ol><li>用户维度：判断是否点赞业务场景一般是：一个用户对应一堆视频，以用户维度创建缓存，可以大幅减少命令执行次数</li><li>冷热数据分离：视频id是自增的，id从大到小对应这上传时间从新到旧，用户刷到旧视频的频率相对较低，可根据视频id进行冷热数据分离</li><li>冷数据回源：冷数据回源查DB，并写入缓存，这样就可以保证缓存高效利用而且压力不过太大</li><li>冷热阈值：限制hash中的字段数，批量查询时，若发现字段数超过1500则查询结束后重构缓存，取前750个视频id，修改minVid</li><li>ttl字段：以前每次查看是否要更新缓存时，都要调用TTL命令，执行命令次数翻倍，将TTL写入字段一同查询，可减少命令数</li><li>续期：当TTL临近过期(达到2&#x2F;3时)进行续期</li></ol><h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>批量获取用户是否点赞：</p><ol><li>HMGET获取vid1、vid2、vid3、ttl、minVid<ol><li>获取失败：不存在该key，重新构建</li><li>获取成功但vid未找到<ol><li>vid &gt;&#x3D; minVid &#x3D;&#x3D;》未点赞</li><li>vid &lt;  minVid &#x3D;&#x3D;》冷数据，回源查DB，并写入缓存</li></ol></li><li>检查TTL快过期则续期</li><li>检测字段值是否超过阈值，超过则重建</li></ol></li><li>返回结果</li></ol><p>用户点赞：更新DB，HSET添加该字段，不存在则构建</p><p>用户删除：更新DB，HDEL删除该字段，不做其他处理</p><p>优点：</p><ul><li>可高效利用缓存且缓存存储量不大</li><li>DB回源的数据量可以接受</li></ul><p>缺点：实现起来较为复杂</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>这种缓存模式下需要关注：点赞、取消点赞、批量判断用户是否点赞</p><p>我们先实现基本的方法：</p><ol><li>构建用户点赞视频缓存 - 相对简单，根据视频id和阈值HMSet即可，代码见<code>utopia-back\cache\like.go:190</code></li><li>判断数量是否超过阈值 - 查询字段数，和阈值去做判断</li><li>超出阈值重建缓存</li></ol><p>超出阈值重建缓存时，其中一半的字段是可以保留的，删除不需要的即可</p><ol><li>先取出所有字段，排序后将minVid设置为第750位的vid</li><li>调用 构建用户点赞视频缓存 函数，不需要传视频id，通过该函数刷新ttl与minVid即可</li><li>调用HMDel删除剩余字段</li></ol><p>实现代码见<code>utopia-back\cache\like.go:271</code></p><p>在<code>utopia-back\cache\like.go:271</code>将 用户点赞视频批量写入缓存 进行封装，用户点赞时进行调用。</p><p>判断用户是否批量为视频点赞时，检查ttl与字段数量，需要则调用方法进行重建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utopia-back\cache\like.go:138</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsUserLikedVideos 用户是否为某些视频点赞(批量)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// result key为vid  &lt;-&gt;  0未点赞；1为点赞；2 冷数据,需回源</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// state 0 成功；1 不存在该key,需要新建；2 查询失败,需回源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUserLikedVideos</span><span class="params">(uid <span class="type">uint</span>, videoIds []<span class="type">uint</span>)</span></span> (result <span class="keyword">map</span>[<span class="type">uint</span>]<span class="type">int</span>, state <span class="type">int</span>) &#123;</span><br><span class="line">key := UserLikedVideoKeyV3(uid)</span><br><span class="line"></span><br><span class="line">fields := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(videoIds)+<span class="number">2</span>)</span><br><span class="line">fields[<span class="number">0</span>], fields[<span class="number">1</span>] = sMinVid, sTTL</span><br><span class="line"><span class="comment">// 将整数切片转换为字符串切片</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> videoIds &#123;</span><br><span class="line">fields[i+<span class="number">2</span>] = strconv.FormatInt(<span class="type">int64</span>(num), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询是否存在</span></span><br><span class="line">resHMGet := RDB.HMGet(Ctx, key, fields...)</span><br><span class="line"><span class="keyword">if</span> resHMGet.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Logger.Error(fmt.Sprintf(<span class="string">&quot;IsUserLikedVideos cmd:%v&quot;</span>, resHMGet.String()))</span><br><span class="line">state = <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Logger.Info(fmt.Sprintf(<span class="string">&quot;IsUserLikedVideos cmd:%v&quot;</span>, resHMGet.String()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sMinVidVal, ok1 := resHMGet.Val()[<span class="number">0</span>].(<span class="type">string</span>)</span><br><span class="line">sTtlVal, ok2 := resHMGet.Val()[<span class="number">1</span>].(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok1 || !ok2 &#123; <span class="comment">// 不存在该key，需重新构建</span></span><br><span class="line">state = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">minVid, _ := strconv.Atoi(sMinVidVal)</span><br><span class="line">ttl, _ := strconv.Atoi(sTtlVal)</span><br><span class="line"></span><br><span class="line">state = <span class="number">0</span> <span class="comment">// 查询成功，state标为0</span></span><br><span class="line"></span><br><span class="line">vidRes := resHMGet.Val()[<span class="number">2</span>:]</span><br><span class="line">result = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint</span>]<span class="type">int</span>, <span class="built_in">len</span>(videoIds))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, vid := <span class="keyword">range</span> videoIds &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := vidRes[i].(<span class="type">string</span>); ok &#123; <span class="comment">// 查询到点赞</span></span><br><span class="line">result[vid] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> vid &gt;= <span class="type">uint</span>(minVid) &#123; <span class="comment">// 热数据，用户没点赞</span></span><br><span class="line">result[vid] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 冷数据，需要回源</span></span><br><span class="line">result[vid] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否超过域值，是否需要续期</span></span><br><span class="line">judgeRebuildVideoLikedVideos(key, ttl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口及IP限流"><a href="#接口及IP限流" class="headerlink" title="接口及IP限流"></a>接口及IP限流</h2><p>采用 <strong>令牌桶</strong> 对可针对不同接口配置不同的限流策略，同时支持对用户IP限流，防止用户恶意攻击</p><p>通过<code>github.com/juju/ratelimit</code>实现令牌桶，将接口做map的key，对应不同的*BucketConf，BucketConf包含一个Bucket，用于对接口进行限流，接口限流支持阻塞等待，配置maxWait</p><p>每隔BucketConf配置一个map[string]*ratelimit.Bucket，用于对IP进行限流，IP限流不支持阻塞等待，达到阈值时直接阻止该请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BucketMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*BucketConf)</span><br><span class="line"><span class="keyword">var</span> defaultIpRateConf = &amp;IpRateConf&#123;</span><br><span class="line">FillInterval: <span class="number">100</span> * time.Millisecond,</span><br><span class="line">Capacity:     <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BucketConf <span class="keyword">struct</span> &#123;</span><br><span class="line">Bucket  *ratelimit.Bucket</span><br><span class="line">MaxWait time.Duration</span><br><span class="line"></span><br><span class="line">IpRateConf   *IpRateConf</span><br><span class="line">IpRateBucket <span class="keyword">map</span>[<span class="type">string</span>]*ratelimit.Bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IpRateConf <span class="keyword">struct</span> &#123;</span><br><span class="line">FillInterval time.Duration</span><br><span class="line">Capacity     <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限流中间件初始化，对不同接口和对不同接口下的IP配置不同的限流策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitRateLimit 注册限流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRateLimit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 需要限流的接口在此注册</span></span><br><span class="line"><span class="comment">// 参考文章：https://blog.csdn.net/m0_52528053/article/details/127294249</span></span><br><span class="line">middleware.BucketMap[<span class="string">&quot;/api/v1/upload/token&quot;</span>] = &amp;middleware.BucketConf&#123;</span><br><span class="line"><span class="comment">// 每10ms产生5个token，最多存储10个token</span></span><br><span class="line">Bucket: ratelimit.NewBucketWithQuantum(<span class="number">10</span>*time.Millisecond, <span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line"><span class="comment">// 最大等待时间</span></span><br><span class="line">MaxWait: <span class="number">20</span> * time.Millisecond,</span><br><span class="line"></span><br><span class="line">IpRateConf: &amp;middleware.IpRateConf&#123;</span><br><span class="line">FillInterval: time.Second,</span><br><span class="line">Capacity:     <span class="number">5</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">middleware.BucketMap[<span class="string">&quot;/api/v1/upload/callback&quot;</span>] = &amp;middleware.BucketConf&#123;</span><br><span class="line">Bucket:  ratelimit.NewBucketWithQuantum(<span class="number">10</span>*time.Millisecond, <span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">MaxWait: <span class="number">20</span> * time.Millisecond,</span><br><span class="line">&#125;</span><br><span class="line">middleware.BucketMap[<span class="string">&quot;default&quot;</span>] = &amp;middleware.BucketConf&#123;</span><br><span class="line">Bucket:  ratelimit.NewBucketWithQuantum(<span class="number">10</span>*time.Millisecond, <span class="number">100</span>, <span class="number">20</span>),</span><br><span class="line">MaxWait: <span class="number">10</span> * time.Millisecond,</span><br><span class="line">&#125;</span><br><span class="line">middleware.FillDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码注册到路由中间件，当请求失败时报错请求频繁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码注册到路由中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimit</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">bucketConf, ok := BucketMap[c.Request.URL.Path]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">bucketConf = BucketMap[<span class="string">&quot;default&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bucketConf.Bucket.WaitMaxDuration(<span class="number">1</span>, bucketConf.MaxWait) &#123;</span><br><span class="line">ipRateValidate(c.ClientIP(), bucketConf.IpRateConf, bucketConf.IpRateBucket)</span><br><span class="line">c.Next()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">501</span>,</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;请求频繁，请稍后重试&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="待改进"><a href="#待改进" class="headerlink" title="待改进"></a>待改进</h2><blockquote><p>七牛云存储 kodo 自定义变量直接使用用户id</p></blockquote><p>七牛云回调不支持自定义header，所以直接在自定义变量中传递的用户id来判断身份，这块肯定是不安全的，用户找到对应接口后，完全可以自己尝试去替换别人的头像或给别人上传视频。自定义变量应改为用户自身token，服务端单独鉴权</p><blockquote><p>用户 点赞&#x2F;取消点赞 时，直接写入<code>like_counts</code>表</p></blockquote><p>此处具有较大的优化空间，倘若每次点赞都回写一次，点赞这种高并发场景会将DB压垮。</p><p>改进方案：</p><ol><li>接入消息队列，收到点赞消息后异步处理like_counts表</li><li>使用消息队列解耦后，以视频id进行聚合，之后批量写入DB，例如vid&#x3D;13的视频，点赞量达到20后，对应字段直接加20，减少对DB的请求</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目简介&quot;&gt;&lt;a href=&quot;#项目简介&quot; class=&quot;headerlink&quot; title=&quot;项目简介&quot;&gt;&lt;/a&gt;项目简介&lt;/h2&gt;&lt;h3 id=&quot;比赛题目&quot;&gt;&lt;a href=&quot;#比赛题目&quot; class=&quot;headerlink&quot; title=&quot;比赛题目&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="项目" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2介绍</title>
    <link href="https://tbghg.top/2023-10-22/1a999e0870b8/"/>
    <id>https://tbghg.top/2023-10-22/1a999e0870b8/</id>
    <published>2023-10-22T02:30:12.000Z</published>
    <updated>2023-10-22T02:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点介绍授权码模式，以及实现第三方QQ登录并获取信息</p><h2 id="OAuth介绍"><a href="#OAuth介绍" class="headerlink" title="OAuth介绍"></a>OAuth介绍</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容</p><p>OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0</p><p>OAuth2包括：</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><p>具体可以参考：<a class="link"   href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" >理解OAuth 2.0<i class="fas fa-external-link-alt"></i></a></p><h2 id="授权码模式过程"><a href="#授权码模式过程" class="headerlink" title="授权码模式过程"></a>授权码模式过程</h2><p>我们先用QQ来理解一下，假如我现在做了个网站，想要实现QQ登录，这里分为：QQ认证服务器，QQ资源服务器(有权限时访问会获取该QQ账户的信息，如头像)，客户端(这里指我的网站)，服务端(我个人的网站服务端)</p><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/MIK-LHXxHs.png"                        alt="OAuth2过程"                 ></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">&#x27;https://plantuml.com/zh-dark/sequence-diagram</span><br><span class="line">&#x27;客户端 认证服务器 资源服务器 服务端</span><br><span class="line"></span><br><span class="line">&#x27;获取code</span><br><span class="line">&#x27;客户端 -&gt; 服务端:选择QQ登录\n「可省略，由客户端直接请求认证服务器」</span><br><span class="line">&#x27;服务端 -&gt; 客户端:302重定向至认证服务器，携带response_type、client_id、redirect_uri、state等，见下文\n「可省略，由客户端直接请求认证服务器」</span><br><span class="line">客户端 -&gt; 认证服务器:携带response_type、client_id、redirect_uri、state等</span><br><span class="line">认证服务器 -&gt; 客户端:302重定向至redirect_uri，携带code</span><br><span class="line"></span><br><span class="line">&#x27;获取access_token</span><br><span class="line">客户端 -&gt; 服务端:(redirect_uri对应地址)携带code</span><br><span class="line">服务端 -&gt; 认证服务器:携带grant_type、client_id、*client_secret*等，见下文\n根据code换access_token</span><br><span class="line">认证服务器 -&gt; 服务端:返回access_token、expires_in、refresh_token</span><br><span class="line"></span><br><span class="line">&#x27;获取资源</span><br><span class="line">服务端 -&gt; 资源服务器:携带access_token，获取账户资源，如QQ头像、昵称</span><br><span class="line">资源服务器 -&gt; 服务端:返回对应资源</span><br><span class="line">服务端 -&gt; 客户端:返回对应资源</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>关于<code>客户端-&gt;认证服务器</code>和<code>服务端-&gt;认证服务器</code>可参考QQ给出的文档：<a class="link"   href="https://wiki.connect.qq.com/%e4%bd%bf%e7%94%a8authorization_code%e8%8e%b7%e5%8f%96access_token" >使用Authorization_Code获取Access_Token<i class="fas fa-external-link-alt"></i></a></p><p>获取Authorization Code：</p><table><thead><tr><th align="center">参数</th><th align="center">是否必须</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">response_type</td><td align="center">必须</td><td align="center">授权类型，此值固定为“code”。</td></tr><tr><td align="center">client_id</td><td align="center">必须</td><td align="center">申请QQ登录成功后，分配给应用的appid。</td></tr><tr><td align="center">redirect_uri</td><td align="center">必须</td><td align="center">成功授权后的回调地址，必须是注册appid时填写的主域名下的地址，建议设置为网站首页或网站的用户中心。注意需要将url进行URLEncode。</td></tr><tr><td align="center">state</td><td align="center">必须</td><td align="center">client端的状态值。用于第三方应用防止CSRF攻击，成功授权后回调时会原样带回。请务必严格按照流程检查用户与state参数状态的绑定。</td></tr><tr><td align="center">scope</td><td align="center">可选</td><td align="center">请求用户授权时向用户显示的可进行授权的列表。 可填写的值是<a class="link"   href="https://wiki.connect.qq.com/api%E5%88%97%E8%A1%A8" >API文档<i class="fas fa-external-link-alt"></i></a>中列出的接口，如果要填写多个接口名称，请用逗号隔开。 例如：scope&#x3D;get_user_info,list_album,upload_pic 不传则默认请求对接口get_user_info进行授权。 建议控制授权项的数量，只传入必要的接口名称，因为授权项越多，用户越可能拒绝进行任何授权。</td></tr><tr><td align="center">display</td><td align="center">可选</td><td align="center">仅<strong>PC网站</strong>接入时使用。 用于展示的样式。不传则默认展示为PC下的样式。 如果传入“mobile”，则展示为mobile端下的样式。</td></tr></tbody></table><p>通过Authorization Code获取Access Token：</p><table><thead><tr><th align="center">参数</th><th align="center">是否必须</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">grant_type</td><td align="center">必须</td><td align="center">授权类型，在本步骤中，此值为“authorization_code”。</td></tr><tr><td align="center">client_id</td><td align="center">必须</td><td align="center">申请QQ登录成功后，分配给网站的appid。</td></tr><tr><td align="center">client_secret</td><td align="center">必须</td><td align="center">申请QQ登录成功后，分配给网站的appkey。</td></tr><tr><td align="center">code</td><td align="center">必须</td><td align="center">上一步返回的authorization code。 如果用户成功登录并授权，则会跳转到指定的回调地址，并在URL中带上Authorization Code。 例如，回调地址为<code>www.qq.com/my.php</code> ，则跳转到：<code>http://www.qq.com/my.php?code=520DD95263C1CFEA087******</code> 注意此code会在10分钟内过期。</td></tr><tr><td align="center">redirect_uri</td><td align="center">必须</td><td align="center">与上面一步中传入的redirect_uri保持一致。</td></tr><tr><td align="center">fmt</td><td align="center">可选</td><td align="center">因历史原因，默认是x-www-form-urlencoded格式，如果填写json，则返回json格式</td></tr><tr><td align="center">need_openid</td><td align="center">可选</td><td align="center">need_openid&#x3D;1，表示同时获取openid。</td></tr></tbody></table><p>当然，我们需要去标识该用户，可以通过携带AccessToken，请求OpenID接口，即可获取对应用户身份标识OpenID。</p><p>和简化模式相比，多了通过code换取AccessToken的过程，这个过程是在自己的后台服务器完成的，secret保存在服务端，不会暴露给用户，从而保证更高的安全性</p><p>即：授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动</p><hr><blockquote><p>Q1: code换取token时，为什么也要携带redirect_uri？ </p><p>核对授权码和重定向URI, 验证是否对应。<br>(网上有说是回调地址，之后要回调之类的。这个步骤发生在获取code之后，认证服务器返回302重定向到redirect_uri，在根据code获取token时，很明显跟这个原因没关系)</p></blockquote><blockquote><p>Q2: 在获取code时，redirect_uri为什么有些授权方认证时是可选的？</p><p>RFC6749 3.1.2. Redirection Endpoint里写了，这个redirect_uri可以通过请求参数传给认证服务器，也可以在客户端在认证服务器注册的时候提前设置</p></blockquote><blockquote><p>Q3: 为什么需要有code这一步，直接拿到token不行吗？</p><ul><li>说法一：<a class="link"   href="https://stackoverflow.com/questions/13387698/why-is-there-an-authorization-code-flow-in-oauth2-when-implicit-flow-works-s" >Why is there an “Authorization Code” flow in OAuth2 when “Implicit” flow works so well?<i class="fas fa-external-link-alt"></i></a></li><li>说法二：secret存储在客户端是不安全的，中间加一层服务端，把需要secret获取token的交由 服务端-认证服务器 处理，不暴露给外界，保证安全性</li></ul></blockquote><blockquote><p>Q4: CSRF以及state字段</p><p>之后补充</p></blockquote><p>这几个问题欢迎评论区探讨</p><h2 id="登录QQ-Golang实现"><a href="#登录QQ-Golang实现" class="headerlink" title="登录QQ-Golang实现"></a>登录QQ-Golang实现</h2><p>可参考：<a class="link"   href="https://learnku.com/articles/36658" >Go 语言实现 QQ 扫码登陆<i class="fas fa-external-link-alt"></i></a>，<code>AppId</code>和<code>AppKey</code>使用该博主所申请的，代码写的也很可以，我也没啥好补充的。<a class="link"   href="https://github.com/pibigstar/go-demo/blob/master/sdk/qq/qq_pc_login.go" >代码<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重点介绍授权码模式，以及实现第三方QQ登录并获取信息&lt;/p&gt;
&lt;h2 id=&quot;OAuth介绍&quot;&gt;&lt;a href=&quot;#OAuth介绍&quot; class=&quot;headerlink&quot; title=&quot;OAuth介绍&quot;&gt;&lt;/a&gt;OAuth介绍&lt;/h2&gt;&lt;p&gt;OAuth（开放授权）是一个开放</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="web" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/web/"/>
    
    
    <category term="go" scheme="https://tbghg.top/tags/go/"/>
    
    <category term="Auth" scheme="https://tbghg.top/tags/Auth/"/>
    
  </entry>
  
  <entry>
    <title>常见限流算法</title>
    <link href="https://tbghg.top/2023-10-19/df3cc489e560/"/>
    <id>https://tbghg.top/2023-10-19/df3cc489e560/</id>
    <published>2023-10-19T07:15:38.000Z</published>
    <updated>2023-10-19T07:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://juejin.cn/post/7056068978862456846" >Go实现常见的限流算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81" >系统自适应限流<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cyhone.com/articles/analysis-of-uber-go-ratelimit/" >uber-go 漏桶限流器使用与原理分析<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>限流，也称流量控制。是指系统在面临高并发，或者<strong>大流量请求</strong>的情况下，<strong>限制新的请求对系统的访问</strong>，从而<strong>保证系统的稳定性</strong>。</p><p>常见限流算法有：</p><ol><li>固定窗口&#x2F;计数器</li><li>滑动窗口</li><li>限流桶</li><li>令牌桶</li></ol><h2 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h2><h3 id="固定窗口-计数器"><a href="#固定窗口-计数器" class="headerlink" title="固定窗口&#x2F;计数器"></a>固定窗口&#x2F;计数器</h3><p>维护一个计数器，设置一个过期时间，例如：1min访问次数不能包括100次，有用户访问时，访问次数+1，超过阈值时拒绝该请求，每隔1min重制一次计数器。</p><p>但当用户第59s发送了100个请求和第61s发送了100个请求，此时因为计数器重制，所以会将这些请求放行</p><p>优点：实现简单</p><p>可以通过redis实现：设置过期时间，每次访问后值+1，同时判断下访问次数是否超过域值</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><img                         lazyload                       alt="image"                       data-src="https://oss.tbghg.top/blog/202310191946841.png"                        alt="3.png"                 ></p><p>整个红色的矩形框表示一个时间窗口，举例的话，一分钟作为一个时间窗口，把它分割成6份，每份10s，过10s就把窗口向右移动一格，每个格子都有自己单独的计时器，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确</p><p>这样看的话，第一种方案其实是将1min作为一个窗口，即计数器是滑动窗口的一种特殊情况，所以也被称为固定窗口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> limiter</span><br><span class="line"><span class="comment">// 代码摘自 https://juejin.cn/post/7056068978862456846</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlidingWindowLimiter 滑动窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> SlidingWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">   limit        <span class="type">int</span>           <span class="comment">// 窗口请求上限</span></span><br><span class="line">   window       <span class="type">int64</span>         <span class="comment">// 窗口时间大小</span></span><br><span class="line">   smallWindow  <span class="type">int64</span>         <span class="comment">// 小窗口时间大小</span></span><br><span class="line">   smallWindows <span class="type">int64</span>         <span class="comment">// 小窗口数量</span></span><br><span class="line">   counters     <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span> <span class="comment">// 小窗口计数器</span></span><br><span class="line">   mutex        sync.Mutex    <span class="comment">// 避免并发问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSlidingWindowLimiter 创建滑动窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlidingWindowLimiter</span><span class="params">(limit <span class="type">int</span>, window, smallWindow time.Duration)</span></span> (*SlidingWindowLimiter, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// 窗口时间必须能够被小窗口时间整除</span></span><br><span class="line">   <span class="keyword">if</span> window%smallWindow != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;window cannot be split by integers&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;SlidingWindowLimiter&#123;</span><br><span class="line">      limit:        limit,</span><br><span class="line">      window:       <span class="type">int64</span>(window),</span><br><span class="line">      smallWindow:  <span class="type">int64</span>(smallWindow),</span><br><span class="line">      smallWindows: <span class="type">int64</span>(window / smallWindow),</span><br><span class="line">      counters:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>),</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SlidingWindowLimiter)</span></span> TryAcquire() <span class="type">bool</span> &#123;</span><br><span class="line">   l.mutex.Lock()</span><br><span class="line">   <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取当前小窗口值</span></span><br><span class="line">   currentSmallWindow := time.Now().UnixNano() / l.smallWindow * l.smallWindow</span><br><span class="line">   <span class="comment">// 获取起始小窗口值</span></span><br><span class="line">   startSmallWindow := currentSmallWindow - l.smallWindow*(l.smallWindows<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算当前窗口的请求总数</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">   <span class="keyword">for</span> smallWindow, counter := <span class="keyword">range</span> l.counters &#123;</span><br><span class="line">      <span class="keyword">if</span> smallWindow &lt; startSmallWindow &#123;</span><br><span class="line">         <span class="built_in">delete</span>(l.counters, smallWindow)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         count += counter</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 若到达窗口请求上限，请求失败</span></span><br><span class="line">   <span class="keyword">if</span> count &gt;= l.limit &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若没到窗口请求上限，当前小窗口计数器+1，请求成功</span></span><br><span class="line">   l.counters[currentSmallWindow]++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）</p><p>关于漏桶的实现，uber团队有一个开源的 <a class="link"   href="https://github.com/uber-go/ratelimit" >https://github.com/uber-go/ratelimit<i class="fas fa-external-link-alt"></i></a> 实现。<br>使用方法也比较简单，<code>Take()</code> 方法会返回漏桶下一次滴水的时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;go.uber.org/ratelimit&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 限制每秒100次 -&gt; 每隔10ms会放行一个请求</span></span><br><span class="line">    rl := ratelimit.New(<span class="number">100</span>) <span class="comment">// per second</span></span><br><span class="line"></span><br><span class="line">    prev := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        now := rl.Take()</span><br><span class="line">        fmt.Println(i, now.Sub(prev))</span><br><span class="line">        prev = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 0 0</span></span><br><span class="line">    <span class="comment">// 1 10ms</span></span><br><span class="line">    <span class="comment">// 2 10ms</span></span><br><span class="line">    <span class="comment">// 3 10ms</span></span><br><span class="line">    <span class="comment">// 4 10ms</span></span><br><span class="line">    <span class="comment">// 5 10ms</span></span><br><span class="line">    <span class="comment">// 6 10ms</span></span><br><span class="line">    <span class="comment">// 7 10ms</span></span><br><span class="line">    <span class="comment">// 8 10ms</span></span><br><span class="line">    <span class="comment">// 9 10ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后写一下这个库的详细介绍，在此不多赘述</p><h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。</p><p>对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。</p><p>实现时，我们不需要真正的每隔一段时间去发放令牌，记录下上次访问时间、上次访问令牌剩余数量，<code>(当前时间-上次访问时间)*令牌生成速度+剩余令牌数</code>得出当前令牌数</p><p>可以参考：<a class="link"   href="https://github.com/juju/ratelimit" >https://github.com/juju/ratelimit<i class="fas fa-external-link-alt"></i></a> ，部分代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整令牌数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> adjustavailableTokens(tick <span class="type">int64</span>) &#123;</span><br><span class="line">    lastTick := tb.latestTick</span><br><span class="line">    tb.latestTick = tick</span><br><span class="line">    <span class="keyword">if</span> tb.availableTokens &gt;= tb.capacity &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens += (tick - lastTick) * tb.quantum</span><br><span class="line">    <span class="keyword">if</span> tb.availableTokens &gt; tb.capacity &#123;</span><br><span class="line">        tb.availableTokens = tb.capacity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取令牌，没有的话返回0，不阻塞(Take方法是会阻塞的)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> takeAvailable(now time.Time, count <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    tb.adjustavailableTokens(tb.currentTick(now))</span><br><span class="line">    <span class="keyword">if</span> tb.availableTokens &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count &gt; tb.availableTokens &#123;</span><br><span class="line">        count = tb.availableTokens</span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens -= count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> currentTick(now time.Time) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(now.Sub(tb.startTime) / tb.fillInterval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令牌桶算法能满足绝大部分服务器限流的需要, 是被广泛使用的限流算法, 不过其也有一些缺点:</p><ul><li>令牌桶是没有优先级的，无法让重要的请求先通过</li><li>如果对服务限流进行缩容和扩容，需要人为手动去修改，运维成本比较大</li><li>令牌桶只能对局部服务端的限流, 无法掌控全局资源</li></ul><h2 id="限流的具体使用"><a href="#限流的具体使用" class="headerlink" title="限流的具体使用"></a>限流的具体使用</h2><ul><li>网关限流：可以在nginx处做限流，参考文章 <a class="link"   href="https://cloud.tencent.com/developer/article/2028460" >Nginx限流应用 &amp; 漏桶&#x2F;令牌桶算法原理<i class="fas fa-external-link-alt"></i></a></li><li>服务端限流：以gin框架为例，编写一个限流中间件，加入到需要限流的路由中即可</li><li>自适应限流：结合应用的 Load、CPU 使用率、总体平均 RT(请求成功的响应耗时)、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。如Sentinel</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot;   href=&quot;https://juejin.cn/post/705606897</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="web" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/web/"/>
    
    
    <category term="后端" scheme="https://tbghg.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Goland常用快捷键</title>
    <link href="https://tbghg.top/2023-09-30/8ec2dc5165dc/"/>
    <id>https://tbghg.top/2023-09-30/8ec2dc5165dc/</id>
    <published>2023-09-30T13:28:36.000Z</published>
    <updated>2023-09-30T13:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Goland常用快捷键"><a href="#Goland常用快捷键" class="headerlink" title="Goland常用快捷键"></a>Goland常用快捷键</h1><p>Mac、Win两套的快捷键不同还是有些难搞的，先重点记录下windows的</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://zhuanlan.zhihu.com/p/148127210" >Goland快捷键讲解<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h2><h3 id="上下左右、前后end、翻页"><a href="#上下左右、前后end、翻页" class="headerlink" title="上下左右、前后end、翻页"></a>上下左右、前后end、翻页</h3><p>有可以用自带的，没有可以做以下映射：</p><ul><li>Fn + H&#x2F;J&#x2F;K&#x2F;L  -&gt;  左&#x2F;下&#x2F;上&#x2F;右</li><li>Fn + I&#x2F;O      -&gt;  Home&#x2F;End </li><li>Fn + ;        -&gt;  page up&#x2F; page down</li></ul><h3 id="简单移动"><a href="#简单移动" class="headerlink" title="简单移动"></a>简单移动</h3><ul><li>Ctrl+M 光标所在位置居中 </li><li>Ctrl+左&#x2F;右 移动到上&#x2F;下一个单词 </li><li>Ctrl+Home&#x2F;End 移动到文件首&#x2F;尾处 </li><li>Ctrl+上&#x2F;下 屏幕滑动但光标不动，配合Ctrl+m一起用</li></ul><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li>Ctrl+Alt+右 前进【很常用】</li><li>Ctrl+Alt+左 后退【很常用】</li><li>Ctrl+B 前往声明或用法【常用】</li><li>Ctrl+Alt+B 转到实现 【常用】</li><li>Ctrl+[ 跳转到函数大括号开始 </li><li>Ctrl+] 跳转到函数大括号结束</li><li>Alt+下&#x2F;上 下&#x2F;上一个方法</li><li>Ctrl+G 跳转到 [行:列]</li><li>Ctrl+E 跳转到最近使用的文件，也选到侧框，需要再确定，支持直接搜索</li><li>Ctrl+Tab 跳转到最近的文件，直接跳，与ctrl+e很像，但不用二次确定</li><li>F2跳转到warning，F3跳转到error，但F3和我的Snipaste快捷键有些冲突</li><li>F4跳转到源代码【很常用】</li></ul><p>还没弄明白这个插件是干啥的，之后再看看：</p><p>acejump-lite:当我们要在屏幕上跳转时，如光标在屏幕低，要跳转到屏幕顶某处，就可以使用这个插件，我自定义为 Fn+m, 然后输入跳转的目标字符</p><h3 id="enter下一行-上一行"><a href="#enter下一行-上一行" class="headerlink" title="enter下一行&#x2F;上一行"></a>enter下一行&#x2F;上一行</h3><ul><li>Enter 新建下一行并移动到下一行, 改变此行【常用】</li><li>Shift+Enter 新建下一行并移动到下一行（不改变此行)【常用】</li><li>Ctrl+Enter 拆分此行，鼠标不动，在行尾使用，可新建下一行并鼠标不动</li><li>Ctrl+Alt+Enter 新建上一行并到上一行</li></ul><h3 id="代码更改【常用】"><a href="#代码更改【常用】" class="headerlink" title="代码更改【常用】"></a>代码更改【常用】</h3><ul><li>Shift+F6 重命名</li><li>Ctrl+R 替换</li><li>Ctrl+Shift+F 全局搜索</li><li>Ctrl+Shift+R 全局替换</li><li>Ctrl+D 重复当前行或选中文本</li></ul><h3 id="文件代码"><a href="#文件代码" class="headerlink" title="文件代码"></a>文件代码</h3><ul><li>Ctrl+Alt+L 格式化代码【常用】</li><li>Ctrl+Alt+O 优化导入的类和包</li><li>Ctrl+S save</li></ul><h3 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h3><ul><li>Ctrl+W 扩选代码【常用】 </li><li>Ctrl+Shift+W 撤销扩选</li><li>Ctrl+Shift+Space 智能提示【常用】</li><li>Alt+J 选中相同变量，持续按，逐步选多个【没用过，但貌似有用】&#96;</li><li>Ctrl+Shift+C 复制当前的文件的路径【有用】</li></ul><h2 id="打开-执行对应操作"><a href="#打开-执行对应操作" class="headerlink" title="打开&#x2F;执行对应操作"></a>打开&#x2F;执行对应操作</h2><p>Alt+F1：选择要打开的界面【常用】，重点记一下<br>Ctrl+K git提交界面</p><p>Ctrl+Shift+Space 智能提示</p><p>Ctrl+Shift+A 打开操作搜索界面，快速执行对应的action</p><ul><li>要打开设置，就可以使用键后，输入 settings 即可 </li><li>要打开插件，输入 plugins, </li><li>要把主菜单关掉，可以输入 main ,第一个就是</li><li>要删除文件，可以对着文件输入 delete </li><li>要新建文件，可以输入 go</li><li>要新建项目，可以输入 project</li><li>要 运行代码，可以输入 run </li><li>等等</li></ul><p>总之这个键可以代替大多数需要移动鼠标才能做的，要达到无鼠标编程，这个键需要熟练使用</p><p>按两次shift后会出现：所有、类型、文件、符号、操作、Git，可以Alt+左&#x2F;右切换</p><ul><li>双Shift 所有【常用】</li><li>Ctrl+N 类型</li><li>Ctrl+Shift+N 文件【常用】</li><li>Ctrl+Shift+Alt+N 符号(函数)</li><li>Ctrl+Shift+A 操作【常用】</li></ul><p>实际上记住 双shift &#x3D;&#x3D;&gt; Alt+方向 切换即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Goland常用快捷键&quot;&gt;&lt;a href=&quot;#Goland常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Goland常用快捷键&quot;&gt;&lt;/a&gt;Goland常用快捷键&lt;/h1&gt;&lt;p&gt;Mac、Win两套的快捷键不同还是有些难搞的，先重点记录下windo</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="语言" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="golang" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/golang/"/>
    
    
    <category term="go" scheme="https://tbghg.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go单飞详解(singleflight)</title>
    <link href="https://tbghg.top/2023-08-11/db9d47ddaded/"/>
    <id>https://tbghg.top/2023-08-11/db9d47ddaded/</id>
    <published>2023-08-11T09:54:52.000Z</published>
    <updated>2023-08-11T09:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>singleflight 包提供了一种阻止重复函数调用的机制，主要用在<strong>缓存击穿</strong>的情况下</p><p>某些热点数据的缓存过期或突然失效时，如果有大量的请求访问该数据，在数据写回到缓存前，这些请求都会统一打到DB上，可能会把DB压垮。</p><p>一般的方案有：</p><ol><li>确保热点key不过期</li><li>热点数据读DB写入到缓存时，加个分布式锁</li></ol><p>当然还有一种方式，与2类似，就是sync下的singleflight，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>singleflight.Group类型提供了三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Forget(key <span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>Do方法<ul><li>接受一个字符串Key和一个待调用的函数，会返回调用函数的结果和错误。</li><li>使用Do方法的时候，它会根据提供的Key判断是否去真正调用fn函数。</li><li>同一个 key，在同一时间只有第一次调用Do方法时才会去执行fn函数，其他并发的请求会等待调用的执行结果。</li></ul></li><li>DoChan方法：<ul><li>类似Do方法，只不过是一个异步调用。</li><li>它会返回一个通道，等fn函数执行完，产生了结果以后，就能从这个 chan 中接收这个结果。</li></ul></li><li>Forget方法：<ul><li>在SingleFlight中删除一个Key。</li><li>这样一来，之后这个Key的Do方法调用会执行fn函数，而不是等待前一个未完成的fn 函数的结果。</li></ul></li></ul><p>下面看个简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gsf singleflight.Group</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// v 获取到的值，err 返回的error，shared 结果是否被共享</span></span><br><span class="line">            v, err, shared := gsf.Do(<span class="string">&quot;key&quot;</span>, getNum)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Print(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;获得结果：%v，是否被共享：%v\n&quot;</span>, v, shared)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我被执行了，获取结果10&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">我被执行了，获取结果10</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以发现getNum只被执行了一次，其他请求则是复用第一次请求的结果。</p><p><strong>重点注意</strong>：单飞的fn函数执行完之后，就会把该key删除，之后再有相同的key时会再调一遍，可以参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">            time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// v 获取到的值，err 返回的error，shared 结果是否被共享</span></span><br><span class="line">            v, err, shared := gsf.Do(<span class="string">&quot;key&quot;</span>, getNum)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Print(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;获得结果：%v，是否被共享：%v\n&quot;</span>, v, shared)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我被执行了，获取结果10&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    我被执行了，获取结果10</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    我被执行了，获取结果10</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">    获得结果：10，是否被共享：true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，getNum被调用了两次</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些字段在WaitGroup完成之前被写入一次，并且仅在WaitGroup完成之后被读取</span></span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以前有个forgotten bool，但0.3.0版本是没有了的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只用在Shared = c.dups &gt; 0，判断是否共享</span></span><br><span class="line">    dups  <span class="type">int</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Err    <span class="type">error</span></span><br><span class="line">    Shared <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>singleflight.Group由一个互斥锁sync.Mutex和一个映射表组成，每一个singleflight.call结构体都保存了当前调用对应的信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        <span class="comment">// 等待fn运行完</span></span><br><span class="line">        c.wg.Wait()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测是fn造成panic，还是内部runtime.Goexit</span></span><br><span class="line">        <span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">            <span class="built_in">panic</span>(e)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">            runtime.Goexit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Forget(key <span class="type">string</span>) &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先加锁，判断<code>g.m[key]</code>是否存在，不存在则<code>c.wg.Add</code>并执行fn，存在则<code>c.wg.Wait</code>完成后处理结果。</p><p>其中<code>Forget</code>方法只是删除了g.m中的key，所以在此之前：正在调用fn的请求还是会执行，<code>c.wg.Wait</code>的请求也会获得fn的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doCall handles the single call for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否正常退出fn函数</span></span><br><span class="line">    normalReturn := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 判断函数中是否panic</span></span><br><span class="line">    recovered := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// use double-defer to distinguish panic from runtime.Goexit,</span></span><br><span class="line">    <span class="comment">// more details see https://golang.org/cl/134395</span></span><br><span class="line">    <span class="comment">// 两个defer去判断是fn内部panic还是runtime.Goexit</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// the given function invoked runtime.Goexit</span></span><br><span class="line">        <span class="comment">// fn没有正常退出，且recovered仍为false</span></span><br><span class="line">        <span class="comment">// 说明没走到最下面的 if !normalReturn 判断，认为发生了runtime.Goexit</span></span><br><span class="line">        <span class="keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;</span><br><span class="line">            c.err = errGoexit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">        c.wg.Done()</span><br><span class="line">        <span class="comment">// 删除该key，下次执行时遇到该key重新调fn去</span></span><br><span class="line">        <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">            <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">            <span class="comment">// In order to prevent the waiting channels from being blocked forever,</span></span><br><span class="line">            <span class="comment">// needs to ensure that this panic cannot be recovered.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(c.chans) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="built_in">panic</span>(e)</span><br><span class="line">                <span class="keyword">select</span> &#123;&#125; <span class="comment">// Keep this goroutine around so that it will appear in the crash dump.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">            <span class="comment">// Already in the process of goexit, no need to call again</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Normal return</span></span><br><span class="line">            <span class="comment">// 写到ch中，DoChan方法调用的话会用到</span></span><br><span class="line">            <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">                ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">                <span class="comment">// Ideally, we would wait to take a stack trace until we&#x27;ve determined</span></span><br><span class="line">                <span class="comment">// whether this is a panic or a runtime.Goexit.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Unfortunately, the only way we can distinguish the two is to see</span></span><br><span class="line">                <span class="comment">// whether the recover stopped the goroutine from terminating, and by</span></span><br><span class="line">                <span class="comment">// the time we know that, the part of the stack trace relevant to the</span></span><br><span class="line">                <span class="comment">// panic has been discarded.</span></span><br><span class="line">                <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">                    c.err = newPanicError(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        c.val, c.err = fn()</span><br><span class="line">        normalReturn = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">        recovered = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与Do类似，不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> ch</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="singleflight存在的问题"><a href="#singleflight存在的问题" class="headerlink" title="singleflight存在的问题"></a>singleflight存在的问题</h2><ul><li>一人超时，全员超时</li><li>一人错，全员错</li><li>singleflight是一把大锁，在高并发时锁冲突严重，故需要针对性的做些优化</li><li>singleflight不携带context，缺少一些控制机制</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a class="link"   href="https://zhuanlan.zhihu.com/p/382965636" >golang防缓存击穿神器【singleflight】<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6971002900608712711" >Go缓存击穿方案-singleflight源码解读<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pkg.go.dev/golang.org/x/sync/singleflight" >go-pkg<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;singleflight 包提供了一种阻止重复函数调用的机制，主要用在&lt;strong&gt;缓存击穿&lt;/strong&gt;的情况下&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="语言" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="golang" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/golang/"/>
    
    
    <category term="go" scheme="https://tbghg.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go ACM模式处理输入输出</title>
    <link href="https://tbghg.top/2023-08-01/ec40e5e5fa07/"/>
    <id>https://tbghg.top/2023-08-01/ec40e5e5fa07/</id>
    <published>2023-08-01T01:16:05.000Z</published>
    <updated>2023-08-01T01:16:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面试时ACM模式较多，力扣以核心代码模式为主，特地训练下ACM模式处理输入输出</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li>ACM模式较好的练习地点：<a class="link"   href="https://kamacoder.com/" >https://kamacoder.com/<i class="fas fa-external-link-alt"></i></a></li><li>Golang常规处理输入输出：<a class="link"   href="https://blog.csdn.net/weixin_44211968/article/details/124632136" >https://blog.csdn.net/weixin_44211968/article/details/124632136<i class="fas fa-external-link-alt"></i></a></li><li>bufio处理输入输出：<a class="link"   href="https://www.acwing.com/blog/content/28740/" >https://www.acwing.com/blog/content/28740/<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>在此用洛谷中的一道题说明一下：<a class="link"   href="https://www.luogu.com.cn/problem/P1886" >P1886 滑动窗口 &#x2F;【模板】单调队列<i class="fas fa-external-link-alt"></i></a></p><p>使用常规输入输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, k <span class="type">int</span></span><br><span class="line">fmt.Scanln(&amp;n, &amp;k)</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Scan(&amp;list[i])</span><br><span class="line">&#125;</span><br><span class="line">max, min := slidingWindow(list, k)</span><br><span class="line"><span class="comment">// 直接for循环输出也可</span></span><br><span class="line">fmt.Println(strings.Trim(fmt.Sprint(min), <span class="string">&quot;[]&quot;</span>))</span><br><span class="line">fmt.Println(strings.Trim(fmt.Sprint(max), <span class="string">&quot;[]&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(list []<span class="type">int</span>, k <span class="type">int</span>)</span></span> (max, min []<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> maxWindow, minWindow []<span class="type">int</span></span><br><span class="line"><span class="comment">// 单调递减队列</span></span><br><span class="line">maxPush := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(maxWindow) &gt; <span class="number">0</span> &amp;&amp; list[maxWindow[<span class="built_in">len</span>(maxWindow)<span class="number">-1</span>]] &lt; list[i] &#123;</span><br><span class="line">maxWindow = maxWindow[:<span class="built_in">len</span>(maxWindow)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">maxWindow = <span class="built_in">append</span>(maxWindow, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单调递增队列</span></span><br><span class="line">minPush := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(minWindow) &gt; <span class="number">0</span> &amp;&amp; list[minWindow[<span class="built_in">len</span>(minWindow)<span class="number">-1</span>]] &gt; list[i] &#123;</span><br><span class="line">minWindow = minWindow[:<span class="built_in">len</span>(minWindow)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">minWindow = <span class="built_in">append</span>(minWindow, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">maxPush(i)</span><br><span class="line">minPush(i)</span><br><span class="line">&#125;</span><br><span class="line">max = <span class="built_in">append</span>(max, list[maxWindow[<span class="number">0</span>]])</span><br><span class="line">min = <span class="built_in">append</span>(min, list[minWindow[<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(list); i++ &#123;</span><br><span class="line">maxPush(i)</span><br><span class="line">minPush(i)</span><br><span class="line"><span class="comment">// 删除超出窗口的部分</span></span><br><span class="line"><span class="keyword">for</span> maxWindow[<span class="number">0</span>] &lt; i-k+<span class="number">1</span> &#123;</span><br><span class="line">maxWindow = maxWindow[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> minWindow[<span class="number">0</span>] &lt; i-k+<span class="number">1</span> &#123;</span><br><span class="line">minWindow = minWindow[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">max = <span class="built_in">append</span>(max, list[maxWindow[<span class="number">0</span>]])</span><br><span class="line">min = <span class="built_in">append</span>(min, list[minWindow[<span class="number">0</span>]])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是有三个超时，其他通过，可自行尝试</p><p>分析下原因，每次<code>fmt.Scan</code>时都会进行一次系统调用，如果N较大，那时间开销相对就比较大，我们可以使用<code>bufio</code>库将数据直接读取到缓存中，整体只需要一次系统调用，时间开销要小很多</p><p>相应的，输出时如果我们选择for循环每次print一个数据，那时间开销也会很长，但将数据通过<code>strings.Trim(fmt.Sprint(min), &quot;[]&quot;)</code>处理好之后再输出，总共两次<code>fmt.Println</code>系统开销要小很多。同时我们也可以把结果放到缓冲区中，再通过<code>Flush</code>将数据写出</p><p>我们先来看处理输入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, k <span class="type">int</span></span><br><span class="line">fmt.Scanln(&amp;n, &amp;k)</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Scanf(&quot;%d %d/n&quot;, &amp;n, &amp;k)</span></span><br><span class="line"><span class="comment">// os.Stdin标准输入，写入到缓存中</span></span><br><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="comment">// os.Stdout标准输出</span></span><br><span class="line"><span class="comment">// out := bufio.NewWriter(os.Stdout)</span></span><br><span class="line"><span class="comment">// 从缓存中读取数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Fscan(in, &amp;list[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max, min := slidingWindow(list, k)</span><br><span class="line">fmt.Println(strings.Trim(fmt.Sprint(min), <span class="string">&quot;[]&quot;</span>))</span><br><span class="line">fmt.Println(strings.Trim(fmt.Sprint(max), <span class="string">&quot;[]&quot;</span>))</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后，所有数据点可通过</p><p>我们再来看下输出，这时我们用了两次<code>fmt.Println</code>，也就是会进行两次系统调用，那我们如果将结果写入输出的缓存中，最后<code>os.Flush</code>是不是可以对时间进一步优化呢，原则上是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, k <span class="type">int</span></span><br><span class="line">fmt.Scanln(&amp;n, &amp;k)</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Scanf(&quot;%d %d/n&quot;, &amp;n, &amp;k)</span></span><br><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line">out := bufio.NewWriter(os.Stdout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Fscan(in, &amp;list[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max, min := slidingWindow(list, k)</span><br><span class="line"><span class="comment">//fmt.Println(strings.Trim(fmt.Sprint(min), &quot;[]&quot;))</span></span><br><span class="line"><span class="comment">//fmt.Println(strings.Trim(fmt.Sprint(max), &quot;[]&quot;))</span></span><br><span class="line"><span class="comment">// 将数据处理好后，写入out缓存中</span></span><br><span class="line">fmt.Fprint(out, fmt.Sprint(strings.Trim(fmt.Sprint(min), <span class="string">&quot;[]&quot;</span>)+<span class="string">&quot;\n&quot;</span>+strings.Trim(fmt.Sprint(max), <span class="string">&quot;[]&quot;</span>)))</span><br><span class="line"><span class="comment">// 将缓存中的数据刷新到io.Writer</span></span><br><span class="line">out.Flush()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的运行结果是有一个点报MLE了（按照第二种写法，那个点是100.16MB）</p><p>这个也比较好理解，对于数据量比较变态的情况，及时将数据输出，可以预防MLE，所有结果合起来再输出，就有可能会超出规定内存</p><p>当然，输入也有可能会超出默认缓存大小，这个时候需要根据实际情况进行调整，例如 <a class="link"   href="https://www.acwing.com/blog/content/28740/" >https://www.acwing.com/blog/content/28740/<i class="fas fa-external-link-alt"></i></a> 中提到的：</p><p>特殊场合 当一次输入超大时：<a class="link"   href="https://www.acwing.com/activity/content/11/" >3302. 表达式求值<i class="fas fa-external-link-alt"></i></a></p><p>将输入缓存设置为<code>20000 * 1024</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in = bufio.NewScanner(os.Stdin)</span><br><span class="line">bs = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">20000</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">in.Buffer(bs, <span class="built_in">len</span>(bs))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;面试时ACM模式较多，力扣以核心代码模式为主，特地训练下ACM模式处理输入输出&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;&lt;a href=&quot;#推荐</summary>
      
    
    
    
    <category term="技术" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://tbghg.top/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="go" scheme="https://tbghg.top/tags/go/"/>
    
    <category term="算法" scheme="https://tbghg.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

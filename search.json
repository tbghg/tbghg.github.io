[{"title":"写代码的魔愣时刻","url":"/2022-03-16/0a5b85a98e14/","content":"\n\n","categories":["生活"]},{"title":"如何speexx刷口语？","url":"/2021-06-28/b48ad6246916/","content":"笔者用的软件是”鼠大侠“，下面阐述一下鼠标宏的制作条件：\n双开speexx网页，一个听，一个播放，发现可以实现\n\n人工通过此方式刷speexx时发现所要点击的方式是固定的\n\n鼠大侠这个软件每一周都有软件试用一天的效果\n\n\n鼠标宏的运行流程：\n首先规划分屏，我将做题区域放到了右面，让系统寻找下图：并且判断是否在右侧，如果找到匹配度大于90%并在右侧则将鼠标移动至此。但值得一提的是笔者比较懒，没写判断是否在右侧，而是把左侧那个遮住了，如图：\n\n然后鼠标点击，即开始录音，然后鼠标移动到左侧播放页面的播放位置\n\n等待8秒让他读完，检测是否存在如果存在证明读的可以，操纵鼠标让左右侧页面均点击下一个，如果没读过就一直这样读下去，直到读过去为止\n\n重复上面的步骤，直到读完\n\n\n那么咱们抛开制作应该如何白嫖使用呢？\n下载叫做鼠大侠的一个软件\n\n扫码关注他的微信公众号白嫖一天会员\n\n双开网页，做题网页在右，左侧网页让他小到不出现答题按钮\n\n导入鼠标宏（下面附），修改鼠标移动到的位置\n\n按下F8运行\n\n挂机出去玩\n\n作业做完了\n\n\n最后脚本链接如下：链接：https://pan.baidu.com/s/1CGWHZjeL4gwj6A7lkGwAMw 提取码：wt1h\n","categories":["生活"],"tags":["课业技巧"]},{"title":"实现MOOC快速互评","url":"/2021-06-28/f72defb44f0e/","content":"MOOC互评总是一件令人头疼的事，尤其是工数这种二十多道题需要评5份以上，笔者饱受互评之苦久矣，于近期用C语言写了个小小的脚本，可供参考。\n在MOOC互评界面，当我们按tab键时光标会依次从打分选项跳到评语再跳到打分选项那种，并且我们可以惊奇的发现，当我们在打分选项使用←键时就会从零分跳到最高分，在这两个前提下，我们就可以操作了。 依次执行：\n\n按下 ← 键 抬起 ← 键\n按下 ctrl 按下 v 键\n抬起 v 键 抬起 ctrl\n\n这时我们就执行完了一个模块了：\n\n如果是评语，← 键对他无影响，相当于只是一个 ctrl + v\n如果是打分模块，我们←键就会让他从 0 到最高分，ctrl + v 对他无影响。\n\n在执行完这一套之后我们再执行 按下 tab 键 抬起 tab 键，并一直循环这些就可以实现自动互评了。\n代码如下，读者可自行探索\n#include&lt;stdio.h&gt;#include&lt;windows.h&gt;/*前提当我们按tab键时光标会依次从打分选项跳到评语再跳到打分选项那种，并且我们可以惊奇的发现，当我们在打分选项使用←键时就会从零分跳到最高分，在这两个前提下，我们就可以操作了。依次执行：按下←键 抬起←键 按下ctrl 按下v键 抬起v键 抬起ctrl 这时我们就执行完了一个模块了：如果是评语，←键对他无影响，相当于只是一个ctrl+v如果是打分模块，我们←键就会让他从0到最高分，ctrl+v对他无影响。在执行完这一套之后我们再执行 按下tab键 抬起tab键，并一直循环这些就可以实现自动互评了。*/int main()&#123;  int a;  system(&quot;pause&quot;);//暂停一下留有准备时间  while(1)//一直执行以下代码  &#123;    //keybd_event函数的用法见下面（下面那个网址）    keybd_event(37,0,0,0);//按下←键 （37对应的是←键，网址中有对应表，下同）    keybd_event(37,0,KEYEVENTF_KEYUP,0);//抬起←键    keybd_event(17,0,0,0);//按下ctrl    keybd_event(86,0,0,0);//按下v键    keybd_event(17,0,KEYEVENTF_KEYUP,0);//抬起v键     keybd_event(86,0,KEYEVENTF_KEYUP,0);//抬起ctrl     keybd_event(9,0,0,0);//按下tab键    keybd_event(9,0,KEYEVENTF_KEYUP,0); //抬起tab键    Sleep(300);//让程序休眠0.3秒，怕电脑跟不上    //上面这个已经没问题了，只不过我们评完之后还会继续运行，需要再关闭    //那我们应该怎么做才能让他停下来的更方便些呢？我们可以进行以下操作    a =GetKeyState(VK_SPACE);//获取空格键的状态，这个函数自行百度即可    if(a&lt;0)//如果空格键被按下      return 0;//结束了这个程序    //就是说现在我们运行完之后只要按下空格就可以退出程序了，大功告成！  &#125;  return 0;&#125;\n\nkeybd_event的使用方法 及 常用模拟键的键值对照表\n","categories":["生活"],"tags":["课业技巧"]},{"title":"记录一次rm rf事件","url":"/2021-06-28/27c83dce2cfb/","content":"结果展示\n\n\n这是一次较为惨痛的事件，相信大家都知道rm -rf这个命令吧，这是笔者错误执行了某些代码后的结果（桌面十分的干净，删除了包括而不限于我的大英作业、大物仿真作业、科中名词解释作业以及第二天要用到的科中期末大会总结ppt）。\n事件分析起因是这样的，笔者打算在虚拟机上安装科学上网工具，在虚拟机中通过sh脚本安装软件，但是笔者发现他的脚本中安装的软件是从外网上面安装的，导致笔者的电脑一直显示安装超时，于是笔者决定先从自己的电脑下载好他要下载的东西，然后修改sh脚本。最终改成了下面的代码（源代码懒得去找了）：\n#!/bin/sh\\# Set ARGPLATFORM\\=$1TAG\\=$2if \\[ \\-z &quot;$PLATFORM&quot; \\]; then ARCH\\=&quot;64&quot;else case &quot;$PLATFORM&quot; in linux/386) ARCH\\=&quot;32&quot; ;; linux/amd64) ARCH\\=&quot;64&quot; ;; linux/arm/v6) ARCH\\=&quot;arm32-v6&quot; ;; linux/arm/v7) ARCH\\=&quot;arm32-v7a&quot; ;; linux/arm64linux/arm64/v8) ARCH\\=&quot;arm64-v8a&quot; ;; \\*) ARCH\\=&quot;&quot; ;; esacfi\\[ \\-z &quot;$&#123;ARCH&#125;&quot; \\] &amp;&amp; echo &quot;Error: Not supported OS Architecture&quot; &amp;&amp; exit 1\\# Download filesV2RAY\\_FILE\\=&quot;v2ray-linux-$&#123;ARCH&#125;.zip&quot;DGST\\_FILE\\=&quot;v2ray-linux-$&#123;ARCH&#125;.zip.dgst&quot;if \\[ $? \\-ne 0 \\]; then echo &quot;Error: Failed to download binary file: $&#123;V2RAY\\_FILE&#125; $&#123;DGST\\_FILE&#125;&quot; &amp;&amp; exit 1fiecho &quot;Download binary file: $&#123;V2RAY\\_FILE&#125; $&#123;DGST\\_FILE&#125; completed&quot;\\# Check SHA512LOCAL\\=$(openssl dgst -sha512 v2ray.zip  sed &#x27;s/(\\[^)\\]\\*)//g&#x27;)STR\\=$(cat v2ray.zip.dgst  grep &#x27;SHA512&#x27;  head -n1)if \\[ &quot;$&#123;LOCAL&#125;&quot; \\= &quot;$&#123;STR&#125;&quot; \\]; then echo &quot; Check passed&quot; &amp;&amp; rm \\-fv v2ray.zip.dgstelse echo &quot; Check have not passed yet &quot; &amp;&amp; exit 1fi\\# Prepareecho &quot;Prepare to use&quot;unzip v2ray.zip &amp;&amp; chmod +x v2ray v2ctlmv v2ray v2ctl /usr/bin/mv geosite.dat geoip.dat /usr/local/share/v2ray/mv config.json /etc/v2ray/config.json\\# Cleanrm \\-rf $&#123;PWD&#125;/\\*echo &quot;Done&quot;\n\n笔者直接从主机上下载它要下载的东西，所以需要将代码中对应下载那一行的代码删除，要不还是会出现下载超时的现象，最终改成了这个代码，比较凑巧的是笔者在主机上安装过git bash，于是主机上直接就可以运行这个sh脚本，然后就先在主机上面试了试，结果如上图，桌面变的特别干净。。。\n大家应该已经看出这代码有些不对劲了吧，对，rm -rf ${PWD}就这玩意。\n想必大家应该清楚怎么回事了吧……\n原本作者是想把当前工作目录的安装包什么的清了，但是我当时把给pwd赋值的那行也删了，因为刚开始的工作环境是在桌面，于是我桌面没了……\n反思sh脚本这种东西，执行前还是先大概看看吧，首先拿记事本打开，ctrl+F查找一下rm什么的，看看有没有一些危险的代码，确认无误之后再去执行。我这种就属于shell没学明白就瞎倒腾的。\n后记笔者痛失大英作业和同学聊天时，同学表示，你跟老师说这些还不如跟老师说你作业被猫撕了可信度高……\n","categories":["生活"],"tags":["Linux"]},{"title":"2.1 密码学（NISP一级学习）","url":"/2022-01-23/4c5adac2002a/","content":"前言TBH的上课笔记。\n\n密码学的发展\n古典密码 受算法限制\n近代密码\n现代密码（香农） 新特点：基于密钥而非算法\n公钥密码 无密钥传输保密通信成为可能\n\n加密与解密加密通过密码算法实现，密码算法从密钥使用角度分为对称密码算法和非对称密码算法。\n对称密码算法也称单钥&#x2F;私钥密码算法：加密解密密钥相同或实质上相同（可从一个推出另一个）\n\nDES、3DES、IDEA、AES\n密钥相对较短，一般采用128、192、256比特\n\n\n非对称密码算法非对称密码算法：加密密钥和解密密钥不同，从一个很难推出另一个。其中，对外公开的密钥，称为公开密钥( public key)，简称公钥；必须保密的密钥，称为私有密钥( private key)，简称私钥。又叫公钥密码算法( Public-keycipher)。\n例如：RSA、ECC、ELGamal\n\n公钥加密 私钥解密\n私钥加密 公钥解密\n密钥长度512-2048位\n\n优点：\n密钥分发数目与参与者数目相同\n在有大量参与者的情况下易于密钥管理一安全\n支持数字签名和不可否认性\n无需事先与对方建立关系，交换密钥\n\n缺点：\n速度相对较慢（可能比同等强度的对称密码算法慢10倍到100倍）\n加密后，密文变长\n\n混合加密将公钥进行非对称加密\n\n\n\n哈希函数\n对称密码和非对称密码算法主要解决信息的机密性问题，而实际系统和网络还可能受到消息篡改等攻击。\n篡改攻击主要包括：修改信息内容，改变程序使其不能正确运行等。哈希函数可以用来保证信息的完整性。\n哈希(Hash)函数(也称为杂凑函数或单向散列函数)接受一个消息作为输入，产生一个称为哈希值的输出。输出的哈希值也可称为散列值、消息摘要(Message Digest,MD)\n\nMD5MD:Message Digest，消息摘要\n\n输入∶任意长度的消息\n输出∶128位消息摘要\n处理∶以512位输入数据块为单位\n\nSHA-1 算法SHA ( Secure Hash Algorithm，安全哈希算法）由美国国家标准技术研究所开发\n\n输入∶最大长度为264位的消息\n输出:160位消息摘要\n处理∶输入以512位数据块为单位处理\n\n比较SHA-1&#x2F;MD5\n散列值长度MD5 128bitsSHA1 160bits\n安全性SHA1算法被视为MD5的替代候选算法\n速度SHA1慢些( openssl speed md5&#x2F;sha1 )\n\n数字签名\nA将文件的哈希值进行私钥加密后与文件、文件的哈希值一并发过去。\nB用A的公钥对加密的哈希值进行解密，如果与文件的哈希值相符则证明是A。\n\n\n\n可信性：签名让文件的接收者相信签名者是慎重地在文件上签名的。\n不可重用性：签名不可重用，即使同一消息在不同时刻的签名也是有区别的。如果将签名部分提取出来，附加在别的消息后面，验证签名会失败。这是因为签名和所签名消息之间是一一对应的，消息不同签名内容也不同，因此签名无法重复使用。\n数据完整性：在文件签名后，文件不能改变。\n不可伪造性：签名能够证明是签名者而不是其他人在文件上签名，任何人都不能伪造签名。\n不可否认性：在签名者否认自己的签名时，签名接收者可以请求可信第二方进行仲裁。\n\n","categories":["技术","CTF"],"tags":["NISP","安全"]},{"title":"2.2 数字证书与公钥基础设施（NISP一级）","url":"/2022-01-25/89b23de9ce06/","content":"数字证书\n绑定用户身份和公钥\n网络世界的电子身份证\n\n\n与现实世界的身份证类似\n能够证明个人、团体或设备的身份\n\n\n包含相关信息\n\n\n包含姓名、地址、公司、电话号码、Email地址、..与身份证上的姓名、地址等类似\n包含所有者的公钥\n\n\n拥有者拥有证书公钥对应的私钥\n由可信的颁发机构颁发\n\n\n比如身份证由公安局颁发一样\n\n\n颁发机构对证书进行签名\n\n\n与身份证上公安局的盖章类似\n可以由颁发机构证明证书是否有效\n可防止擅改证书上的任何资料\n\n\n公钥基础设施\nPKI :Public Key Infrastructure 公钥基础设施\n\n\n利用公开密钥技术建立的提供信息安全服务的在线基础设施。它利用加密、数字签名、数字证书来保护应用、通信或事务处理的安全\n是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和数字证书的产生、管理、存储、分发和撤销等功能\n如同电力基础设施为家用电器提供电力一样，PKI为各种应用提供安全保障，提供网络信任基础\n\nCA : 认证权威机构CA专门负责数字证书的产生、发放和管理，以保证数字证书真实可靠。它是公钥基础设施 PKI 的核心，CA负责管理P阳结构下的所有用户(包括各种应用程序)证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份。\n主要功能：\n\n签发数字证书\n\n\n签发证书\n更新证书\n\n\n管理数字证书\n\n\n撤销、查询\n审计、统计\n\n\n验证数字证书\n\n\n黑名单认证（CRL )\n\n\nRA的设立、审查及管理\n\nRA : 证书注册机构\n证书注册权威\n\n\nRegistration Authority\n\n\n受理用户的数字证书申请\n\n\n对证书申请者身份进行审核并提交CA制证\n类似于申请身份证的派出所\n\n\n提供证书生命期的维护工作\n\n\n受理用户证书申请\n协助颁发用户证书\n审核用户真实身份\n受理证书更新请求\n受理证书吊销\n\n目录服务（LDAP )证书的存储库，提供了证书的保存、修改、删除和获取的能力。\nCA采用LDAP标准的目录服务存放证书作用与数据库相同优点是在修改操作少的情况下，对于访问的效率比传统数据库要高\nCRL 证书撤销列表CRL 证书撤销列表 (Certificate Revocation List)，也称“证书黑名单”\n在证书的有效期期间，因为某种原因（如人员调动、私钥泄漏等等），导致相应的数字证书内容不再是真实可信，此时，进行证书撤销，说明该证书已是无效\nCRL中列出了被撤销的证书序列号\n证书载体内存、IC卡、软盘、USB-KEY等均可\n","categories":["技术","CTF"],"tags":["NISP","密码学"]},{"title":"2.3 身份认证","url":"/2022-01-27/fc301c280d90/","content":"\n单向认证\n双向认证\n第三方认证\n\n身份认证基本方法身份认证一般依据以下三种基本情况或这三种情况的组合来鉴别用户身份。\n\n用户所知的东西，例如口令、密钥等\n用户拥有的东西，例如印章、U盾(USB Key)等\n用户所具有的生物特征:例如指纹、声音、虹膜、人脸等\n\n根据用户所知认证根据“用户所知”进行认证的方法有：\n2.3 身份认证\n单向认证\n双向认证\n第三方认证\n\n身份认证基本方法身份认证一般依据以下三种基本情况或这三种情况的组合来鉴别用户身份。\n\n用户所知的东西，例如口令、密钥等\n用户拥有的东西，例如印章、U盾(USB Key)等\n用户所具有的生物特征:例如指纹、声音、虹膜、人脸等\n\n根据用户所知认证根据“用户所知”进行认证的方法有：\n\n静态口令认证 口令固定不变，且长期有效 弱鉴别 缺点：\n短信口令认证\n动态口令认证 又称一次性口令(One Time Password ,OTP)\n口令动态性–每次变化，无须人工干\n口令随机性–随机性强，难以猜测\n\n\n\n根据用户所有认证U盾(USB KEY)采用软硬件相结合的挑战&#x2F;应答认证模式。\nUSB Key是一种USB接口的硬件设备 内置单片机或智能卡芯片 可以存储用户的密钥或数字证书 利用USB Key内置的密码算法实现对用户身份的认证\n挑战&#x2F;应答认证模式，即认证系统发送一个随机数(挑战)，用户使用USB Key中的密钥和算法计算出一个数值(应答)，认证系统对该数值进行检验，若正确则认为是合法用户。\n基于生物特征的身份认证\n指纹识别的实现原理\n虹膜识别的实现原理\n其他身份认证技术\n根据用户所有认证U盾(USB KEY)采用软硬件相结合的挑战&#x2F;应答认证模式。\nUSB Key是一种USB接口的硬件设备 内置单片机或智能卡芯片 可以存储用户的密钥或数字证书 利用USB Key内置的密码算法实现对用户身份的认证\n挑战&#x2F;应答认证模式，即认证系统发送一个随机数(挑战)，用户使用USB Key中的密钥和算法计算出一个数值(应答)，认证系统对该数值进行检验，若正确则认为是合法用户。\n基于生物特征的身份认证\n指纹识别的实现原理\n虹膜识别的实现原理\n其他身份认证技术\n","categories":["技术","CTF"],"tags":["NISP"]},{"title":"2.4 访问控制 2.5 安全审计 NISP一级","url":"/2022-01-27/cdc9a7fea900/","content":"访问控制的概念和目标访问控制︰针对越权使用资源的防御措施 目标∶防止对任何资源（如计算资源、通信资源或信息资源)进行未授权的访问，从而使资源在授权范围内使用，决定用户能做什么，也决定代表一定用户利益的程序能做什么。\n主体与客体\n\n控制策略\n是主体对客体的相关访问规则集合，即属性集合。访问策略体现了一种授权行为，也是客体对主体某些操作行为的默认\n访问控制是主体依据某些控制策略或访问权限，对客体本身或其资源赋予不同访问权限的能力，从而保障数据资源在合法范围内得以有效使用和管理\n访问控制安全策略实施遵循最小特权原则。在主体执行操作时，按照主体所需权利的最小化原则分配给主体权力。最大限度地限制主体实施授权行为，避免突发事件、操作错误和未授权主体等意外情况可能给系统造成的危险。\n\n授权规定主体可以对客体执行的操作 如：读、写、执行、拒绝访问··· ···\n自主访问控制与强制访问控制的比较\n自主访问控制\n细粒度\n灵活性高\n配置效率低\n\n\n强制访问控制\n控制粒度大\n灵活性不高\n安全性强\n\n\n\n基于角色的访问控制(RBAC)每个用户必须扮演某种角色\n\n特点：\n\n便于授权管理(角色的变动远远低于个体的变动)\n便于处理工作分级，如文件等资源分级管理\n利用安全约束，容易实现各种安全策略，如最小 特权、职责分离等\n便于任务分担，不同角色完成不同的任务\n\n2.5 安全审计安全审计受到威胁后，如何从安全事故中恢复过来，使系统尽快运作起来，需要预先采取一些措施。\n安全审计是提高安全性的重要工具，它能够再现问题，以帮助事后的责任追查和数据恢复等。\n审计技术的出现早于计算机技术，它按照时间顺序产生、记录系统事件，并对其进行检查。安全审计可以跟踪和监测系统中的异常事件，也可以监视系统中其他安全机制的运行情况。\n计算机安全审计(Audit)是指按照一定的安全策略，记录历史操作事件，并利用记录进行分析，发现系统漏洞、入侵行为等，并改善系统性能和安全性的一系列过程。\n安全审计是对访问控制的必要补充，它会对用户使用何种信息资源、使用的时间，以及如何使用(执行何种操作)进行记录与监控。通过对系统和用户进行充分和适当的审计，能够分析发现安全事件的原因，并提供相应的证据。\n日志日志是安全审计系统的主要组成部分。为了维护自身系统资源的运行状况，计算机系统一般都会有相应的日志系统，记录有关日常事件或者误操作警报的日期及时间。\n受到可疑攻击或安全威胁后，可以通过查看事件安全日志来确认可疑或恶意的行为。例如，通过查看事件日志，发现非工作时间某个用户成功登录账户，则可能有人窃取了账号和口令：日志中有多次登录失败的记录，则可能有攻击者尝试进入系统。\n安全审计可以分成被动式审计、主动式审计两种。 被动式审计就是简单地记录一些活动，并不做处理。 主动式审计一般包括：结束一个登录会话、拒绝一些主机的访问（包括WEB站点，FTP （File Transfer Protocol，文件传输协议）服务器和电子邮件服务器)、跟踪非法活动的源位置等行为。\n安全审计的作用\n\n","categories":["技术","CTF"],"tags":["NISP"]},{"title":"3.1 网络基础知识 3.2 网络安全威胁 NISP一级","url":"/2022-01-27/f07ed7043738/","content":"Internet和TCP&#x2F;IP协议因特网( Internet )通过TCP&#x2F;IP协议将遍布在全世界各地的计算机互联，从而形成超级计算机网络。\n何为协议协议其实是一种约定 大家预先约定好规则，之后都按照这同一个规则执行 就像多家公司合作，一开始要签协议似的\n\n网络中的协议(Protocol )，是指实现约定或定义的一组通信规则\n它精确地规定了所交换数据的格式和传输方法\n不同网络必须遵守统一的协议才能相互通信\nTCP&#x2F;IP是一组不同层次上的多个协议组合\n其定义了电子设备如何接入互联网，以及数据如何在他们之间传输\n\n网络协议模型中OSI与TCP&#x2F;IP\nTCP&#x2F;IP协议分层\n网络中的通信地址通信中，每台计算机必须有一个全球唯一的物理地址 这个地址工作在网络接口层，被称为MAC地址( 48bit )\n网络中的通信地址通信中，每台计算机还必须有一个逻辑地址 这个地址工作在IP层被称为IP地址(32bit )(ipv4) [ipv6的长度为128bit]\n封装与解封装\nIPv4\n\n版本:IPv4版本\n包头长度:IPv4包头长度\n服务类型∶针对该IPv4数据包定义转发优先级\n数据包长度:IPv4数据包总长度&#x3D;IPv4包头长度+IPv4\n用户数据长度标识∶分片重组时保持统一\n标记∶第二bit置1，表示不能分片﹔第三bit置1，表示最后一片。\n偏移︰分片重组时还原原始数据位置\n生存期:每经过一跳此数值减1，避免数据平面环路导致的无限转发协议类型:表示上层协议类型\n包头校验和︰用于校验IPv4包头的正确性\n原IP地址∶发送方的IPv4地址\n目的IP地址∶接收方的IPv4地址\n可选项︰用于表示对IPv4数据包进行一些特殊处理的信息\n用户数据:IPv4头部上层负载的全部数据\n\n端口port计算机中有一些协议常用端口，这些端口绑定了一些服务且明确表示使用。 范围是0~65535\nTCP&#x2F;UDP传输控制协议TCP\n提供面向连接的、可靠的字节流服务\n提供可靠性服务\n\n\n用户数据报协议UDP\n用户数据报协议：提供面向事务的简单不可靠信息传送服务\n无连接、不可靠。协议简单、占用资源少，效率高\n\n\n超文本传输协议HTTP\n是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。\n它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n\n统一资源定位符URL\n用户在访问网站时，为了获取特定的信息资源，需要给出特定资源的地址，即统一资源定位符(Uniform Resource Locator, URL)。它是用来标识万维网中每个信息资源的地址。\nURL由三部分组成，表示形式为∶ http:&#x2F;&#x2F;主机域名或IP地址[:端口号]&#x2F;文件路径&#x2F;文件名\n\n3.2 网络安全威胁攻击者可以通过网络嗅探、网络钓鱼、拒绝服务、远程控制、社会工程学等网络攻击手段，获得目标计算机的控制权，或获取有价值的数据和信息等。\n网络嗅探通过解惑、分析网络中传输的数据而获取有用的信息\n\n网络钓鱼\n拒绝服务\n","categories":["技术","CTF"],"tags":["NISP","网络安全"]},{"title":"3.3 网络安全防护与实践 3.4 无线局域网安全防护 3.5 实验 NISP一级","url":"/2022-01-27/479619c9c7f7/","content":"虚拟专用网络VPN虚拟专用网络(Virtual Private Network ，VPN)是在公用网络上建立专用网络的技术。\nVPN的特点\n成本低\n安全性高\n服务质量保证\n可管理性\n可扩展性\n\nVPN常用协议\nIPSec协议\n安全套接层协议SSL\n\nVPN的应用\n远程访问VPN，适用于企业内部人员流动频繁或远程办公的情况。\n内联网VPN，适用于相同企业内部异地互联的情况。\n外联网VPN，适用于不同企业之间互联的情况。\n\n防火墙指设置在不同网络(如:可信任的内网和外网或专用网与不可信的共用网)之间的一系列包括软硬件在内的部件组合。它在内网和外网之间构建一道保护屏障，网络内部和外部之间的所有数据流必须经过防火墙，只有符合安全标准的数据流才能通过防火墙。\n\n\n数据包过滤\n审计和报警机制\n远程管理\n网络地址转换\n代理\n流量控制、统计分析和流量计费\n\n3.4 无线局域网安全防护增强无线网络安全性的措施\n修改admin密码\n使用无线网络安全协议\n禁用DHCP服务\n禁止SSID广播\n禁止远程管理\nMAC地址过滤\n合理放置无线AP\n\n3.5 实验ping常用参数-t 持续ping -n 自定义发送数据包的个数（默认为4） -l 定义发送数据包的长度，单位字节 -w timeout 指定超时间隔，单位为毫秒\n返回信息\nRequest timed out（请求超时）\n对方已关机，或者网络上根本没有这个地址\n对方与自己不在同一网段内，通过路由也无法找到对方\n对方确实存在，但设置了ICMP数据包过滤（比如防火墙设置）。\n错误设置IP地址\n\n\n\n检查对方存在与否，可以用带参数 -a 的Ping命令探测，如果得到的返回信息能显示对方的NETBIOS名称，则说明对方是存在的，但是有防火墙设置，如果不显示，则很有可能是对方不在同一个网段内，或者关机。\n\nDestination host Unreachable（对方主机不存在或者没有跟对方建立连接）\n对方与自己不在同一网段内，而自己又未设置默认的路由。\n网线出了故障。\n\n\nBad IP address\n\n这个信息表示可能没有连接到DNS服务器，所以无法解析这个IP地址，也可能是IP地址不存在。\n\nNo answer\n\n无响应。这种故障说明本地系统有一条通向中心主机的路由，但却接收不到它发给该中心主机的任何信息。\n\nno rout to host\n\n网卡工作不正常。\n\nunknown host name\n\nDNS配置不正确。\n网络管理基本命令ipconfig\n&#x2F;all代表显示当前网络配置的所有信息。包括IP地址、MAC地址等\n&#x2F;release释放计算机当前获得的IP地址\n&#x2F;renew 从DHCP重新获得IP地址\n\n网络管理基本命令netstat\n-a命令将显示所有连接\n-n以数字形式显示地址和端口号\n-e命令将显示本地网卡统计信息\n\n无线局域网安全配置\n无线宽带路由器的登录\n修改无线宽带路由器的登录密码\n修改加密算法，WPA-PSK&#x2F;WPA2-PSK\nDHCP服务器设置\nSSID静默\nMAC地址过滤\nAP隔离（同一网络下用户相互隔离）\n\n","categories":["技术","CTF"],"tags":["NISP"]},{"title":"buuctf rip 1 详细wp","url":"/2021-07-19/68763f18ce7e/","content":"buuctf rip 详细wp\n【转载】\n原文地址：https://www.cnblogs.com/refrain-again/p/15001283.html\n作者：refrain-again\nTBH：感谢这位大佬！\n\nbuu上rip这道题作为pwn里面最简单的栈题，意外的发现网上很多wp因为远程环境的更新，需要维持堆栈平衡，所以原先老旧的wp在本地可以打通，但在远程却打不通，甚至很多人的blog就拿着原本可以打通的wp贴上去，自己都没有实操一遍，我相信很多人都和我一样因为这些wp对初期学习造成了不小的困扰，特别是初期自己底层知识什么都不懂的时候，看到一些甚至是在胡乱解释的wp，就不知道该如何进行后续的学习了，所以今天我通过近两天的摸索，写一篇尽量正确的wp，因为我自己水平有限，一些细节的地方可能会有错误，但大的思路一定是对的，希望能给大家提供帮助，其中用到了别人ppt里现成的图，本人仅用作学习交流，侵删。\nps：因为这里是作为本人的学习笔记，所以前面会有大量的关于栈如何工作的基础内容，不想看的可以直接跳过去看最后的wp\n1.Stack(栈)的工作原理推荐文章：\n手把手教你栈溢出从入门到放弃（上）\n手把手教你栈溢出从入门到放弃（下）\n1.1 C语言内存分布首先我们来看当一个c语言函数在执行的时候，操作系统是如何调度内存将数据存放并且完成相关函数操作的\n\n在右边的图中，我们可以大致的了解，一个c程序被编译成可执行文件执行时，他在内存中的存储情况如该图所示，这是一个内存空间，地址由底部逐渐升高，其中，最上层的kernel是操作系统的核心源码，他是操作系统完成各项功能的关键，这一部分我们暂时不做深入的研究，在早期的学习中，我们关注的是Stack(栈)，Heap(堆)，BSS(静态内存分配)。\n其中Stack(栈)用于静态分配中的存放局部变量，如局部变量t和ptr都被储存在了栈中，而BSS存储全局变量，Heap则负责存储动态分配的内存空间，如c语言中的malloc&#x2F;free分配内存时，就会分配到Heap区域。\n而Heap与Stack中间的内存空间，则是共享的一片内存空间，Heap从低地址向高地址分配空间，Stack从高地址向低地址分配空间，从而完整高效的使用了这一片内存空间。\n1.2栈中的内存分布与工作原理好了，现在我们已经大致了解了c语言的内存分布，其中heap和Bss尤其是heap会在后面更深入的学习中使用，我也会在后续的wp中更新相关知识，今天这道题只需要用的栈的相关知识，现在我们来看，当函数调用时，栈的内存空间是如何分布的。\n栈这个数据结构相信大家早就学过，首先我们需要了解一下栈中常用的3个寄存器,64位cpu对应rsp,rbp,rip三个寄存器。而32位cpu则对应esp，ebp，eip三个寄存器。然后我们了解一下栈帧的概念，一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间，rsp&#x2F;esp永远指向栈帧的栈顶，rbp&#x2F;ebp则永远指向栈帧的栈底,rip&#x2F;eip指向当前栈栈帧执行的命令。如图中文字所，栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，简单来说就是在c语言的编译过程中还有很多函数如scanf等由他人的库写好的函数我们需要进行“链接”，所以main函数并不是最栈顶的函数，当然main以上的函数我们这题不需要进行研究，你也可以当做栈顶就是main函数，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数，比如，当上面的代码main函数调用到sum函数时，便会开辟一个新的栈帧，这里需要注意的是，main函数调用sum函数完成1+2时，1和2会被逆向存储在自己的栈帧（main函数的栈帧）中，然后完成sum函数以后，回到main函数继续执行剩余操作。\n\n下面，我们来看每个栈帧的具体结构\n\n\n\n\n上面的几张图，就是创建新栈帧的过程，当然，图中所演示的是在32位cpu中的情况，也是就是寄存器与存储字长有着细微的变化，但是差别并不是很大，并且，图中的对于寄存器的各种操作都是在汇编代码中具体实现的，这里我们并不赘述太多，相信大家都对简单的汇编或多或少有些了解，图中我们可以看到两个相邻的栈帧，子函数(callee’s function state)栈帧的Return Address紧挨着父函数(caller’s…state)，而我们需要注意的是，Return Address是什么呢？在第二张图中，很明确的告诉我们，在调用子函数时，我们将汇编中父函数的下一个汇编指令的地址，放入Return Address，这样我们在子函数完成时，便可以将Return Address中的值弹入rip&#x2F;eip中，这样程序便会从上次调用的地方继续完成父函数，而这一点，也就是我们实行栈溢出的关键，我们不妨想一想，如果我们能够通过某种方式，操控Return Address的返回地址，那么是不是意味着，我们可以任意操控远程的机器指向任何指令，也就是说我们只要可以篡改Return Address指向一个危险函数的地址，理论上，我们就可以通过危险函数干任何我们想干的事情。那么我们再来看看当子函数调用结束后，是如何删除子函数的栈帧返回父函数的。\n\n\n\n这里具体需要ppt中的汇编代码辅助理解，但是汇编代码的流程图实在太多，改天有空我会发上去，大概就是esp先等于ebp，然后再pop ebp 将esp指向的地址的值赋给ebp，也就是此时的父函数的一个栈帧的栈底，于是ebp就回到了父函数的栈底，而因为pop以后esp自动加一指向Return Address（因为栈是从高地址指向低地址，所以是加一），然后再执行return指令，简单的讲就是pop eip，将esp指向的值弹入到eip中，前面我们说过Return Address里存放的是当前栈帧函数的父函数调用当前函数时下一个指令的地址，而eip又是当前要执行的指令地址的寄存器，于是这样就会回到父函数继续执行父函数的下一个指令。而此时pop以后esp再次加一，所以就回到了父函数栈帧的栈顶，ebp也在上一次pop ebp时就回到了父函数的栈底，而这样一个过程可以理论上被无数次执行，所以用栈来实现函数调用及其的方便。\n2.buuctf rip wp2.1栈溢出的原理那么上面我们学习了栈的基础知识，我们便以buu上的这一道rip来看一下最简单的栈溢出。\n如果你认真的看了上面的栈的工作流程，那么你就会发现，实际上在一个函数调用完以后就要将Return Address的值返回rip&#x2F;eip，他的值也就是父函数调用此函数时下一个指令的地址，而rip&#x2F;eip将执行这一指令，并继续完成父函数，那么我们只要设法将Return Address的值改变到一个危险函数的地址，我们就可以通过这个危险函数获得系统的控制权。\n那么我们怎么样才可以改变Return Address的地址呢？我们知道子函数在调用时，如果子函数中有局部变量，那么他将被存储到子函数的栈帧中，以这道rip为例，下载rip给我们的elf文件，将其拖入ida pro,按f5将其反编译成c语言伪代码\n\n我们可以看到，主要有一个main函数，还有一个fun函数\n\n这个elf可执行文件，补充一下，elf是linux下的可执行文件，相当于windows中的exe文件，他的反编译文件是由一个main函数和一个fun函数组成的，当我们用虚拟机在unbantu中正常执行他时，他只会执行main函数，因为fun函数并没有被调用，而fun函数也就是我们上面说的危险函数，system是c语言下的一个可以执行shell命令的函数，目前你可以简单理解为，执行了这个危险函数，我们就拿到了远端服务器的shell，也就是相当于在windows下以管理员身份开启cmd，那么我们就可以通过一系列后续指令控制远端服务器，但在ctf中，我们只需要拿到shell以后获得flag就算成功。\n那么，回过头来，我们再来看这个main函数，我们刚刚说过，函数的局部变量会存放在他的栈中，那么在main函数中，他char了一个s，也就是在main函数的栈帧中，划分了一个15字节的存储空间，我们在unbantu中file一下这个文件:\n\n我们可以发现，这是一个64位的elf文件，也就是说，每个存储单元是8个字节（如果不知道的去学学计组），简单的讲就是一个字节是8位，因为他是64位，所以一个存储单元就是8个字节，同理32位就是4个字节。\n然后我们可以先通过checksec查看保护机制(不知道没关系，以后才会用到)，因为这题是任何保护都没有打开的，所以我们可以实现最简单的栈溢出\n\n接回上面的话题，我们开辟了一个15个字节的存储空间，那么在栈帧中系统就会给我们分配一个15个字节的存储空间，那么我们再注意一下我们是如何写入这15个字节的数据的，没错，我们使用的是gets函数，相信大家在c语言中都学习过这个函数，我们在c语言的学习中知道，这个函数时可以无限制输入数据的，但当时，我们并没有意识到gets函数时危险的，现在，我们通过前面栈的工作原理的学习，我们发现，我们明明只分配了15个字节的内存空间，但是我们可以输入无数个字节，那么这会导致什么问题呢？请大家自己回过头再去看一看前面栈的结构图\n\n此时，我们的s就在Local Variables，把他想象成一个水桶，我们如果可以一直往里面不停的倒水，那么这个水桶的水满了，是不是就可以溢出到另一个水桶Caller’s ebp里？再继续倒水，那是不是就溢出到了Return Address里，那么原本不属于Return Address的水由于其他水桶的溢出而进入了Return Address，也就是改变了Return Address的值。这个时候，我们前面所说的，通过改变Return Address的值来完成对危险函数的调用，是不是就可以实现了？\n那么，最后的问题就是，我们该怎么确定溢出多少水呢？这个也是很简单的问题，Local Variables也就是char s[]划定了15个字节的内存空间,那么我们需要知道这个内存空间在栈中的位置，就可以知道需要多少个字节才能到达\n我们打开 ida pro ，作为最简单的栈题，我们在 ida pro 中的 main 函数在创建空间s时已经清晰的告诉了我们距离 rbp 的距离是 Fh ,这是16进制也就是15个字节，当然，这只是理想的情况，在复杂一些的情况中，开辟的内存地址显然不会像这题一样紧挨着上一个 rbp ，甚至有时出题人会故意在 ida 的静态调试中告诉你错误的地址，这个时候你需要用 pwndbg 进行动态调试，这题通过动态调试也可以发现，二者的地址是一样的。所以我们首先需要输入15个字节到达 rbp 的位置。\n\n然后 Caller’s ebp 中存储的是上一个函数的 ebp 的值，当然，我们这个图的例子是32位的系统，而我们是64位的系统，所以 ebp 应该是 rbp 才对，是8个字节，那么我们还需要8个自己的数据把 Caller’s rbp 的数据填满（当然在本题中应该是 rbp ，因为是64位的系统)，这样我们就填满了前两个水桶，你可以理解为水即将溢出进入Return Address了，所以接下来我们输入的值，将溢出进入 Return Address ，也就是说，这时我们还需要输入危险函数，也就是fun函数的地址，查看一下ida pro发现fun函数的地址是 0x401186，于是只需要再输入 0x401186这一地址值，该地址就被我们送到了Return Address，当这个函数调用结束后就会被送到rip，执行fun函数，从而控制shell。\n2.2 expfrom pwn import *p = remote(&quot;node4.buuoj.cn&quot;,27296)payload=b&#x27;A&#x27;*15+b&#x27;B&#x27;*8+p64(0x401186+1)p.sendline(payload)p.interactive()\n\n作为最简单的 pwn 题，当然是最简单的 exp ，只要知道原理几行代码就可以搞定，我们发送了15个A用来填充s，再发送8个字节用来填充b，将地址打包为 p64 位的数据一起发送，就可以完成栈溢出，至于最后为什么要 +1 ，我们可以发现，不加一我们在本地可以打通，但是却打不通远程，这也是我开头说的，和以前 payload 不一样的地方，原理我们是没有错的，这里 +1 是为了堆栈平衡，详细可以看大佬的博客http://blog.eonew.cn/archives/958\n因为现在已经是凌晨三点，再加上我对这里还有点模糊，也就不废话了，总之我们学的知识是没有错的，这里需要堆栈平衡应该也是远程 buu 的服务器更新以后 linux 环境发生了变化，加了新的要求，而不是因为其他原因，改成15个字节直接发送地址不加一也可以完成交互，但是并不是因为不需要覆盖 rbp ，而是满足堆栈平衡的一种另外一种方式，后续如果学明白了会更新。\n总结虽然是最简单的 pwn 题，exp只有短短几行代码，但是想要完全掌握背后的知识，却不是那么简单，哪怕是已经学了两天，今天在复盘栈的工作原理的时候，发现自己也会很多不熟练的地方，所以只有将基础打牢，能在脑海中自动演示栈的工作原理，才能完成后续更加复杂的学习，这也是二进制安全难入门的地方之一，在此与各位师傅共勉。\n这里面用的图，全都是某个安全团队大师傅讲pwn入门公开课用的图，因为一些问题不太方便公开，如果有人需要完整ppt的话，如果有疑问或者想要ppt再或者想要一起学习的师傅可以中私信联系我。\n其实大家看完这题以后一定和我刚学完一样会有一个疑惑，那就是实际情况中，怎么可能会有人傻到将程序设置一个后门函数呢？实际情况中确实是不会有人这么傻的，因此这只是一个最简单的栈溢出题，意在让你了解栈工作的基本原理，属于 level 0，在后续更深入的学习中，我们会遇到更符合实际情况的题目，也会见招拆招，构造出更复杂的 payload 。\n那么就是这样，写完已经凌晨三点了，还是那句话，很简单的题目，但很多厉害的大佬都懒得详细写这些，可能我第一次写博客写的也不是很好，但希望对各位能有所帮助，就是这样，睡觉了。\n","categories":["技术","CTF"],"tags":["CTF","PWN"]},{"title":"Ciscn 2021 wp","url":"/2021-06-28/c5e2eec113ee/","content":"队伍名称：打工魂\n队伍成员：向政昌、钟希鸣、郭英楠、田冰航\nCryptorsa拿到out和chall.py，一看发现是三种rsa攻击方式\n第一种是e&#x3D;3的小明文攻击，直接gmpy2.iroot（m， 3）拿到第一个text\n第二种是共模攻击，直接网上搜到如下代码轻松拿到第二个text\n\n第三题是已知p高位，在网上找了一段如下的sage代码直接拿到第三个text\n\n最后将三个text连起来，用python进行MD5加密得到flag\n\nMISCrobot使用wiresharp打开流量包，发现存三元组value[A,B,C]，推测根据此可以绘制出flag，于是我们就有两种思路：\n①用python写个脚本，把流量包里面的value中的三元组全部读取出来，并根据excel进行绘图。\n②用abb robot studio打开Robot.rspag文件，导入之后是一个机械臂模型根据文件提示安装hardware\n安装后打开Robot Control.exe并将其连接至hardware，启动绘图，最终得到字符串：easy_robo_xx，进行md5加密，获得最终flag。\nWEB1easy_SQLbp抓取数据包\nuname=11&#x27;) AND extractvalue(1,concat(0x7e,(select * from (select * from flag join flag b using(id,no))c),0x7e))— fAZr&amp;passwd=admin&amp;Submit=%E7%99%BB%E5%BD%95\n\n得出来个列名\n\n\n制作1.txt保存抓包数据，将其放置在sqlmap.py文件路径下\n执行sqlmap命令\npython sqlmap.py -r 1.txt -p uname —tech=B —dump -C 1c3e739e-00c7-4a7b-8b42-2d872a49714e -T flag\n\nWEB2easy_sourcepayload：/index.php?rc=ReflectionMethod&amp;amp;ra=User&amp;amp;rb=q&amp;amp;rd=getDocComment\n\n\n我们学长的wp","categories":["技术","CTF"],"tags":["CTF"]},{"title":"pwn入门的一些学习资料","url":"/2021-06-28/2a848b524af4/","content":"\n原文链接：https://www.jianshu.com/p/7133863623e6\n\n总结记录一下pwn入门的一些学习资料\npwn入门学习的网站：CTF Wiki\n必备技能：\n汇编语言要搞pwn首先要懂汇编吧，毕竟是搞二进制的 建议看王爽写的那本汇编语言，将书本的实验做一遍，然后再了解一下AT&amp;T和intel两种汇编代码风格有什么不同 可以看下这篇博客intel汇编 和 AT&amp;T汇编 的区别\n\n编程语言（C语言和python）C语言这门语言必须要会吧，题目大部分是用C语言写的，而且很多那些知识都要读libc的源代码，不懂C，读libc源码时就会很痛苦，虽然懂也会很痛苦 要会python吧，毕竟exp用python写的，CTF中pwn主要是用pwntools这个python库来写利用脚本,要熟悉这个库 学习python的话上菜鸟教程学吧 pwntools库的话看下面 这个库的document pwntools document 还有常见的用法 pwntools 的常见用法\n\n计算机组成与原理玩pwn，入门是栈溢出，要玩栈溢出，栈的构造要了解吧，函数的调用约定要了解吧，函数参数的在栈上的分布要知道吧，然后balbala很多知识点要刷，建议读下《深入理解计算机系统》这本书 还有（《程序员的自我修养》这个选读） 下面举下经常用到的知识 函数调用栈： C语言函数调用栈(一) C语言函数调用栈(二)\n\n\nelf的文件结构：了解下就好了 看程序员的自我修养\nPLT和GOT：Linux中的GOT和PLT到底是个啥？\n系统的防护机制了解一波：系统防护机制\n\nIDA 和gdb的常见工具的操作\n\nlinux的常见操作\n\n\npwn入门视频：（可以关注一下B栈上的一个up主 (君莫笑hhhhhhhh) 下面是他的一些视频）\n\n环境搭建 （环境的搭建 建议初学者用peda peda的安装我另一篇博客有讲）\n\n逆向基础速成\n\npwn入门系列-1-pwn基础知识\n\npwn入门系列-2-一个简单的例子\n\n\n可以看下国外的 liveOverflow系列的教程：LiveOverflow]-binary hacking 台湾 Angelboy的教学视频 强烈推荐：视频地址\npwn入门博客\n手把手教你栈溢出从入门到放弃（上）\n\n手把手教你栈溢出从入门到放弃（下）\n\n一步一步学ROP之linux_x86篇 – 蒸米\n\n一步一步学ROP之linux_x64篇 – 蒸米\n\n一步一步学ROP之gadgets和2free篇 – 蒸米\n\n\n刷题的网站 浙大的jarvisoj平台 国外的pwnable.kr 台湾的pwnable.tw i春秋平台上的题目 还有一个国外的Scoreboard 不过需要科学上网\n先大概写这么多吧，以后再补充\n","categories":["技术","CTF"],"tags":["CTF","PWN"]},{"title":"监控平台搭建(2)-环境搭建","url":"/2024-08-04/e97aae35e0da/","content":"监控平台搭建(2)-环境搭建介绍记录搭建的命令，只提供基本的注释\n系统：ubuntu-24.04-amd64\n镜像：ubuntu-24.04-live-server-amd64.iso\n初步搭建查看ubuntu时区是否正确，否则发送告警模板时时间对不上\n# 查看时区date -R\n\n参考文章：修改时区\nPrometheuscd ~export VERSION=2.53.1curl -LO https://github.com/prometheus/prometheus/releases/download/v2.53.1/prometheus-$VERSION.linux-amd64.tar.gztar -xzf prometheus-$&#123;VERSION&#125;.linux-amd64.tar.gzsudo mv prometheus-$&#123;VERSION&#125;.linux-amd64/ /usr/local/prometheuscd /usr/local/prometheusmkdir -p datasudo chmod +x prom*sudo cp -rp promtool /usr/bin/sudo vim /usr/lib/systemd/system/prometheus.service\n\n/usr/lib/systemd/system/prometheus.service如下：\n[Unit]Description=Prometheus server daemonDocumentation=https://prometheus.io/After=network.target[Service]Type=simpleExecStart=/usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.yml --storage.tsdb.path=/usr/local/prometheus/data --web.enable-lifecycleRestart=on-failure[Install]WantedBy=multi-user.target\n\nsudo systemctl daemon-reloadsudo systemctl start prometheussudo systemctl status prometheussudo systemctl enable prometheus\n\nlocalhost:9090验证\n\nnode exportercd ~curl -OL https://github.com/prometheus/node_exporter/releases/download/v1.8.2/node_exporter-1.8.2.linux-amd64.tar.gztar -xzf node_exporter-1.8.2.linux-amd64.tar.gzsudo mv node_exporter-1.8.2.linux-amd64/ /usr/local/node_exportersudo vim /usr/lib/systemd/system/node_exporter.service\n\n/usr/lib/systemd/system/node_exporter.service配置文件：\n[Unit]Description=node_exporter[Service]ExecStart=/usr/local/node_exporter/node_exporter --web.listen-address=:9100 --collector.systemd --collector.systemd.unit-whitelist=&quot;(ssh|docker|rsyslog|redis-server).service&quot; --collector.textfile.directory=/usr/local/node_exporter/textfile.collectedRestart=on-failure[Install]WantedBy=multi-user.target\n\nsudo systemctl daemon-reloadsudo systemctl start node_exportersudo systemctl status node_exportersudo systemctl enable node_exporter\n\n将node exporter添加到Prometheus中：\nsudo vim /usr/local/prometheus/prometheus.yml......  - job_name: &quot;node_exporter&quot;    static_configs:      - targets: [&quot;localhost:9100&quot;]# 刷新Prometheus配置curl -X POST http://localhost:9090/-/reload\n\n访问localhost:9100\n\n在Prometheus中输入up，查看服务是否正确连接\nGrafanacd ~sudo apt-get upgradesudo apt-get install -y adduser libfontconfig1 muslwget https://dl.grafana.com/enterprise/release/grafana-enterprise_11.1.0_amd64.debsudo dpkg -i grafana-enterprise_11.1.0_amd64.debsudo systemctl daemon-reloadsudo systemctl start grafana-serversudo systemctl status grafana-serversudo systemctl enable grafana-server\n\n\n访问localhost:3000\n账号密码均为admin\n导入Prometheus数据源\n导入模板12633，查看系统状况\n\n\nMySQLsudo apt updatesudo apt install mysql-serversudo systemctl daemon-reloadsudo systemctl start mysqlsudo systemctl status mysqlsudo systemctl enable mysql# 查看初始的账号密码sudo cat /etc/mysql/debian.cnfmysql -u&lt;账号&gt; -p# 修改root密码(mysql8.0)ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;FLUSH PRIVILEGES;# 重新使用root登录mysql -uroot -p# 查看用户目前的权限use mysql;select Host,User from user where user=&#x27;root&#x27;;# 如果要将root修改为外网可访问，之后的localhost换为%[该SQL根据情况可选] update user set Host=&#x27;%&#x27; where User =&#x27;root&#x27;;# 授权【前面改为%的话就要跟着变】GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;# 刷新FLUSH PRIVILEGES;# 创建新账号# 说明：为用户设置最大连接限制，以避免在重负载下监控抓取使服务器过载。CREATE USER &#x27;exporter&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;prometheus&#x27; WITH MAX_USER_CONNECTIONS 3;GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#x27;exporter&#x27;@&#x27;%&#x27;;flush privileges;\n\nmysqld exportercd ~curl -LO https://github.com/prometheus/mysqld_exporter/releases/download/v0.15.1/mysqld_exporter-0.15.1.linux-amd64.tar.gztar -xzf mysqld_exporter-0.15.1.linux-amd64.tar.gzsudo mv mysqld_exporter-0.15.1.linux-amd64/ /usr/local/mysqld_exporter/cd /usr/local/mysqld_exportercat &gt; .my.cnf &lt;&lt;EOF[client]user=exporterpassword=prometheusEOF# 启动 默认端口9104./mysqld_exporter --config.my-cnf=.my.cnf# 使用systemd方式启动sudo vim /usr/lib/systemd/system/mysqld_exporter.service[Unit]Description=Prometheus[Service]ExecStart=/usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnfRestart=on-failure[Install]WantedBy=multi-user.targetsudo systemctl daemon-reloadsudo systemctl start mysqld_exportersudo systemctl enable mysqld_exportersudo systemctl status mysqld_exporter\n\n配置到Prometheus中\nsudo vim /usr/local/prometheus/prometheus.yml......  - job_name: &#x27;mysqld_exporter&#x27;    static_configs:    - targets: [&#x27;localhost:9104&#x27;]      labels:        app: mysqld_exporter        node: node1        role: mysqld_exporter# 刷新Prometheus配置curl -X POST http://localhost:9090/-/reload\n\nGrafana导入模板7362\n\nGrafana配置根据需要 导入相关模板，监控Springboot应用可以使用：21319 模板\n模板虽然好用 但大多情况无法满足我们的具体需求，尤其是具体应用，需要根据埋点上报的具体指标 灵活改动，并且模板中的信息堆放比较杂，我们需要把它们合并到一块方便查看\n关于Grafana的具体配置会在 [4. 可视化](.&#x2F;4. 可视化.md) 详细介绍\n告警AlertManagercurl -LO https://github.com/prometheus/alertmanager/releases/download/v0.27.0/alertmanager-0.27.0.linux-amd64.tar.gztar -xzf alertmanager-0.27.0.linux-amd64.tar.gzsudo mv alertmanager-0.27.0.linux-amd64/ /usr/local/alertmanager/\n\n下面是构建集群，Gossip协议\n# 主机1./alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.129:8101&quot;# 主机2./alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.128:8101&quot; --cluster.peer=192.168.227.129:8101\n\n检查一下运行是否正常\n\n没问题后设置自启动\nP1：\nsudo vim /usr/lib/systemd/system/alertmanager.service[Unit]Description=AlertManagerAfter=network.target[Service]ExecStart=/usr/local/alert_manager/alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.129:8101&quot; --config.file=alertmanager.yml --log.level=debug --log.format=jsonRestart=on-failure[Install]WantedBy=multi-user.targetsudo systemctl daemon-reloadsudo systemctl start alertmanagersudo systemctl enable alertmanagersudo systemctl status alertmanager\n\nP2：\nsudo vim /usr/lib/systemd/system/alertmanager.service[Unit]Description=AlertManagerAfter=network.target[Service]ExecStart=/usr/local/alert_manager/alertmanager --web.listen-address=&quot;:9093&quot; --cluster.listen-address=&quot;192.168.227.128:8101&quot; --cluster.peer=192.168.227.129:8101  --config.file=alertmanager.yml --log.level=debug --log.format=jsonRestart=on-failure[Install]WantedBy=multi-user.targetsudo systemctl daemon-reloadsudo systemctl start alertmanagersudo systemctl enable alertmanagersudo systemctl status alertmanager\n\n具体告警配置：[5. 告警配置](.&#x2F;5. 告警配置.md)\nmtail监控日志\n官方地址\n官方文档\n\n具体日志告警配置：不出意外的话，会在“监控平台搭建(6)-日志告警”文章中\n","categories":["技术","Prometheus"],"tags":["Prometheus","监控","后端"]},{"title":"监控平台搭建(3)-Springboot埋点","url":"/2024-08-04/739cd10a2ee5/","content":"监控平台搭建(3)-Springboot埋点采集需求Springboot应用需要监控的场景：\n\nJVM的具体情况\n接口的TP90、最大响应时长、平均响应时长、QPS\n监控接口的进阶要求\n根据入参进行分类\n内部调用其他接口（如外部数据源），监控指标同上\n接口http响应码，内部业务code码，根据code统计失败率\n\n\n项目出现问题，发送自定义指标，配置告警，帮助快速发现问题\n\n需求分析需求一：Springboot Actuator可以直接监控JVM信息\n需求四：可以通过打印错误日志 -&gt; mtail监控 -&gt; 监控到指定日志，发送Metrics -&gt; 告警 来实现，所以暂时不讨论\n所以本篇文章主要讨论 需求二、需求三 的实现\nMetrics类型选择有四种数据类型：Counter(单增)，Gauge(可增可减)，Histogram(桶&#x2F;直方图)，Summary(摘要)\n\nSummary(摘要) 是 客户端 直接计算出 用户指定的分位点，然后上报Prometheus\nHistogram(桶&#x2F;直方图) 是 Prometheus 根据 桶分布情况 估算 分位点\nHistogram计算过程\nHistogram分位点计算逻辑-源码\n\n\n\n数据上报：\n\nHistogram类型上报的数据：桶、max、count、sum\nSummary类型上报的数据：分位点、max、count、sum\n\nHistogram VS Summary\n\nHistogram\n客户端性能消耗小，服务端查询分位数时消耗大。\n可以在查询期间自由计算各种不同的分位数。\n分位数的精度无法保证，其精确度受桶的配置、数据分布、数据量大小情况影响。\n可聚合，可以计算全局分位数。\n客户端兼容性好。\n\n\nSummary\n客户端性能消耗大（因为分位数计算发生在客户端），服务端查询分位数时消耗小。\n只能查询客户端上报的哪些分位数。\n分位数的精度可以得到保证，精度会影响客户端的消耗。\n不可聚合，无法计算全局分位数（因此不支持多实例，平行扩展的 http 服务）。\n客户端兼容性不好。\n\n\n\n大多数场景使用 Histogram 更为灵活。\n现在来分析下需求二、三：\n如果我们只使用Histogram类型统计接口\n\n通过max可以统计最大响应时间\nPrometheus可以根据桶估算分位点\n根据区间内的sum和count可以计算平均响应时长\n\n综上，对于我们的需求，只采用Histogram即可解决\n埋点实现下面会从头介绍我个人的探索过程，省流：方案一不可用，不感兴趣可以直接从方案二开始看起\n\n留着 方案一 是因为确实写了一篇文档，也打算这么来搞，但最终发现不可行，也无法通过其它方式补救\n\n方案一 @Timed我们可以使用springboot actuator进行监控，而它底层按照micrometer的规范实行，导入micrometer-registry-prometheus即可将数据转为Prometheus的Metrics格式进行上报\n同时，我们可以使用micrometer提供的@Timed进行监控埋点，它是通过AOP来实现的，所以需要导入spring-boot-starter-aop，同时也记得开启@EnableAspectJAutoProxy\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;\n\n接着添加相关配置\nmanagement:  server:  \t# 监控指标暴漏在8092端口    port: 8092  endpoints:    web:      exposure:        # 允许访问所有监控端点        include: &quot;*&quot;  metrics:    tags:      # 添加标签 应用名称      application: $&#123;spring.application.name&#125;\n\n启动后，查看localhost:8092/actuator即可查看所有的监控指标，而localhost:8092/actuator/prometheus则是要上报Prometheus的指标\n\n下面是关于@Timed的使用：\npackage io.micrometer.core.annotation;import java.lang.annotation.*;@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD&#125;)@Repeatable(TimedSet.class)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface Timed &#123;    // 指标名称    String value() default &quot;&quot;;\t// 自己想要添加的额外标签    String[] extraTags() default &#123;&#125;;\t// A long task timer is used to track the total duration of all in-flight long-running tasks and the number of such tasks.    // 长任务计时器用于跟踪所有正在进行的长时间运行任务的总持续时间以及此类任务的数量    boolean longTask() default false;\t// 摘要类型时，要计算的分位数    double[] percentiles() default &#123;&#125;;\t// 是否为直方图类型    boolean histogram() default false;\t// 指标的注释    String description() default &quot;&quot;;&#125;\n\n在使用前我们需要将包内提供的TimeAspect创建为bean，详细参考：Timer（一）之@Timed初探\n@Configurationpublic class springConfig &#123;    @Bean    public TimedAspect timedAspect(MeterRegistry registry) &#123;        return new TimedAspect(registry, tagsBasedOnJoinPoint);    &#125;&#125;\n\n举个简单的例子\n@Timed(value = &quot;apple.timed1&quot; ,description = &quot;测试timed注解&quot;, histogram = true, extraTags = &#123;&quot;tag1&quot;,&quot;tbg&quot;,&quot;tag2&quot;,&quot;hg&quot;&#125;)\n\n名称默认会以.进行分割然后转换，到Prometheus后，为apple_timed1\n\n上报的指标包括bucket、count、sum、max四种\n但是只有这些指标，肯定没有办法满足需求，例如：\n\n如何动态的指定标签，或者说如何将接口的入参作为标签\n如何将header中的字段添加到标签中\n\n首先看源码上的注释：\nAspectJ aspect for intercepting types or methods annotated with @Timed. The aspect supports programmatic customizations through constructor-injectable custom logic.You might want to add tags programmatically to the Timer. In this case, the tags provider function (Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt;) can help. It receives a ProceedingJoinPoint and returns the Tags that will be attached to the Timer.\n\nprivate final Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint;...    public TimedAspect(MeterRegistry registry, Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint) &#123;        this(registry, tagsBasedOnJoinPoint, DONT_SKIP_ANYTHING);&#125;\n\n通过tagsBasedOnJoinPoint，我们可以自行添加标签，入参为ProceedingJoinPoint，我们可以轻松的获得方法的具体信息，下面给个例子\n@Configurationpublic class springConfig &#123;    @Bean    public TimedAspect timedAspect(MeterRegistry registry) &#123;        return new TimedAspect(registry, tagsBasedOnJoinPoint);    &#125;    // 定义一个函数，根据ProceedingJoinPoint生成相应的Tags    Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint = joinPoint -&gt; &#123;        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        // 添加方法名的Tag        tags.add(Tag.of(&quot;method&quot;, &quot;i&#x27;m method&quot;));        // 获取方法签名        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();        String[] parameterNames = methodSignature.getParameterNames();        Object[] args = joinPoint.getArgs();        // 查找参数名为inter的参数 并添加相应的Tag        for (int i = 0; i &lt; parameterNames.length; i++) &#123;            if (&quot;inter&quot;.equals(parameterNames[i])) &#123;                tags.add(Tag.of(&quot;inter&quot;, args[i].toString()));                break;            &#125;        &#125;        return tags;    &#125;;&#125;\n\n\n可以看到，标签成功打上去了，inter中是我们传入的参数\n至于header，可以从入参中取HttpServletRequest类型，从中取数据\n问题但是后面发现，这种方式无法获取到方法返回值，那么就无法获取返回的业务code或者http状态码等等，无法根据返回结果打标签，但是这种场景又很必须，例如根据业务code统计失败率，出现某些业务code后进行告警等等\n该部分源码如下：\n\n过程如下：执行原方法 -&gt; 调用我们自定义的tagsBasedOnJoinPoint.apply方法 -&gt;上报指标\n因为自定义方法中含有ProceedingJoinPoint连接点，还是有一定操作空间，所以现在的目标就变成了：对于一个已执行完毕的方法，通过反射等途径，获取之前的执行结果并使用\n当时考虑了下面的方法：\n\n方法执行完成后 再通过一个切面(如@AfterReturning)来获取返回值\n将返回值记录，保证之后可以通过连接点取到返回值\n如何记录：通过反射，在方法中添加参数\n\n实现时发现，反射获取到参数后为数组类型，只能修改，无法添加，所以引申出一种自暴自弃式做法：\n所有要监控的方法多一个result参数，统一写到这个里面【这个方案一旦交上去，估计第二天就从公司毕业了，所以就废弃掉了】\n方案二 自行实现AOP分析虽说是自行实现，但是可以注意到，TimedAspect是以Bean的形式注入的，我们只要自行实现一个@Timed的切面即可，并且TimedAspect中大部分实现可以参考，我们只需要在result小修一下。\n既然要重新实现，那就实现一个更为完善的吧，对于自定义标签，我们可以分为两类：\n\nBefore：根据入参打标签\nAfter：根据返回值打标签\n\n先来看Function&lt;ProceedingJoinPoint, Iterable&lt;Tag&gt;&gt; tagsBasedOnJoinPoint，它虽然能用但却不好用，需要把所有要监控的方法的入参添加标签校验都放到这里，很容易出现彼此间的干扰，可读性较差，且后续维护会比较困难，这种类型已经无法满足我们的需求，所以直接删除相关代码\n这里考虑使用策略模式，入参处理方式有各自的策略，出参处理方式有各自的策略，监控一个方法时通过注解配置它的入参出参策略标识。策略顶层定义一个抽象类，编写经常被复用的方法，权限设置为protected，对外提供 public List&lt;Tag&gt; getTags供获取标签结果，所有的策略注入到策略工厂中\n实现既然要在注解中定义标识，那原本的@Timed就不能用了，我们可以重新定义一个\nimport java.lang.annotation.*;@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface CustomTimed &#123;    // 指标名称    String value();    // 指标描述    String description() default &quot;&quot;;    // 额外标签    String[] extraTags() default &#123;&#125;;    // 摘要类型时，需要计算的分位点    double[] percentiles() default &#123;&#125;;    // 是否为直方图类型    boolean histogram() default false;    // 额外处理标识，主要处理获取结果后    String afterKey() default &quot;&quot;;    // 额外处理标识，主要处理入参    String beforeKey() default &quot;&quot;;&#125;\n\n下面我们来编写Before策略的抽象类，注释比较详细就不过多解释了\npublic abstract class MonitorBeforeStrategy &#123;    protected abstract List&lt;Tag&gt; applyStrategy(ProceedingJoinPoint pjp);    protected String[] parameterNames;    protected Object[] args;    public List&lt;Tag&gt; getTags(ProceedingJoinPoint pjp) &#123;        parameterParsing(pjp);        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        tags.add(Tag.of(&quot;class&quot;, pjp.getStaticPart().getSignature().getDeclaringTypeName()));        tags.add(Tag.of(&quot;method&quot;, pjp.getStaticPart().getSignature().getName()));        List&lt;Tag&gt; customTags = applyStrategy(pjp);        tags.addAll(customTags);        return tags;    &#125;    /**     * 记录 http 相关标签     * 需要监控方法中携带 HttpServletRequest 入参     * 如果需要记录Header中的内容，可重写该方法     */    protected List&lt;Tag&gt; httpTags(ProceedingJoinPoint pjp) &#123;        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        HttpServletRequest request = null;        for (int i = 0; i &lt; parameterNames.length; i++) &#123;            if (args[i] instanceof HttpServletRequest) &#123;                request = (HttpServletRequest) args[i];                break;            &#125;        &#125;        if (request == null) &#123;            return tags;        &#125;//        String userAgent = request.getHeader(&quot;xxx&quot;);        tags.add(Tag.of(&quot;requestMethod&quot;, request.getMethod()));        tags.add(Tag.of(&quot;uri&quot;, request.getRequestURI()));        return tags;    &#125;    /**     * @param pjp 连接点对象，提供对目标方法的访问     * @function 解析方法参数 获取参数名称和对应的参数值     */    protected void parameterParsing(ProceedingJoinPoint pjp) &#123;        MethodSignature methodSignature = (MethodSignature) pjp.getSignature();        this.parameterNames = methodSignature.getParameterNames();        this.args = pjp.getArgs();    &#125;    /**     * @param names 需要匹配的参数名称数组     * @function 获取返回与参数名称匹配的对象数组     * @returns 与入参顺序对应的对象组     */    protected Object[] getTargetArgs(String... names) &#123;        Object[] targetArgs = new Object[names.length];        for (int j = 0; j &lt; names.length; j++) &#123;            for (int i = 0; i &lt; parameterNames.length; i++) &#123;                if (names[j].equals(parameterNames[i])) &#123;                    // Object索引与names相对应，可省略 查询不到时赋 Null 操作                    targetArgs[j] = args[i];                    break;                &#125;            &#125;        &#125;        return targetArgs;    &#125;&#125;\n\n先来看一个Before策略类的具体实现，可以发现现在添加标签就容易一些了\npublic class HttpMonitorBeforeStrategy extends MonitorBeforeStrategy &#123;    // TODO 此处 interface_code 算是例子，按照实际情况更改    // 要处理的入参参数名    private final String INTERFACE_CODE = &quot;interfaceCode&quot;;    // 该参数上报时的标签名    private final String INTERFACE_CODE_TAG = &quot;interface_code&quot;;    @Override    protected List&lt;Tag&gt; applyStrategy(ProceedingJoinPoint pjp) &#123;        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        Object[] targetArgs = getTargetArgs(INTERFACE_CODE);        if (targetArgs[0] != null &amp;&amp; !targetArgs[0].toString().isEmpty()) &#123;            tags.add(Tag.of(INTERFACE_CODE_TAG, targetArgs[0].toString()));        &#125;        // URI、requestMethod标签 封装至 protected List&lt;Tag&gt; httpTags(ProceedingJoinPoint pjp) 中，根据业务情况自定调用        tags.addAll(httpTags(pjp));        return tags;    &#125;&#125;\n\n接着是After的抽象类，这里需要注意，只写个泛型肯定不行，会存在泛型擦除的情况，导致我们取出result中的参数较为困难，所以需要传递实际类型\n@Slf4jpublic abstract class MonitorAfterStrategy&lt;R&gt; &#123;    protected List&lt;Tag&gt; tags = null;    protected R result;    // 泛型擦除，这里需要传递实际类型    private final Class&lt;R&gt; resultType;    public MonitorAfterStrategy(Class&lt;R&gt; resultType) &#123;        this.resultType = resultType;    &#125;    protected abstract List&lt;Tag&gt; applyStrategy(ProceedingJoinPoint pjp);    public List&lt;Tag&gt; getTags(ProceedingJoinPoint pjp, Object result) &#123;        if (result == null) &#123;            return tags;        &#125;        if (resultType.isInstance(result)) &#123;            this.result = resultType.cast(result);            this.tags = applyStrategy(pjp);        &#125; else &#123;            log.error(&quot;result is not of type &#123;&#125;, result: &#123;&#125;&quot;, this.result.getClass(), result);        &#125;        return tags;    &#125;&#125;\n\n具体实现中我们来举两个例子，先是常规简单的，可以看到现在从结果中取数据极为方便，直接取就可以\npublic class RespBodyVoMonitorAfterStrategy extends MonitorAfterStrategy&lt;RespBodyVo&gt; &#123;    private final String CODE_TAG = &quot;code&quot;;    public RespBodyVoMonitorAfterStrategy() &#123;        super(RespBodyVo.class);    &#125;    @Override    protected List&lt;Tag&gt; applyStrategy(ProceedingJoinPoint pjp) &#123;        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        // result不为null已经判断过了，这里直接处理即可        String code = result.getCode();        tags.add(Tag.of(CODE_TAG, code));        return tags;    &#125;&#125;\n\n下面是在外面包裹了一层，并且内部使用了泛型(ResponseEntity&lt;RespBodyVo&gt;)，在上报类型时复杂一些，首先上报一般的class，然后强转指定对应的泛型即可\n...import org.springframework.http.ResponseEntity;@Slf4jpublic class WrappedRespBodyVoMonitorAfterStrategy extends MonitorAfterStrategy&lt;ResponseEntity&lt;RespBodyVo&gt;&gt; &#123;    private final String STATUS_CODE_TAG = &quot;status_code&quot;;    private final String BUSINESS_CODE_TAG = &quot;business_code&quot;;    public WrappedRespBodyVoMonitorAfterStrategy() &#123;        super((Class&lt;ResponseEntity&lt;RespBodyVo&gt;&gt;) (Class&lt;?&gt;) ResponseEntity.class);    &#125;    @Override    protected List&lt;Tag&gt; applyStrategy(ProceedingJoinPoint pjp) &#123;        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();        tags.add(Tag.of(STATUS_CODE_TAG, String.valueOf(result.getStatusCode().value())));        RespBodyVo body = result.getBody();        if (body == null) &#123;            return tags;        &#125;        String code = body.getCode();        tags.add(Tag.of(BUSINESS_CODE_TAG, code));        return tags;    &#125;&#125;\n\n接着是抽象策略工厂类\npublic class MonitorStrategyFactory &#123;    private Map&lt;String, Map&lt;String, Object&gt;&gt; beforeStrategyMap;    private Map&lt;String, Map&lt;String, Object&gt;&gt; afterStrategyMap;    public MonitorAfterStrategy getAfterStrategy(String strategy) &#123;        return (MonitorAfterStrategy) afterStrategyMap.get(strategy);    &#125;    public MonitorBeforeStrategy getBeforeStrategy(String strategy) &#123;        return (MonitorBeforeStrategy) beforeStrategyMap.get(strategy);    &#125;    public void setBeforeStrategyMap(Map beforeStrategyMap) &#123;        this.beforeStrategyMap = beforeStrategyMap;    &#125;    public void setAfterStrategyMap(Map afterStrategyMap) &#123;        this.afterStrategyMap = afterStrategyMap;    &#125;&#125;\n\n最后就是自己定义的TimedAspect了\n@Aspect@Component@Slf4jpublic class CustomTimedAspect &#123;    // 所监控方法未出现异常时标签的赋值    public static final String DEFAULT_EXCEPTION_TAG_VALUE = &quot;none&quot;;    // 记录监控方法异常的标签    public static final String EXCEPTION_TAG = &quot;exception&quot;;    // 监控策略工厂    private final MonitorStrategyFactory monitorStrategyFactory;    // 指标仓库，自动装配    private final MeterRegistry registry;    public CustomTimedAspect(MeterRegistry registry, MonitorStrategyFactory monitorStrategyFactory) throws IOException &#123;        this.registry = registry;        this.monitorStrategyFactory = monitorStrategyFactory;    &#125;    @Around(&quot;@within(top.tbghg.demo.monitor.aop.CustomTimed)&quot;)    public Object timedClass(ProceedingJoinPoint pjp) throws Throwable &#123;        Method method = ((MethodSignature) pjp.getSignature()).getMethod();        Class&lt;?&gt; declaringClass = method.getDeclaringClass();        CustomTimed timed = declaringClass.getAnnotation(CustomTimed.class);        return perform(pjp, timed);    &#125;    @Around(&quot;execution (@top.tbghg.demo.monitor.aop.CustomTimed * *.*(..))&quot;)    public Object timedMethod(ProceedingJoinPoint pjp) throws Throwable &#123;        Method method = ((MethodSignature) pjp.getSignature()).getMethod();        CustomTimed timed = method.getAnnotation(CustomTimed.class);        return perform(pjp, timed);    &#125;    private Object perform(ProceedingJoinPoint pjp, CustomTimed timed) throws Throwable &#123;        Timer.Sample sample = Timer.start(registry);        String exceptionClass = DEFAULT_EXCEPTION_TAG_VALUE;        Object result = null;        try &#123;            result = pjp.proceed();            return result;        &#125; catch (Exception ex) &#123;            exceptionClass = ex.getClass().getSimpleName();            throw ex;        &#125; finally &#123;            record(pjp, timed, sample, exceptionClass, result);        &#125;    &#125;    private void record(ProceedingJoinPoint pjp, CustomTimed timed, Timer.Sample sample, String exceptionClass, Object result) &#123;        List&lt;Tag&gt; customTags = new ArrayList&lt;&gt;();        try &#123;            // 获取自定义标签            customTags = getCustomTags(pjp, timed, result);        &#125; catch (Exception e) &#123;            log.error(&quot;自定义标签运行异常, pjp: &#123;&#125;, CustomTimed: &#123;&#125;, result: &#123;&#125;&quot;, pjp, timed, result, e);        &#125;        try &#123;            // 记录指标            sample.stop(                    Timer.builder(timed.value())                            .description(timed.description())                            .tags(timed.extraTags())                            .tags(EXCEPTION_TAG, exceptionClass)                            .tags(customTags)                            .publishPercentileHistogram(timed.histogram())                            .publishPercentiles(timed.percentiles())                            .register(registry));        &#125; catch (Exception e) &#123;            log.error(&quot;指标记录失败, pjp: &#123;&#125;, CustomTimed: &#123;&#125;, customTags: &#123;&#125;&quot;, pjp, timed, customTags, e);        &#125;    &#125;    // 获取自定义标签    private List&lt;Tag&gt; getCustomTags(ProceedingJoinPoint pjp, CustomTimed timed, Object result) &#123;        List&lt;Tag&gt; customTags = new ArrayList&lt;&gt;();        // 处理入参相关标签        MonitorBeforeStrategy beforeStrategy = monitorStrategyFactory.getBeforeStrategy(timed.beforeKey());        if (beforeStrategy != null) &#123;            customTags.addAll(beforeStrategy.getTags(pjp));        &#125;        // 处理返回值相关标签        MonitorAfterStrategy afterStrategy = monitorStrategyFactory.getAfterStrategy(timed.afterKey());        if (afterStrategy != null) &#123;            customTags.addAll(afterStrategy.getTags(pjp, result));        &#125;        return customTags;    &#125;&#125;\n\nOK，实现完毕，下面就是一些配置了\n导入包、application.yaml添加配置 和之前的相同，不多赘述\nspringboot中添加注解\n@EnableAspectJAutoProxy@ImportResource(locations = &#123;&quot;classpath:spring-application.xml&quot;&#125;)\n\n下面就是写创建Bean的xml了\n&lt;bean id=&quot;respBodyVoMonitorAfterStrategy&quot; class=&quot;top.tbghg.demo.monitor.Strategy.impl.RespBodyVoMonitorAfterStrategy&quot;/&gt;&lt;bean id=&quot;wrappedRespBodyVoMonitorAfterStrategy&quot; class=&quot;top.tbghg.demo.monitor.Strategy.impl.WrappedRespBodyVoMonitorAfterStrategy&quot;/&gt;&lt;bean id=&quot;httpMonitorBeforeStrategy&quot; class=&quot;top.tbghg.demo.monitor.Strategy.impl.HttpMonitorBeforeStrategy&quot;/&gt;&lt;bean id=&quot;noHttpMonitorBeforeStrategy&quot; class=&quot;top.tbghg.demo.monitor.Strategy.impl.NoHttpMonitorBeforeStrategy&quot;/&gt;&lt;bean id=&quot;monitorStrategyFactory&quot; class=&quot;top.tbghg.demo.monitor.Strategy.MonitorStrategyFactory&quot;&gt;    &lt;property name=&quot;beforeStrategyMap&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;http&quot; value-ref=&quot;httpMonitorBeforeStrategy&quot;/&gt;            &lt;entry key=&quot;noHttp&quot; value-ref=&quot;noHttpMonitorBeforeStrategy&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;afterStrategyMap&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;respBodyVo&quot; value-ref=&quot;respBodyVoMonitorAfterStrategy&quot;/&gt;            &lt;entry key=&quot;wrappedRespBodyVo&quot; value-ref=&quot;wrappedRespBodyVoMonitorAfterStrategy&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n现在就已经彻底完成了，下面添加一个试试\n@CustomTimed(value = &quot;http.server.requests.custom&quot;, description = &quot;公共API请求&quot;, histogram = true, afterKey = &quot;wrappedRespBodyVo&quot;, beforeKey = &quot;http&quot;)\n\n下面打开http://localhost:8092/actuator/prometheus结果如下（部分）：\n（涉及具体业务，不方便贴图，就简单摘了一点，主要看指标的标签）\n# HELP http_server_requests_custom_seconds 公共API请求# TYPE http_server_requests_custom_seconds histogramhttp_server_requests_custom_seconds_bucket&#123;application=&quot;demo&quot;,business_code=&quot;1001&quot;,class=&quot;top.tbghg.controller.OpenApiController&quot;,exception=&quot;none&quot;,method=&quot;commonApi&quot;,requestMethod=&quot;POST&quot;,status_code=&quot;200&quot;,uri=&quot;/common_api&quot;,le=&quot;0.001&quot;,&#125; 0.0\n\n可以看到对于直方图类型，最终上报了 bucket、max、sount、sum四类数据，并且指标中包含如下标签：应用名、业务code、类、方法、http方法、异常、URI\n","categories":["技术","Prometheus"],"tags":["Prometheus","监控","后端"]},{"title":"监控平台搭建(6)-日志告警","url":"/2024-08-14/6647ff29bfaf/","content":"监控平台搭建(6)-日志告警前言日志告警通常是使用ELK(Elasticsearch、Logstash 和 Kibana)来做的\n\nELK：查看日志、日志告警\nPrometheus：查看指标、指标告警\n\n两个系统负责的不是同一种东西，按理说应该上ELK，但是它的体量太大\n此次需求需要对日志进行监控，同时项目较为小型，使用轻量化的mtail监控日志即可\n介绍mtail是一个google开发的日志提取工具，它从 应用程序日志 中提取指标以导出到 时间序列数据库 或 时间序列计算器，用于警报和仪表板\n简单来说，整个过程为：mtail实时读取应用程序的日志，根据用户编写的脚本实时分析，最终生成时间序列指标了，Prometheus拉取mtail暴露的指标\n官方地址\n配置与使用curl -LO https://github.com/google/mtail/releases/download/v3.0.7/mtail_3.0.7_linux_amd64.tar.gztar -xzf mtail_3.0.7_linux_amd64.tar.gzsudo mv mtail_3.0.7_linux_amd64/ /usr/local/mtail/mkdir mtailscd mtailsvim test.mtailcounter error_log_count by file,date,info/\\[(?P&lt;date&gt;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;)\\]\\[error\\],(?P&lt;info&gt;.*)/ &#123;  error_log_count[getfilename()][$date][$info]++&#125;\n\n先来逐行解释下test.mtail的内容，具体的mtail语法可参考：mtail详解 和 官方文档\n# 声明error_log_count，指出类型counter，说明包含file,date,info三种标签counter error_log_count by file,date,info# 正则匹配日期，?P&lt;date&gt;接收日期，之后通过$date使用# ?P&lt;info&gt;匹配这行后面的所有内容/\\[(?P&lt;date&gt;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;)\\]\\[error\\],(?P&lt;info&gt;.*)/ &#123;  error_log_count[getfilename()][$date][$info]++&#125;\n\n配置自启动，注意此处的logs需要根据实际情况替换\nsudo vim /usr/lib/systemd/system/mtail.service[Unit]Description=mtailAfter=network.target[Service]WorkingDirectory=/usr/local/mtailExecStart=/usr/local/mtail/mtail -port 9150 --progs /usr/local/mtail/mtails/ --logs /usr/local/mtail/logs/*.logRestart=on-failureRestartSec=5[Install]WantedBy=multi-user.target\n\n进行验证：\necho &quot;[2088-11-09 23:25:31][error],[object Promise] reason:TypeError: Cannot read properties of undefined (reading &#x27;area&#x27;)    at /data/server/server-2022-11-02-19-49-41-627-ver-07b1a29930153101e4feb0ff39e760903d9e5cbe/Project/Servers/wbScene/worldScene/EntityComponent/ComponentTrade.js:139:64    at Array.forEach (&lt;anonymous&gt;)    at ComponentTrade.autoTradeAction (/data/server/server-2022-11-02-19-49-41-627-ver-07b1a29930153101e4feb0ff39e760903d9e5cbe/Project/Servers/wbScene/worldScene/EntityComponent/ComponentTrade.js:133:16)    at runMicrotasks (&lt;anonymous&gt;)    at processTicksAndRejections (node:internal/process/task_queues:96:5)&quot; &gt;&gt; apple.log\n\nhttp://192.168.227.129:9150/\n\n发现mtail文件编译通过\n\n指标中有 时间、错误信息、日志文件、mtail文件，配置告警时，可以简单阐述错误情况\n参考资料\n官方文档\nmtail详解\nmtail + prometheus 监控日志error触发告警【重点】\nmatil采集错误日志并通过prometheus告警\n\n","categories":["技术","Prometheus"],"tags":["Prometheus","监控","后端"]},{"title":"监控平台搭建-总纲","url":"/2024-08-04/8e582b7771d9/","content":"监控平台搭建-总纲【TODO】\n环境搭建：缺少 AlertManager集群搭建\n可视化：未填写\n告警配置：HTTP待改写 应用未填写\n日志告警：配置与使用 未填写\n\n目录监控平台的搭建较为繁琐，下面分为一下几个部分进行讲解：\n\n基础知识\n环境搭建\nspringboot埋点\n可视化\n告警配置\n日志告警\n\n监控平台结构\nPrometheus\nExporter\nmysql - mysqld exporter\n主机 - node exporter\nJava应用\nSpringboot Actuator上报JVM信息        \n自行实现HTTP相关埋点(AOP)\nmtail监控日志\n\n\n\n\nAlertManager(集群 - Gossip协议 告警去重)\nPrometheus\n主机\nmysql\nhttp\n日志(mtail)\n\n\nGrafana\n能用模板用模板\n用不了自己配吧\n\n\n\nQ&amp;APushgatewayQ1：需要使用Pushgateway吗？\n不使用，也不需要使用。\n首先来举个使用Pushgateway场景的例子：\n我现在有一个临时任务脚本或批处理脚本，如果要上报Prometheus则需要开启对应http接口，按照对应格式编写，持续等待，直到Prometheus将该数据拉取才能停止\n当然我们可以直接使用Pushgateway，任务完成后将要上报的数据主动上报给Pushgateway，也就是从拉模式变成了推模式，实现则更为简单了一些\n同时注意，Pushgateway并不会将我们上推的数据按照时间序列的形式保存，同一个指标在不同时间上传多次会被覆盖，只留下最新的\n对于当前的需求来说，完全不需要使用Pushgateway\n拉取时间间隔Q2：假设Prometheus拉取时间是15s一次，而应用的数据是每秒计算一次，这样会导致中间14s的数据丢失吗，例如max、平均响应时长、TP90\nA2：并不会，首先需要明确下面几点：\n\n不管是 摘要 还是 直方图，它们都会累计的去记录max、count、sum\n直方图 中的桶是累计的，并不是每秒之类的\n\n下面分类型讨论一下，同样我们假设Prometheus每隔15s拉取一次\n\n最大响应时长：max是累计更新的，肯定是准确的，不需要考虑\n平均响应时长：计算方式为 选定一段区间，总时长的差值&#x2F;这段时间的响应数量，得到的就是这个时间段的平均响应时长，并且上报的数据中 总时长和总共数量也都有\n\n最后则是分位点：\n\n摘要：摘要计算分位点有一个滑动窗口，默认的滑动窗口时间长度是 2 分钟，滑动时间间隔是 1 秒。分位点计算基于最近 2 分钟内收集的数据，并且每秒钟更新一次，如果出现极端数据，还是会反映到Prometheus中的，除非拉取时间比滑动窗口时间还长\n直方图：它的桶是累积的，Prometheus是根据桶来估算出分位点的，所以也没有影响。但是需要注意，计算一段时间内的TP90时，指定的时间窗口要大于向Prometheus上报的时间间隔\n\n","categories":["技术","Prometheus"],"tags":["Prometheus","监控","后端"]},{"title":"OAuth2介绍","url":"/2023-10-22/1a999e0870b8/","content":"重点介绍授权码模式，以及实现第三方QQ登录并获取信息\nOAuth介绍OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容\nOAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0\nOAuth2包括：\n\n授权码模式（authorization code）\n简化模式（implicit）\n密码模式（resource owner password credentials）\n客户端模式（client credentials）\n\n具体可以参考：理解OAuth 2.0\n授权码模式过程我们先用QQ来理解一下，假如我现在做了个网站，想要实现QQ登录，这里分为：QQ认证服务器，QQ资源服务器(有权限时访问会获取该QQ账户的信息，如头像)，客户端(这里指我的网站)，服务端(我个人的网站服务端)\n\n@startuml&#x27;https://plantuml.com/zh-dark/sequence-diagram&#x27;客户端 认证服务器 资源服务器 服务端&#x27;获取code&#x27;客户端 -&gt; 服务端:选择QQ登录\\n「可省略，由客户端直接请求认证服务器」&#x27;服务端 -&gt; 客户端:302重定向至认证服务器，携带response_type、client_id、redirect_uri、state等，见下文\\n「可省略，由客户端直接请求认证服务器」客户端 -&gt; 认证服务器:携带response_type、client_id、redirect_uri、state等认证服务器 -&gt; 客户端:302重定向至redirect_uri，携带code&#x27;获取access_token客户端 -&gt; 服务端:(redirect_uri对应地址)携带code服务端 -&gt; 认证服务器:携带grant_type、client_id、*client_secret*等，见下文\\n根据code换access_token认证服务器 -&gt; 服务端:返回access_token、expires_in、refresh_token&#x27;获取资源服务端 -&gt; 资源服务器:携带access_token，获取账户资源，如QQ头像、昵称资源服务器 -&gt; 服务端:返回对应资源服务端 -&gt; 客户端:返回对应资源@enduml\n\n关于客户端-&gt;认证服务器和服务端-&gt;认证服务器可参考QQ给出的文档：使用Authorization_Code获取Access_Token\n获取Authorization Code：\n\n\n\n参数\n是否必须\n含义\n\n\n\nresponse_type\n必须\n授权类型，此值固定为“code”。\n\n\nclient_id\n必须\n申请QQ登录成功后，分配给应用的appid。\n\n\nredirect_uri\n必须\n成功授权后的回调地址，必须是注册appid时填写的主域名下的地址，建议设置为网站首页或网站的用户中心。注意需要将url进行URLEncode。\n\n\nstate\n必须\nclient端的状态值。用于第三方应用防止CSRF攻击，成功授权后回调时会原样带回。请务必严格按照流程检查用户与state参数状态的绑定。\n\n\nscope\n可选\n请求用户授权时向用户显示的可进行授权的列表。 可填写的值是API文档中列出的接口，如果要填写多个接口名称，请用逗号隔开。 例如：scope&#x3D;get_user_info,list_album,upload_pic 不传则默认请求对接口get_user_info进行授权。 建议控制授权项的数量，只传入必要的接口名称，因为授权项越多，用户越可能拒绝进行任何授权。\n\n\ndisplay\n可选\n仅PC网站接入时使用。 用于展示的样式。不传则默认展示为PC下的样式。 如果传入“mobile”，则展示为mobile端下的样式。\n\n\n通过Authorization Code获取Access Token：\n\n\n\n参数\n是否必须\n含义\n\n\n\ngrant_type\n必须\n授权类型，在本步骤中，此值为“authorization_code”。\n\n\nclient_id\n必须\n申请QQ登录成功后，分配给网站的appid。\n\n\nclient_secret\n必须\n申请QQ登录成功后，分配给网站的appkey。\n\n\ncode\n必须\n上一步返回的authorization code。 如果用户成功登录并授权，则会跳转到指定的回调地址，并在URL中带上Authorization Code。 例如，回调地址为www.qq.com/my.php ，则跳转到：http://www.qq.com/my.php?code=520DD95263C1CFEA087****** 注意此code会在10分钟内过期。\n\n\nredirect_uri\n必须\n与上面一步中传入的redirect_uri保持一致。\n\n\nfmt\n可选\n因历史原因，默认是x-www-form-urlencoded格式，如果填写json，则返回json格式\n\n\nneed_openid\n可选\nneed_openid&#x3D;1，表示同时获取openid。\n\n\n当然，我们需要去标识该用户，可以通过携带AccessToken，请求OpenID接口，即可获取对应用户身份标识OpenID。\n和简化模式相比，多了通过code换取AccessToken的过程，这个过程是在自己的后台服务器完成的，secret保存在服务端，不会暴露给用户，从而保证更高的安全性\n即：授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动\n\n\nQ1: code换取token时，为什么也要携带redirect_uri？ \n核对授权码和重定向URI, 验证是否对应。(网上有说是回调地址，之后要回调之类的。这个步骤发生在获取code之后，认证服务器返回302重定向到redirect_uri，在根据code获取token时，很明显跟这个原因没关系)\n\n\nQ2: 在获取code时，redirect_uri为什么有些授权方认证时是可选的？\nRFC6749 3.1.2. Redirection Endpoint里写了，这个redirect_uri可以通过请求参数传给认证服务器，也可以在客户端在认证服务器注册的时候提前设置\n\n\nQ3: 为什么需要有code这一步，直接拿到token不行吗？\n\n说法一：Why is there an “Authorization Code” flow in OAuth2 when “Implicit” flow works so well?\n说法二：secret存储在客户端是不安全的，中间加一层服务端，把需要secret获取token的交由 服务端-认证服务器 处理，不暴露给外界，保证安全性\n\n\n\nQ4: CSRF以及state字段\n之后补充\n\n这几个问题欢迎评论区探讨\n登录QQ-Golang实现可参考：Go 语言实现 QQ 扫码登陆，AppId和AppKey使用该博主所申请的，代码写的也很可以，我也没啥好补充的。代码\n","categories":["技术","web"],"tags":["go","Auth"]},{"title":"cookie、session、token详解","url":"/2022-05-26/9ad8d035806c/","content":"cookie介绍Http协议是一个无状态的协议，因此需要一个标识用来让服务器区分不同的浏览器。cookie就是这个管理服务器与客户端之间状态的标识。\ncookie原理：浏览器第一次向服务器发送请求时，服务器可以通过在response头部设置Set-Cookie字段，浏览器收到响应就会设置cookie并存储，在下一次该浏览器向服务器发送请求时，就会在request头部自动带上Cookie字段，服务器端收到该cookie用以区分不同的浏览器。当然，这个cookie与某个用户的对应关系应该在第一次访问时就存在服务器端，这时就需要session了。\n基础知识\ncookie是有大小限制的。每个cookie所存放的数据不能超过4k，如果cookie字符串长度超过4k，则该属性将返回空字符串。\n由于cookie最终都是以文件形式存放在客户端计算机中，所以查看和修改cookie都是很方便的，这就是为什么常说cookie不能存放重要信息的原因。\n每个cookie是存在有效期的。在默认情况下，一个cookie的生命周期就是在关闭浏览器的时候结束。如果想要cookie能在浏览器关掉之后还可以使用，就必须要为cookie设置有效期，也就是cookie的失效日期。\nalert(typeof document.cookie) 结果是string,而不是array。\ncookie有域和路径这个概念。域就是domain的概念，因为浏览器是个注意安全的环境，所以不同的域之间是不能互相访问cookie的(当然可以通过特殊设置达到cookie跨域访问)。路径就是routing的概念，一个网页所创建的cookie只能被这个网页在同一目录或者子目录下的所有页面访问，而不能被其他目录下的网页访问。\n创建cookie的方式和定义变量的方式有些相似，都需要使用cookie名称和cookie值。同个网站可以创建多个cookie，而多个cookie可以存放在同一个cookie文件中。当然不同浏览器都有着cookie数量、大小的上限\n\n常见问题\ncookie存在两种类型\n你浏览的当前网站本身设置的cookie\n来自在网页上嵌入广告或图片等其他域来源的，第三方cookie(网页可通过使用这些cookie跟踪你的使用信息)\n\n\ncookie的生命周期，大致也两种状态：\n临时性质的cookie。当前使用的过程中网站会存储一些你的个人信息，当浏览器关闭后这些信息也会从计算机中删除\n设置失效时间的cookie。就算浏览器关闭了，这些信息依然会在计算机中，如登录名和密码，这样无须每次都到特定站点时都进行登录，这种cookie可以在计算机中保留几天，几个月，甚至几年\n\n\ncookie的两种清除方式\n通过浏览器工具清除cookie(有第三方工具，浏览器自身也有这种功能)\n通过设置cookie的有效期来清除cookie\n删除cookie有时候可能导致某些网页无法正常运行\n\n\n浏览器可以通过设置来接收和拒绝访问cookie\n出于功能和性能的原因考虑，建议尽量减少cookie的使用数量，并且尽量使用小cookie\n\n路径概念cookie有域和路径的概念，现在介绍路径在cookie中作用。 cookie一般都是由于用户访问页面而被创建的，可是并不是只有在创建cookie的页面才可以访问这个cookie。 默认情况下只有与创建cookie的页面在同一个目录或子目录的网页才可以访问，这个是因为安全方面的考虑，造成不适所有页面都可以随意访问其他页面创建的cookie。\nhttp://www.cnblog.com/Darren\\_code/ 这里种的cookiehttp://www.cnblog.com/Darren\\_code/archive/cookie.html 可以拿到上面的cookiehttp://www.cnblog.com/xxx/ 就拿不到cookie，http://www.cnblog.com也拿不到\n那么如何让这个cookie能被其他目录或者父级目录访问，通过设置cookie的路径就可以实现，如:\ndocument.cookie &#x3D; “name&#x3D;value;path&#x3D;path”;document.cookie &#x3D; “name&#x3D;value;expires&#x3D;date;path&#x3D;path”\npath就是cookie的路径，最常用的就是让cookie在根目录下，这样不管是哪个子页面创建的cookie，所有的页面都可以访问了；\ndocument.cookie &#x3D; “name&#x3D;yulong;path&#x3D;&#x2F;“\n域概念路径能解决在同一个域下访问cookie的问题，咱们接着说cookie实现同域访问的问题\ndocument.cookie &#x3D; “name&#x3D;yulong;path&#x3D;path;domain&#x3D;domain”\n如果我们有a:www.qq.com 与 b:sports.qq.com 公共一个关联域名qq.com 想让b下的cookie被a访问，我们就需要用到cookie的domain属性，并且把path设置成更目录”&#x2F;“\ndocument.cookie &#x3D; “name&#x3D;yulong;path&#x3D;&#x2F;;domain&#x3D;qq.com”\n\n一定是同域之间的访问，不能把domain的值设置成非主域的域名。\n\n安全性通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，所以cookie存储的信息容易被窃取。加入cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。 所以cookie的这个属性的名称是secure,默认值为空，如果一个cookie的属性为secure，那么它与服务器之间的就通过https或者其他安全协议传递数据\ndocument.cookie &#x3D; ‘username&#x3D;yulong;secure’\n把cookie设置为secure，只是cookie与服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如想让本地cookie加密，要自己加密。\n\n就算设置了secure属性也不代表他人不能看到你机器本地保存的cookie信息，所以说到底，别把重要信息放cookie就对了。\n\n编码细节在输入cookie信息时，不能包含空格，分号，逗号等特殊符号，而在一般情况下，cookie信息的存储都是采用未编码的方式。所以在设置cookie信息之前，要先使用escape()函数将cookie信息进行编码，在获取得到cookie值的时候，再使用unescape()函数把值进行转换回来，\ndocument.cookie &#x3D; name &#x3D; “&#x3D;” + escape(value)return unescape(docment.cookie.substring(start,end))\n这样就不用担心因为cookie值出现了特殊符号而导致cookie信息报错了。\nsessionsession是会话的意思，浏览器第一次访问服务端，服务端就会创建一次会话，在会话中保存标识该浏览器的信息。它与cookie的区别就是session是缓存在服务端的，cookie 则是缓存在客户端，他们都由服务端生成，为了弥补Http协议无状态的缺陷。\nsession-cookie认证\n服务器在接受客户端首次访问时在服务器端创建session，然后保存session（我们可以将session保存在内存中，也可以保存在redis中，推荐使用后者），然后给这个session生成一个唯一的标识字符串，然后在响应头中种下这个唯一标识字符串。\n签名。这一步通过秘钥对sid进行签名处理，避免客户端修改sid。（非必需步骤）\n浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的 请求头中会带上该域名下的cookie信息。\n服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客 户端的session，然后判断该请求是否合法。\n\n用户登录认证使用session-cookie做登录认证时，登录时存储session，退出登录时删除session，而其他的需要登录后才能操作的接口需要提前验证是否存在session，存在才能跳转页面，不存在则回到登录页面。\nToken基于Token的认证，是指将所有认证相关的信息在服务器端编码成一个Token，并由服务器签名，以确保不被篡改。Token本身是明文的。存在Token里的信息可以有比如user id、权限列表、用户昵称一类的。这样服务器只要拿着token和token的签名，就可以直接验证用户的身份是合法的。在现实当中，基于Token的认证的主要标准是Json Web Token （JWT）\nJWT资料还是比较多的，不再赘述另外这个网站不错JWT\n注意事项\n使用了JWT，无法实现在服务器端对用户请求进行管理——管理员没法统计多少个人登录了，一个人登录了多少次，登陆了什么设备；同时，也无法强行“踢”掉一个用户的登录——JWT一旦生成，在失效之前，总是有效的。如果实现了一个token黑名单之类的功能，就等价于实现了Session机制，无状态带来的好处就无从谈起。这个限制对于任何一个要认真做用户风险控制的网站来说都是不可能接受的。\n使用了JWT，无法很好的控制payload的数据量。尽管规范表示，应该只把认证的相关信息放到payload里。但实际上，开发人员往往会误用，把几乎所有和user相关的数据都放到payload里。而payload的尺寸过大，比如达到数KB，就会极大的损耗带宽和IO性能。要记得，为了达成“无状态”，每个请求都必须把全量的JWT都带着……\n\n这两个严重的缺陷限定了JWT只能用到一些不太认真的场景。而对于真正的社交、金融、游戏等认真一点的服务，还是要选择基于Session的认证。\n另外如果token中还有session id，就可以在服务器端实现基于Session的认证。因此，你可以将user id、session id、token过期时间等几个关键数据放到payload里——只放这几个，不放其他的数据，得到一个用来做Session认证的JWT。更进一步，如果你把JWT的规范稍微小改一下，比如payload不用JSON，而是更紧凑的格式；定死了签名算法，即可省略JWT的header了；最后再优化一下编码格式，就能得到一个你自己的token。\nToken和session的区别\nsession-cookie的缺点：（1）认证方式局限于在浏览器中使用，cookie是浏览器端的机制，如果在app端就无法使用cookie。（2）为了满足全局一致性，我们最好把session存储在redis中做持久化，而在分布式环境下，我们可能需要在每个服务器上都备份，占用了大量的存储空间。（3）在不是Https协议下使用cookie，容易受到CSRF跨站点请求伪造攻击。\ntoken的缺点：（1）加密解密消耗使得token认证比session-cookie更消耗性能。（2）token比sessionId大，更占带宽。\n两者对比，它们的区别显而易见：（1）token认证不局限于cookie，这样就使得这种认证方式可以支持多种客户端，而不仅是浏览器。且不受同源策略的影响。（2）不使用cookie就可以规避CSRF攻击。（3）token不需要存储，token中已包含了用户信息，服务器端变成无状态，服务器端只需要根据定义的规则校验这个token是否合法就行。这也使得token 的可扩展性更强。\n\n存储认证信息谈完了session和token，我们来说所说这个信息在客户端怎么存储。客户算也分两大类——浏览器和Native App。先说说浏览器。\n浏览器浏览器中的存储主要是Local Storage和Cookie。\n\n其实浏览器用于存放认证信息的存储还有Session Storage，但是它和Local Storage差不多，只是失效的机制不太一样。这里只用Local Storage讨论。\n\n使用基于Token认证的开发人员很喜欢使用Header + Local Storage。因为这样可以有效防止CSRF （下一小节专门讲）。\n但是使用Local Storage，反而会增加中招XSS（Crossing Site Script）的机会。一旦中招XSS，攻击者可以轻易的拿到认证信息，并且传回自己的接受网址而不被用户察觉。这样一来攻击者能够轻易的代替用户登录了。\n整个浏览器中，只有一种资源是脚本无法访问到的。这就是被设置为HttpOnly的cookie。这是非常理想的放置认证token&#x2F;session id的地方。设置这种token只需要在Set Cookie时这么写：\nSet-Cookie: access_token&#x3D;xxxxxxxxxxxxxxxxxx; HttpOnly; Secure; Same-Site&#x3D;strict; Path&#x3D;&#x2F;;\n(Secure和Same-Site是什么？下文会解释)\nXSS攻击者没有任何办法从HttpOnly的Cookie中拿到你的认证信息，除非他能在你登录网站后，直接进入你的电脑，打开浏览器的开发者工具并人肉复制粘贴（叫你不锁屏，哼）。\n有些人坚称自己的程序可以保证不受XSS的攻击，所以可以放心的用Local Storage。比如使用React框架开发的程序理论上所有的DOM节点都由React的虚拟DOM产生，所有的标签生成都进行了escape。espace掉的脚本就无法执行，也就不可能XSS了。\n这样讲没有错误，但是XSS最令人头疼的地方在于你很难保证你的网站对所有用户的输入都进行了escape。\n\n你编写的是一个写文章的网站，需要支持用户手工输入HTML，并且HTML必须得直接展示；\n你编写的网站99%是React这样的框架生成的，但是可能会有一些边角，为了方便还是使用jquery等传统技术\n你的网站是一个团队开发，尽管开发规范要求大家都要对用户的输入进行escape处理，但是只要是人就会忘，而escape这件事情不一定能进入到测试的Case清单；\n……\n\n只要有一个漏洞存在，那么整个防护体系就完全失效。这就是为什么HttpOnly Cookie这样的绝对隔离措施很关键的原因。\nNative AppNative App比浏览器相对简单。一般Native App都是静态编译产生，不存在XSS的问题。同时移动操作系统都会有沙箱机制，避免其他App读取到自己的数据（除非你root了……）。因此，Native App可以比较放心的将数据存在App沙箱内某个存储即可。如果不放心，可以考虑如iOS KeyChain或者Android KeyStore这样的设施。\n但Native App与服务器交互有一些区别。Native App一般是不直接支持Cookie机制的。所以如果一个服务器端使用Cookie来保存认证信息，就需要Natvie App手工解析Set-Cookie Header，同时，Native App因为不直接支持Cookie，所以倾向于在请求中使用AuthorizationHeader来传入认证信息。这也需要服务器适配。当然，最简单的办法是让Native App引入一个模拟Cookie行为的库。\n防止CSRFCSRF代表Crossing Site Recource Forge。大致的触发流程是：\n\n用户登录了站点A，并且在Cookie中留下了A站点的认证信息\n用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权&#x2F;转账&#x2F;发文辱骂等等。\n\n上文中提到了，很多人用JWT+Local Storage的本心是为了防护CRSF。这样做的原因是——因为Cookie的发送是完全由浏览器控制的，不受网页本身的控制。所以最简单直接的办法，就是不用Cookie，不让自动发送认证信息成为可能。问题在于，这么干是有XSS风险的。从上文中可以看到，为了避免XSS，就必须用HttpOnlyCookie。\n那么怎么在使用Cookie的同时，还能防范CSRF呢？\n传统页面Web网站在传统页面Web网站中，一般会使用CSRF Token。这是个非常流行的做法。像Tomcat这类的容器都会自带CSRF Token的产生和检查Filter。\nCSRF Token是这样工作的。客户端要首先向服务器请求一个带有提交表单的页面，服务器返回的页面中会嵌入一个CSRF Token。当用户提交表单时，CSRF Token会被一起携带发给服务器做验证。所以当服务器看到CSRF Token，就可以放心大胆的确认用户的的确确是看看到了提交前的表单界面，从而避免了用户稀里糊涂提交一个被伪造的表单的可能性。\nSPACSRF Token只适合于传统的页面请求，在SPA的情况下会比较尴尬。\n在SPA中，客户端与服务器之间的交互主要是通过接口完成的，没有页面的概念。此时，你的确可以照猫画虎的做一个接口让用户拿到CSRF Token，但这样什么也确认不了。因为攻击者可以调用同样的接口，拿到合法的CSRF Token。\n这时有几种办法：\n\n给所有接口都添加一个请求secret，来标记其来自于合法的客户端。这个secrect可以是固定的随机字符串，也可以通过某些动态算法产生。对于CSRF，浏览器只会做自动传Cookie而已，并不能帮助传入secret。这样一来，就可以确定消除CSRF的风险。但注意，这个机制仅能防范CSRF，而不能防范人为的攻击。黑客只要拿得到客户端，就一定能找到生成secret的办法。secret有一个顺带的功能是提高了第三方用户随意调用接口的门槛——他们必须得去查看客户端源代码，学会了怎么生成secret才能调用接口。\n用Same-Site Cookie。回到上面CSRF步骤的第二步骤。当用户看到了B站点伪造的表单，点击了提交，向站点A发出请求时，被标记了Same-Site=strict的Cookie是不会被携带的，因为当时的主站点域名B和提交的站点域名A不一样。这是Same-Site=strict标记是个相对较新的标准。目前大部分浏览器都已经支持了。但如果大量的用户群还在类似于IE8这样的老系统上，这个招数便是无效的。\n歪招，总是用json格式提交。CSRF可能发生的一个前提条件是必须用传统表单提交。这是因为传统表单提交可以跨域——你在站点B，可以提交表单给站点A。而Ajax的请求除非开启CORS，是不允许跨域的，所以天然的屏蔽掉了这个问题。传统表单的提交的格式必然是application/x-www-form-urlencoded。因此只要保证服务器能够拒绝处理所有application/x-www-form-urlencoded格式的POST请求，就能确保SPA不受CSRF的影响。那用啥呢？JSON - application/json。（我专门写这一条的原因是，jquery的ajax库的默认行为正是使用application/x-www-form-urlencoded格式。如果你还在用，可以考虑改一下。）\n另一个歪招，双认证。将你的认证信息同时放在HttpOnly Cookie和Authorization Header。服务器要先比对这两个值是一样的，然后再去执行认证过程。这样可以同时防范XSS和CSRF。代价是，如果你的认证信息比较长，会浪费一些带宽。\n\n总是使用httpshttp是明文传输的。在http下，用户输入的任何信息，从他的电脑到服务器之间的每个链路节点都是明文的。在这里个链路中的任何地方，都可以截取到完整的数据，包含你的密码，认证token……\n这就是为什么https是必须的。https主要提供三个保证：\n\n端端加密。通过https交互的原始数据，只有用户的浏览器和最终的服务器可以看到。其他中间节点无法获）。\n客户端可以认定要访问的服务器就是那个服务器。这是被证书体系所支撑的。一旦浏览器的地址栏出现了网址的证书信息，并且是绿色的提示，那么用户的心里就可以稳了。（当然国内其实也不完全是这样，讲多了查水表，懂者自懂）。\n服务器可以认定访问的客户端就是合法的客户端。这种模式被称为“2-Way SSL”或者“Mutal SSL”。这种模式是可选的，需要多配置一个客户端证书，一般场景用不到，多见于企业Web服务。\n\n早些时候，很多人对https有一些抵触，大致的原因是，支持https需要软件改造；服务器对证书进行密码计算要耗费很多CPU；同时也会带来跟多的网络请求和响应（多了ssl握手）。这无疑会带来一些成本和体验上的问题。但那已经是10多年前的事情了。现在的软硬件处理能力和网络基础设施比起10年前都有数倍的提高。如果今天，一个商业网站仍然坚持不用https，那么可以请他的老板去大街上裸奔。\n使用了https后，为了进一步保证安全，将Cookie设置为Secure。这样，浏览器就可以只在访问https网址时才会携带Cookie。如果不做这样的设置，通过https站点设置的Cookie，仍然会向http站点发送。当这个站点的域名解析被劫持，就可能造成向一个伪造的服务器发出你的认证信息。\n认证信息不应该永久有效很多人为了“用户体验”，选择让一个登录永久有效。这样做是非常危险的。因为一旦用户的认证信息被别人获取了，就永久性的失去了防御的机会。\n因此，总是要保证认证信息的有效期是有限的。一般根据业务场景的安全级别不同，可以设为若干分钟～若干天。就算是社交娱乐类的应用，有效期最好也不要超过两周。\n但，为了让频繁使用的用户体验更好，可以考虑实现会话期续期。但需要注意，这里说的续期是指从用户角度看可以延续其不需要登录的时间长度，而不是直接让session&#x2F;token有效期变长。必须实现为给用户替换一个新的session id&#x2F;token。这样做，既能保证同一个认证信息不会永久有效，又能让正常的、频繁使用的用户免除登录之苦。\n总结一下总结下来，一个靠谱的Web认证应该：\n\n可以使用Session也可以使用Token做认证，但是总是要保证服务器端可以管理Session，通过Session是否存在来最终确定认证的有效性；\n将认证信息存放在标记为HttpOnly，Secure，Same-Site=strict的Cookie中，从而避免XSS和CSRF；\n总是使用https，只要你的网络链路经过了公网；\n如果是传统的页面网站，请使用CSRF Token机制；\n如果可以，做一个简单的请求secret，可以辅助防止CSRF，也可以稍稍的提高接口被爬取的门槛；\n如果是SPA应用，放心大胆的禁用对application/x-www-form-urlencoded的支持\n保证token&#x2F;session必须有一个有效期\n\n如果你也觉得靠谱，就不妨照着做。\nOAuth2.0OAuth，把这个看完基本就没问题了，说的很形象（当然我也正在看）\n参考文章\n浅析cookie\n两种认证\n前端鉴权（Cookie&#x2F;Session、Token和OAuth）\n\n","categories":["技术","web"],"tags":["后端","Auth"]},{"title":"flask踩坑总结","url":"/2022-03-05/99cd8c13fe0b/","content":"微信云函数无法调用把代理关掉试试\n命名冲突创建`platform.py`文件后程序突然无法运行，最终发现是程序调用了`platform.py`，最终改了个名，bug修复\n蓝图的使用蓝图引入错误将所有蓝图注册到app里面时提示`AttributeError: ‘function’ object has no attribute ‘register’`，自己将蓝图命名为login，该路由下的函数命名为login，导致引成了函数，最终导致注册错误。\n蓝图配置JWT笔者当时不太清楚蓝图应该如何配置JWT，毕竟需要关联到app里，但是蓝图并没有这个东西，最终明白了，蓝图最后都是注册在app里面再运行的，所以在app里面配置好注册蓝图，蓝图自动配置好了，也就是说在蓝图里直接调用就\napscheduler 遇到的问题报warring：The localize method is no longer necessary, as this time zone supports the fold attribute\n设置时区即可：\naps = APScheduler(scheduler=BackgroundScheduler(timezone=&#x27;Asia/Shanghai&#x27;))\n\nContent-Type类型为application&#x2F;x-www-form-urlencoded发送POST请求　　application&#x2F;x-www-form-urlencoded属于比较常用的POST 提交数据的方式。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。　　如果Content-Type 设置为 application&#x2F;x-www-form-urlencoded；此时body提交的数据需要按照 k1&#x3D;v1&amp;k2&#x3D;v2 的方式进行编码,然后进行提交\nimport requestsimport jsonfrom urllib import parse# 定义请求headerHEADERS = &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=utf-8&#x27;&#125;data = &#123;&#125;   # 略# 字典转换k1=v1 &amp; k2=v2 模式data = parse.urlencode(FormData)res = requests.post(url=url, headers=HEADERS, data=data)\n","categories":["技术","web"],"tags":["flask","JWT","python"]},{"title":"json.Unmarshal精度丢失问题分析","url":"/2023-07-11/760dbde82251/","content":"问题描述根据id查询某条数据查询不到，观察日志发现id后两位丢失变为00\n分析先看一段代码：\npackage mainimport (\t&quot;bytes&quot;\t&quot;encoding/json&quot;\t&quot;fmt&quot;)func main() &#123;\tvar m map[string]interface&#123;&#125;\tstr := `&#123;&quot;id&quot;:9223372036854775807, &quot;app&quot;:12312.3434&#125;`\t_ = json.Unmarshal([]byte(str), &amp;m)\tfmt.Printf(&quot;Unmarshal type:%T, value:%v\\n&quot;, m[&quot;id&quot;], m[&quot;id&quot;])\tfmt.Printf(&quot;Unmarshal type:%T, value:%v\\n&quot;, m[&quot;app&quot;], m[&quot;app&quot;])\tfmt.Println(&quot;-----------------------------------&quot;)\td := json.NewDecoder(bytes.NewReader([]byte(str)))\td.UseNumber()\t_ = d.Decode(&amp;m)\tfmt.Printf(&quot;UseNumber type:%T, value:%v\\n&quot;, m[&quot;id&quot;], m[&quot;id&quot;])\tfmt.Printf(&quot;UseNumber type:%T, value:%v\\n&quot;, m[&quot;app&quot;], m[&quot;app&quot;])&#125;/*Unmarshal type:float64, value:9.223372036854776e+18Unmarshal type:float64, value:12312.3434-----------------------------------UseNumber type:json.Number, value:9223372036854775807UseNumber type:json.Number, value:12312.3434*/\n\n使用json.Unmarshal解析后，若未制定目标的类型，对于数字默认会采用float64，见json.Unmarshal中的文档：\n// To unmarshal JSON into an interface value,  // Unmarshal stores one of these in the interface value:  // bool, for JSON booleans  // float64, for JSON numbers  // string, for JSON strings  // []interface&#123;&#125;, for JSON arrays  // map[string]interface&#123;&#125;, for JSON objects  // nil for JSON null\n\n结论因此，对于使用int64类型的数据，若数字超过了float64的范围，则会造成精度损失。\n解决方案：使用UseNumber，见示例代码中的第二部分。关于UseNumber文档给出的描述如下：\n// UseNumber causes the Decoder to unmarshal a number into an interface&#123;&#125; as a Number instead of as a float64.func (dec *Decoder) UseNumber() &#123; dec.d.useNumber = true &#125;\n使用UseNumber后会使用json.Number类型接收值：\n// A Number represents a JSON number literal.type Number string\n即通过字符串进行接收，也可称为数字文本\n多级嵌套时，若内部含有interface&#123;&#125;且为int类型同样需要注意使用UseNumber。\n不过在前端序列化大数时也会出现精度损失的情况，如下：\n\n所以对于大数的情况前后端最好提前沟通一下这种情况，也可以对于大数统一使用字符串类型序列化后传递。或者双方约定，数字类型不得超过53位\n注意事项若代码下文包含switch-case类型转换，要单独把json.Number类型列出，例如：\n// FormatInt64 将v转换成int64func FormatInt64(v interface&#123;&#125;) (res int64, err error) &#123;\tswitch vt := v.(type) &#123;\tcase int64:\t\tres = vt\t\treturn\tcase int:\t\tres = int64(vt)\t\treturn\tcase int32:\t\tres = int64(vt)\t\treturn\tcase int16:\t\tres = int64(vt)\t\treturn\tcase int8:\t\tres = int64(vt)\t\treturn\tcase float64:\t\tres, err = strconv.ParseInt(strconv.FormatFloat(vt, &#x27;f&#x27;, 0, 64), 10, 64)\t\treturn\tcase float32:\t\tres, err = strconv.ParseInt(strconv.FormatFloat(float64(vt), &#x27;f&#x27;, 0, 64), 10, 64)\t\treturn\tcase []byte:\t\tres, err = strconv.ParseInt(string(vt), 10, 64)\t\treturn\tcase string:\t\tres, err = strconv.ParseInt(vt, 10, 64)\t\treturn\tdefault:\t\terr = fmt.Errorf(&quot;not support %T&quot;, v)\t&#125;\treturn&#125;\n\n因为不包含json.Number会直接报错not support json.Number\n","categories":["技术","web"],"tags":["go"]},{"title":"Socket 单步调试正确，直接运行错误","url":"/2021-08-10/8f8bd7ea7177/","content":"Socket 单步调试正确，F5调试错误，运行也错误的解决方案（TBgHg：终于找到原因了）\n出自icansaymyabc 如下所示：\n\nsocket程序是与操作系统紧密相关的，它异步调用了各种系统资源。\n你的问题我见得多了，实质上就是在socket的异步操作尚未得到应答之前你的单线程工作流已经把socket对象销毁了。\n单步调试之所以成功是因为你在每一个语句执行完后给了很大的停顿，使得socket对象在被销毁前有机会干完工作。\n解决办法1：把你的源程序每个语句之后加一条 Sleep(5000)，这样留出足够的时间给socket对象干活。\n解决办法2：把你的程序改成多线程的或异步的，要确保socket对象完成了本职工作才能销毁它。\n\n","categories":["技术","web"],"tags":["socket"]},{"title":"常见限流算法","url":"/2023-10-19/df3cc489e560/","content":"参考文章\nGo实现常见的限流算法\n系统自适应限流\nuber-go 漏桶限流器使用与原理分析\n\n介绍限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。\n常见限流算法有：\n\n固定窗口&#x2F;计数器\n滑动窗口\n限流桶\n令牌桶\n\n常见限流算法固定窗口&#x2F;计数器维护一个计数器，设置一个过期时间，例如：1min访问次数不能包括100次，有用户访问时，访问次数+1，超过阈值时拒绝该请求，每隔1min重制一次计数器。\n但当用户第59s发送了100个请求和第61s发送了100个请求，此时因为计数器重制，所以会将这些请求放行\n优点：实现简单\n可以通过redis实现：设置过期时间，每次访问后值+1，同时判断下访问次数是否超过域值\n滑动窗口\n整个红色的矩形框表示一个时间窗口，举例的话，一分钟作为一个时间窗口，把它分割成6份，每份10s，过10s就把窗口向右移动一格，每个格子都有自己单独的计时器，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确\n这样看的话，第一种方案其实是将1min作为一个窗口，即计数器是滑动窗口的一种特殊情况，所以也被称为固定窗口。\npackage limiter// 代码摘自 https://juejin.cn/post/7056068978862456846import (   &quot;errors&quot;   &quot;sync&quot;   &quot;time&quot;)// SlidingWindowLimiter 滑动窗口限流器type SlidingWindowLimiter struct &#123;   limit        int           // 窗口请求上限   window       int64         // 窗口时间大小   smallWindow  int64         // 小窗口时间大小   smallWindows int64         // 小窗口数量   counters     map[int64]int // 小窗口计数器   mutex        sync.Mutex    // 避免并发问题&#125;// NewSlidingWindowLimiter 创建滑动窗口限流器func NewSlidingWindowLimiter(limit int, window, smallWindow time.Duration) (*SlidingWindowLimiter, error) &#123;   // 窗口时间必须能够被小窗口时间整除   if window%smallWindow != 0 &#123;      return nil, errors.New(&quot;window cannot be split by integers&quot;)   &#125;   return &amp;SlidingWindowLimiter&#123;      limit:        limit,      window:       int64(window),      smallWindow:  int64(smallWindow),      smallWindows: int64(window / smallWindow),      counters:     make(map[int64]int),   &#125;, nil&#125;func (l *SlidingWindowLimiter) TryAcquire() bool &#123;   l.mutex.Lock()   defer l.mutex.Unlock()   // 获取当前小窗口值   currentSmallWindow := time.Now().UnixNano() / l.smallWindow * l.smallWindow   // 获取起始小窗口值   startSmallWindow := currentSmallWindow - l.smallWindow*(l.smallWindows-1)   // 计算当前窗口的请求总数   var count int   for smallWindow, counter := range l.counters &#123;      if smallWindow &lt; startSmallWindow &#123;         delete(l.counters, smallWindow)      &#125; else &#123;         count += counter      &#125;   &#125;   // 若到达窗口请求上限，请求失败   if count &gt;= l.limit &#123;      return false   &#125;   // 若没到窗口请求上限，当前小窗口计数器+1，请求成功   l.counters[currentSmallWindow]++   return true&#125;\n\n漏桶假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）\n关于漏桶的实现，uber团队有一个开源的 https://github.com/uber-go/ratelimit 实现。使用方法也比较简单，Take() 方法会返回漏桶下一次滴水的时间。\npackage mainimport (    &quot;fmt&quot;    &quot;time&quot;        &quot;go.uber.org/ratelimit&quot;)func main() &#123;    // 限制每秒100次 -&gt; 每隔10ms会放行一个请求    rl := ratelimit.New(100) // per second    prev := time.Now()    for i := 0; i &lt; 10; i++ &#123;        now := rl.Take()        fmt.Println(i, now.Sub(prev))        prev = now    &#125;    // Output:    // 0 0    // 1 10ms    // 2 10ms    // 3 10ms    // 4 10ms    // 5 10ms    // 6 10ms    // 7 10ms    // 8 10ms    // 9 10ms&#125;\n\n之后写一下这个库的详细介绍，在此不多赘述\n令牌桶令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。\n对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。\n实现时，我们不需要真正的每隔一段时间去发放令牌，记录下上次访问时间、上次访问令牌剩余数量，(当前时间-上次访问时间)*令牌生成速度+剩余令牌数得出当前令牌数\n可以参考：https://github.com/juju/ratelimit ，部分代码如下\n// 调整令牌数量func (tb *Bucket) adjustavailableTokens(tick int64) &#123;    lastTick := tb.latestTick    tb.latestTick = tick    if tb.availableTokens &gt;= tb.capacity &#123;        return    &#125;    tb.availableTokens += (tick - lastTick) * tb.quantum    if tb.availableTokens &gt; tb.capacity &#123;        tb.availableTokens = tb.capacity    &#125;    return&#125;// 获取令牌，没有的话返回0，不阻塞(Take方法是会阻塞的)func (tb *Bucket) takeAvailable(now time.Time, count int64) int64 &#123;    if count &lt;= 0 &#123;        return 0    &#125;    tb.adjustavailableTokens(tb.currentTick(now))    if tb.availableTokens &lt;= 0 &#123;        return 0    &#125;    if count &gt; tb.availableTokens &#123;        count = tb.availableTokens    &#125;    tb.availableTokens -= count    return count&#125;func (tb *Bucket) currentTick(now time.Time) int64 &#123;    return int64(now.Sub(tb.startTime) / tb.fillInterval)&#125;\n\n令牌桶算法能满足绝大部分服务器限流的需要, 是被广泛使用的限流算法, 不过其也有一些缺点:\n\n令牌桶是没有优先级的，无法让重要的请求先通过\n如果对服务限流进行缩容和扩容，需要人为手动去修改，运维成本比较大\n令牌桶只能对局部服务端的限流, 无法掌控全局资源\n\n限流的具体使用\n网关限流：可以在nginx处做限流，参考文章 Nginx限流应用 &amp; 漏桶&#x2F;令牌桶算法原理\n服务端限流：以gin框架为例，编写一个限流中间件，加入到需要限流的路由中即可\n自适应限流：结合应用的 Load、CPU 使用率、总体平均 RT(请求成功的响应耗时)、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。如Sentinel\n\n","categories":["技术","web"],"tags":["后端"]},{"title":"IDM 相关记录","url":"/2021-09-22/3e89a69f4d25/","content":"\n今天本来打算补曾经没看完的模电视频来着，看见上面写着还有37天视频到期，于是就突然想到了曾经似乎见到过一个叫IDM的玩意，于是查了查（导致今天晚上就这么没了）\n\nIDM 全称：Internet Download Manager\nWiki 链接在此 ，就不详细介绍了。\n软件功能及使用来自B站的一位up（讲的挺详细的）：https://www.bilibili.com/video/BV1q4411t71E\n对我而言的主要用途\n增大下载速度\n学习通、油管、B站等处视频的下载\n据说曾经搭配百度网盘直链脚本很好用，但是现在基本上要么没了要么压根不能用，所以笔者没在用\n\n踩到的坑总结为什么油管视频会弹出下载链接而B站的不会？\n曾经B站的视频格式是 mp4 ，是可以自动检测的，但是后来变成了 M4S 与 XS 的组合形式，这时就需要我们手动添加一下：IDM -选项-常规-自定义浏览器中的 IDM 下载浮动条，添加 M4S 和 XS 类型文件。\n另外附带一个 M4S 与 XS 合成的小工具：Medlexo_Ultimate（无需安装，简单便捷，还免费）\n\n安装及破解安装的话直接去官网下载，破解的话引用一位大佬的破解工具。\n","categories":["技术","工具介绍"],"tags":["IDM","软件推荐"]},{"title":"Jetbrains 常用快捷键","url":"/2021-11-05/01057ffb7d72/","content":"TBH常用操作\n\n\n\n快捷键组合\n说明\n\n\n\n快速按两次 Shift\n搜索任何一个地方\n\n\nCtrl + Tab\n在 tabs 和工具窗口间切换\n\n\nCtrl + D\n复制当前行或选定的块\n\n\nCtrl + Y\n删除插入符号所在行\n\n\nShift + Enter\n开始新行，比如光标在当前行，不需要切换到行尾按Enter，直接按这个组合键即可\n\n\nCtrl + Shift + ] 或 [\n选择直到代码块的开始或结束，较为有用\n\n\nCtrl + F4\n关闭活动中的tab\n\n\n\n以下为作者的原文：原文链接\n特此记录，以备查找\n\n说明此快捷键说明我是翻译官方的快捷键说明的，方便查看，基于PHPStorm的官方Help来翻译的，其他系列的JetBrains软件应该都是一样的道理，其中如有错误，欢迎斧正。\n编辑\n\n\n\n快捷键组合\n说明\n\n\n\nCtrl + Space\n代码自动完成提示（选择）\n\n\nAlt + Enter\n显示意图动作和快速修复\n\n\nCtrl + P\n参数信息（在调用方法参数忘记的时候，提示）\n\n\nCtrl + Q\n快速查找文件，可以查找当前类定义的文件等\n\n\nCtrl + 鼠标滑过\n基本信息\n\n\nAlt + Insert\n生成代码…(细节需要多次操作会发现很有意思)\n\n\nCtrl + O\n重写方法（在PHPStorm中是重写父类方法，会有选择框）\n\n\nCtrl + I\n实现方法（一般是指实现接口类或抽象类方法）\n\n\nCtrl + Alt + T\n环绕代码块 (if..else, try..catch, for, 等)\n\n\nCtrl + &#x2F;\n单行注释(&#x2F;&#x2F;)\n\n\nCtrl + Shift + &#x2F;\n块注释 (&#x2F;**&#x2F;)\n\n\nCtrl + W\n选择依次递增的代码块，具体使用目前来看比较少\n\n\nCtrl + Shift + W\n去掉当前选择返回上一个选择，类似于撤销选择，与上面的相反\n\n\nCtrl + Alt + L\n格式化代码，一般来说，写的代码格式不整齐统一，这个很有用\n\n\nCtrl + Alt + I\n自啮合线，这个解释不太好解释，测试结果就是会自动根据代码来进行对齐\n\n\nCtrl + D\n复制当前行或选定的块\n\n\nCtrl + Y\n删除插入符号所在行\n\n\nCtrl + Shift + J\n智能线连接（HTML和JavaScript才有用）\n\n\nCtrl + Enter\n智能分割线 (HTML 和 JavaScript 才有用)\n\n\nShift + Enter\n开始新行，比如光标在当前行，不需要切换到行尾按Enter，直接按这个组合键即可\n\n\nCtrl + Shift + U\n切换选中的英文文字的大小写，此处其实用到挺多的\n\n\nCtrl + Shift + ] 或 [\n选择直到代码块的开始或结束，我之前不知道这个，其实很有用\n\n\nCtrl + Delete\n删除从当前光标到当前单词结尾\n\n\nCtrl + Backspace\n从光标位置删除到当前单词的开始\n\n\nCtrl + + 或 –\n这里是ctrl和加号或者减号产生的组合，可以折叠或展开当前代码块\n\n\nCtrl + F4\n关闭活动中的tab\n\n\nCtrl + Shift + V\n从历史粘贴\n\n\n调试\n\n\n\n快捷键组合\n说明\n\n\n\nF8\n跳过\n\n\nF7\n步进\n\n\nShift + F8\n跳出\n\n\nAlt + F8\n表达式求值\n\n\nF9\n恢复程序\n\n\nCtrl + F8\n切断断点\n\n\nCtrl+Shift+F8\n查看断点\n\n\n运行\n\n\n\n快捷键组合\n说明\n\n\n\nShift + F10\n运行\n\n\nShift + F9\n调试\n\n\nCtrl + Shift + F10\n从编辑器运行上下文配置（Run context configuration from editor），此处可能翻译不够准确\n\n\nCtrl + Shift + X\n在命令行运行\n\n\n搜索&#x2F;替换\n\n\n快捷键组合\n说明\n\n\n\nCtrl + F&#x2F;R\n查找&#x2F;替换\n\n\nF3&#x2F;Shift + F3\n查找下一个&#x2F;上一个\n\n\nCtrl + Shift + F&#x2F;R\n在目录中查找&#x2F;替换\n\n\n查找哪些地方使用\n\n\n快捷键组合\n说明\n\n\n\nAlt + F7 &#x2F; Ctrl + F7\n当前文件查找被使用&#x2F;在文件中查找哪些地方使用\n\n\nCtrl + Shift + F7\n文件中搜索并在使用的地方高亮显示\n\n\nCtrl + Alt + F7\n显示哪些地方被使用\n\n\n导航\n\n\n\n快捷键组合\n说明\n\n\n\nCtrl + N\n跳转到指定类\n\n\nCtrl + Shift + N\n跳转到文件\n\n\nCtrl + Alt + Shift + N\n跳转到符号\n\n\nCtrl + G\n跳转到第几行\n\n\nAlt + Right&#x2F;Left\n切换编辑器活动窗\n\n\nEsc\nGo to editor (from tool window)\n\n\nCtrl + E\n弹出最近编辑文件，我也是在写这文档才知道，太方便了\n\n\nCtrl + Alt + Left&#x2F;Right\n导航前进&#x2F;后退\n\n\nCtrl + Shift + Backspace\n跳转到最近编辑的代码位置\n\n\nAlt + F1\n在任何视图中选择当前文件或符号\n\n\nCtrl + B 或 Ctrl + Click\n跳到申明（如跳转到当前函数声明的地方，这个很常用，可以实操一下）\n\n\nCtrl + Alt + B\n与上面相反，跳到执行位置\n\n\nCtrl + Shift + I\n打开快速定义查找\n\n\nCtrl + Shift + B\n跳转到类型声明\n\n\nCtrl + U\n跳到超级方法(super-method)&#x2F;超类 (super-class)\n\n\nAlt + Up&#x2F;Down\n跳转到上一个或者下一个方法，在编辑一个类的时候，方便一个一个的方法进行查看\n\n\nCtrl + ] &#x2F; [\n跳转到代码块的开始或结束\n\n\nF2 &#x2F; Shift + F2\n跳转到上一个或下一个高亮错误地方，这个检查代码语法错误很有用\n\n\nF4 &#x2F; Ctrl + Enter\n编辑源代码&#x2F;查看源代码\n\n\n重构\n\n\n\n快捷键组合\n说明\n\n\n\nF5&#x2F;F6\n复制&#x2F;移动\n\n\nAlt + Delete\n安全删除\n\n\nShift + F6\n重命名\n\n\nCtrl + Alt + N\n内联变量\n\n\nCtrl + Alt + M&#x2F;V&#x2F;F&#x2F;C\n提取方法&#x2F;变量&#x2F;字段&#x2F;常数(Method&#x2F;Variable&#x2F;Field&#x2F;Constant)\n\n\nCtrl + Alt + Shift + T\n重构这段代码（显示所有可用的重构），比如if else if 这种语句转switch语句\n\n\nVCS&#x2F;本地历史\n\n\n\n快捷键组合\n说明\n\n\n\nAlt + 反引号 (&#96;)\n‘VCS’ 快速弹出，此处需要注意这个反引号在最左上角，和那个~符号在一起的，ESC键下面\n\n\nCtrl + K\n提交项目到VCS\n\n\nCtrl + T\n从 VCS 更新项目\n\n\nAlt + Shift + C\n显示最近更改\n\n\n常用操作\n\n\n\n快捷键组合\n说明\n\n\n\n快速按两次 Shift\n搜索任何一个地方\n\n\nCtrl + Shift + A\n查找方法(Action)\n\n\nAlt + #[0-9]\n打开相应的工具窗口（这个我也没搞明白）\n\n\nCtrl + Alt + F11\n开启或关闭全屏模式\n\n\nCtrl + Shift + F12\n开启或关闭最大化编辑\n\n\nAlt + Shift + F\n添加到收藏列表（我觉得这个功能很神奇，不知道为啥要这么做）\n\n\nAlt + Shift + I\n检查当前文件以及当前配置文件\n\n\nCtrl + Alt + S\n打开设置对话框（表示会与QQ默认快捷键冲突）\n\n\nCtrl + Tab\n在 tabs 和工具窗口间切换\n\n\n插入模板&#x2F;片段(针对PHPstorm)\n\n\n\n快捷键组合\n说明\n\n\n\nAlt + J\n插入模板\n\n\neco\n‘echo’ 语句\n\n\nfore\nforeach(iterable_expr as $value) {…}\n\n\nforek\nforeach(iterable_expr as $key &#x3D;&gt; $value) {…}\n\n\ninc&#x2F;inco\n‘include’&#x2F;‘include_once’ 语句\n\n\nprif\nprivate function\n\n\nprof\nprotected function\n\n\npubf\npublic function\n\n\nrqr&#x2F;rqro\n‘require’&#x2F;‘require_once’ 语句\n\n\n更多…\n其他自己尝试\n\n\n","categories":["技术","工具介绍"],"tags":["Jetbrains"]},{"title":"pycharm破解2020.1版本","url":"/2022-02-12/45f494763c67/","content":"pycharm破解2020.1版本：https://www.bilibili.com/read/cv10386031\npycharm社区版写flask好难受，又装回来了\n","categories":["技术","工具介绍"],"tags":["python","pycharm"]},{"title":"MySQL RR隔离级别","url":"/2023-01-07/6f152a5a4087/","content":"以前搞不明白RR不能解决幻读，但是又说RR可以用间隙锁、临界锁、MVCC解决幻读，于是详细捋了一下。简单来说是RR可以通过间隙锁、临界锁、MVCC 解决部分幻读，但不能解决全部的，想要完全解决需要串行化。\n幻读与不可重复读区别“幻读”是指读的过程中，某些元组被增加、删除，这样进行一些集合操作，比如算总数，平均值等等，就会每次算出不一样的数。\n不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同\nRR与RC的区别SQL 标准定义了四个隔离级别：\n隔离级别\nREAD-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\nREAD-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\nREPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\nSERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n区别锁方面的区别显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR\n一致性读RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，也就是每一条select都有自己的一致性读ReadView\n而RR隔离级别时，事务中的一致性读的ReadView是以第一条select语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。\nRC 支持半一致性读，RR不支持\n对比RR隔离级别，update语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合where条件。\n半一致性读的优点：减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率。\n参考文章以前随手做的笔记，忘记记录参考文章了，抱歉\n","categories":["技术","数据库"],"tags":["MySQL"]},{"title":"MySQL不同版本介绍","url":"/2023-01-06/1ddc24eb68f4/","content":"经常听到什么MySQL5.5-5.7、8.0，但是中间的就没咋听说过，今天来探究下这个版本到底是啥情况。\n版号说明以5.5.60这个版本的MySQL为例，说明版本号的每个数字含义(mysql-5.5.60.tar.gz)\n\n第一个数字(5)主版本号：文件格式改动时，将作为新的版本发布\n第二个数字(5)发行版本号：新增特性或者改动不兼容时，发行版本号需要更改\n第三个数字(60)发行序列号：主要是小的改动，如bug的修复、函数添加或更改、配置参数的更改等\n\nMySQL产品线3.X至5.1.X\n这是早期MySQL的版本。常见早期的版本有：4.1.7、5.0.56等。\n5.4.X到5.7.X\n这是为了整合MySQL AB公司社区和第三方公司开发的新存储引擎。吸收新的实现算法，更好的支持SMP架构。为提升性能做了大量代码重构。\nMySQL 在2017年发布了新的版本8.0，但是在此之前的上一个版本是5.7\n早在2008年，Sun收购MySQL AB以前，公司内部已经在进行着版本号6的开发工作了（5.0在2005年发布）。然而，版本6的MySQL制定的目标和计划过于激进，步子迈得有点儿大，随着收购的顺利完成，项目也被砍掉了。 至于版本号7，则是用在了MySQL Cluster上。由于新版的MySQL带来了许多的重大更新，开发者们决定是时候把版本号往前滚动一下了，于是便有了8。\n同时因为7发布时间较晚，发布时已经有其他手段解决MySQL集群技术问题，所以并没有很好的推广使用。\n大版本间的区别5.5\ninnodb 就是从 5.5 这个版本开始成为 默认的存储引擎\n引入了真 UTF8 ——&gt; utf8mb4\n5.5的时候引入了MDL(meta data lock)元数据锁\n\nMySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，一般情况下使用utf8也就够了。\n5.6官方文档：What Is New in MySQL 5.6\n也可以参考MySQL大版本间的区别，不再赘述了\n挑几个说一下：\n\nInnodb 将 flush 刷盘操作从主线程移动到其他线程\nInnodb可以创建 全文索引\n可以用 EXPLAIN 来查看 DELETE，INSERT，REPLACE，UPDATE等 DML 操作的执行计划。在这之前，它只支持 SELECT 操作\n\n5.7同样只挑几个说一下\n\n从MySQL 5.7.8开始，MySQL支持原生JSON类型\n之前：对于触发器事件(INSERT、UPDATE、DELETE)和操作时间(BEFORE、AFTER)的组合，一个表最多只能有一个触发器，即在某个触发时间点只能有一个触发事件现在：允许在某个时间点，有多个触发事件\n由于文件系统 The Fusion-io Non-Volatile Memory (NVM) 在 Linux 上提供了原子操作，这导致 innodb 的 doublewrite 变得冗余，所以在该文件系统上，会自动关闭 doublewrite\n支持多线程来刷新缓冲池中的脏页面\n\n8.0MySQL 8.0是有中文文档的：MySQL 8.0 中的新功能\n挑几个重点的：\n\n索引支持降序排序\n支持正则表达式\n可以为这些类型增加默认值 BLOB、TEXT、GEOMETRY 、 JSON\n从 MySQL 8.0.20 开始，doublewrite 缓冲区存储在 doublewrite 文件中\n不再支持 查询缓存\n\nMySQL8.0为啥删除查询缓存？缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性\nMySQL缓存的限制\n\nMySQL基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表\nSQL必须完全一致才会导致cache命中\n为了节省内存空间，太大的result set不会被cache (小于 query\\_cache\\_limit)\nMySQL缓存在分库分表环境下是不起作用的\n执行SQL里有触发器、自定义函数时，MySQL缓存也是不起作用的\n在表的结构或数据发生改变时，基于该表相关cache立即全部失效\n\n替代方案：应用层组织缓存，最简单的是使用redis，ehcached等\n参考文章\nMySQL版本号6和7去哪了\nMySQL版本详解\nMySQL大版本间的区别\n\n","categories":["技术","数据库"],"tags":["MySQL"]},{"title":"MySQL中datetime与timestamp区别","url":"/2022-07-18/ab5a107cdd1b/","content":"一、占用空间\n\n\n类型\n占据字节\n表示形式\n\n\n\ndatetime\n8 字节\nyyyy-mm-dd hh:mm:ss\n\n\ntimestamp\n4 字节\nyyyy-mm-dd hh:mm:ss\n\n\n二、范围\n\n\n类型\n表示范围\n\n\n\ndatetime\n‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’\n\n\ntimestamp\n‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’\n\n\ntimestamp翻译为汉语即”时间戳”，它是当前时间到 Unix元年(1970 年 1 月 1 日 0 时 0 分 0 秒)的秒数。对于某些时间的计算，如果是以 datetime 的形式会比较困难，假如我是 1994-1-20 06:06:06 出生，现在的时间是 2016-10-1 20:04:50 ，那么要计算我活了多少秒钟用 datetime 还需要函数进行转换，但是 timestamp 直接相减就行。\n三、时区timestamp 会是把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储\ndatetime 不会进行时区的检索\n也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。\n四、默认值如果存进去的是NULL，timestamp会自动储存当前时间，而 datetime会储存 NULL。\n在MySQL 5.6之前的版本，CURRENT_TIMESTAMP只能用于timestamp类型，5.6版本之后，CURRENT_TIMESTAMP也能用于datetime类型了\n所以现在想要设置创建记录时默认为当前时间二者都可\ncreate_time datetime default CURRENT_TIMESTAMP,-- 或者create_time timestamp-- PS 可以使用ON UPDATE CURRENT_TIMESTAMP进行数据更新update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;\n\n二者选择如果在时间上要超过Linux时间的，或者服务器时区不一样的就建议选择 datetime。\n如果是想要使用自动插入时间或者自动更新时间功能的，可以使用timestamp。\n如果只是想表示年、日期、时间的还可以使用 year、 date、 time，它们分别占据 1、3、3 字节，而datetime就是它们的集合。\n参考文章\nMySQL 中 datetime 和 timestamp 的区别与选择\nDATETIME与TIMESTAMP的一些区别与问题\n\n","categories":["技术","数据库"],"tags":["MySQL"]},{"title":"sqlite3开局代码","url":"/2021-08-17/f57bb72cffeb/","content":"sqlite&gt;.header onsqlite&gt;.mode columnsqlite&gt;.timer on\n\n第二行那个代码总是记不住，放到这里记录一下。（就是开启column模式）\n当然也有其他模式：SQLite中.mode的演示说明\n","categories":["技术","数据库"],"tags":["sqlite"]},{"title":"sqlite简单介绍","url":"/2021-09-14/20056ab1d288/","content":"\n暑假对sqlite了解不全面就用了，导致现在有些吃亏，分享下该文章，简单了解sqlite\n转载网址：https://www.modb.pro/db/84640\n\n\n什么是 SQLite\n\n\nSQLite3 可使用 sqlite3 模块与 Python 进行集成。sqlite3 模块是由 Gerhard Haring 编写的。它提供了一个与 PEP 249 描述的 DB-API 2.0 规范兼容的 SQL 接口。您不需要单独安装该模块，因为 Python 2.5.x 以上版本默认自带了该模块。\n\nSQLite有什么优点\n\n\n\n源代码不受版权限制,真正的自由,开源和免费\n无务器,不需要一个单独的服务器进程或者操作的系统\n一个SQLite 数据库是存储在一个单一的跨平台的磁盘文件\n零配置,因为其本身就是一个文件,不需要安装或管理,轻松携带\n不需要任何外部的依赖,所有的操作等功能全部都在自身集成\n轻量级,SQLite本身是C写的，体积很小，经常被集成到各种应用程序中\n\n\nSQLite 的使用场景有哪些\n\n\nimport sqlite3class conndb():    list1=[]    def __init__(self):        self.conn = sqlite3.connect(&#x27;testqqs.db&#x27;) #存在就连接，不存在就创建数据库        self.c = self.conn.cursor() #获取操作数据库的游标    def query_sql(self,sql): #执行select并返回数据的方法        result=self.c.execute(sql)        for res in result:            self.list1.append(res[0])        print(list(set(self.list1)))        self.conn.commit()        self.conn.close()    def execute_sql(self,sql): #执行除select外语句的方法        result=self.c.execute(sql)        print(&quot;the result is:&quot;,result)        if &quot;create table&quot; in str(sql).lower():            print(&quot;Table created successfully&quot;)        else:            print(&quot;the createdb.sql execute is successfully&quot;)        self.conn.commit()        self.conn.close()if __name__==&quot;__main__&quot;:    table1=&#x27;&#x27;&#x27;    create TABLE IF NOT EXISTS table0607(      id  INTEGER   PRIMARY KEY AUTOINCREMENT,        `qq_number` varchar(255) DEFAULT NULL,        `qq_sex` varchar(255) DEFAULT NULL,        `qq_years` varchar(255) DEFAULT NULL,        `qq_injoin_time` varchar(255) DEFAULT NULL,        `qq_say_time` varchar(255) DEFAULT NULL     );    &#x27;&#x27;&#x27;    insert_sql=&quot;INSERT INTO qq_infos (id,qq_number,qq_sex,qq_years,qq_injoin_time,qq_say_time) VALUES (1,&#x27;625888888&#x27;,&#x27;女&#x27;,&#x27;130年&#x27;,&#x27;2015/04/21&#x27;,&#x27;吐槽&#x27;)&quot;    query_sql=&quot;select count(*) from qq_infos&quot;    delete_sql=&quot;delete from qq_infos where id=765&quot;    update_sql=&quot;update qq_infos set qq_number=&#x27;625888888&#x27; where id=1&quot;    db=conndb()    sql=&quot;select qq_number from table0607 where id&gt;4366&quot;    db.execute_sql(table1)    db.query_sql(sql)\n\n\n小型网站，SQLite适用于中小规模流量的网站\n嵌入式设备，SQLite适用于手机, PDA, 机顶盒, 以及其他嵌入式设备. 作为一个嵌入式数据库它也能够很好的应用于客户端程序.\n数据库教学，SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。\n本地应用程序，其单一磁盘文件的特性,并且不支持远程连接,使其适用于本地的应用程序,如PC客户端软件.\n使用示例展示\n\n总结：今天分享的内容，代码示例部分还是需要大家亲自动手实操，学习效果会更好。\n友情提示：“无量测试之道”原创著作，欢迎关注交流，禁止第三方不显示文章来源时转载。更多原创文章请扫码关注查看，合作请联系：&#x5f;&#108;&#111;&#97;&#x64;&#107;&#x65;&#x72;&#110;&#x65;&#108;&#x40;&#x31;&#x32;&#54;&#46;&#x63;&#x6f;m_。\n","categories":["技术","数据库"],"tags":["python","数据库"]},{"title":"IDEA博客模板","url":"/2024-08-17/d360aeb3cc84/","content":"我自己是用hexo写博客的，categories是直接创建了对应的目录，不同目录下放对应分类，例如这个文件就在source\\_posts\\技术\\杂项\\IDEA博客模板.md\n每次创建时都需要手动填写categories，并且要加上code_block_shrink: false让代码默认不折叠，就想着干脆创建个IDEA的模板吧\n---title: $&#123;title&#125;code_block_shrink: falsedate: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;:$&#123;SECOND&#125;categories: #set($trimmedDir = $DIR_PATH.replace(&quot;source/_posts/&quot;, &quot;&quot;))#set($segments = $trimmedDir.split(&quot;/&quot;))#set($segment = &quot;&quot;)#foreach($segment in $segments)  - $&#123;segment&#125;#end---\n\n\n\n","categories":["技术","杂项"]},{"title":"Git socks5 代理设置","url":"/2022-02-08/54e8b9533b97/","content":"# 使用socks5代理（端口根据自己设置的改变，一般是1080，我的是10808）git config --global http.proxy socks5://127.0.0.1:10808git config --global https.proxy socks5://127.0.0.1:10808# 使用http代理git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy\n\n# git强制推送git push -f origin master# git放弃修改，覆盖本地代码git fetch --allgit reset --hard origin/master git pull","categories":["技术","杂项"],"tags":["git"]},{"title":"git命令中的问题","url":"/2021-09-19/4dc6ecbfe6bf/","content":"fatal: unable to access &#x27;https://github.com/TBgHg/vue-manage-system.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054\n\n这个解决办法是从stackoverflow上找到的:\nhttps://stackoverflow.com/questions/9008309/how-do-i-set-git-ssl-no-verify-for-specific-repos-only\nFor a single repo:\n\ngit config http.sslVerify “false”\n\nFor all repo:\n\ngit config –global http.sslVerify “false”\n\n文件大小的上限设置：\ngit config --global http.postBuffer 524288000","categories":["技术","杂项"],"tags":["git","网站搭建"]},{"title":"k8s集群搭建记录","url":"/2023-02-07/60294872c87a/","content":"前言本次环境搭建需要安装三台Centos服务器（一主二从），然后在每台服务器中分别安装docker（18.06.3），kubeadm（1.17.4）、kubelet（1.17.4）、kubectl（1.17.4）程序\n之前配置hadoop集群的时候配置过hosts，设置过免密登录，这里直接拿来用了，参考黑马程序员的配置过程进行配置的\n有个坑需要注意一下，我一开始是登录三个tbh-0001主机，然后免密登录直接切换，同时执行reboot命令可能会造成混乱，所以推荐直接登录三台主机\n环境初始化\n检查操作系统的版本\n\n# 此方式下安装kubernetes集群要求Centos版本要在7.5或之上[root@tbh-0001 ~]# cat /etc/redhat-release CentOS Linux release 7.6.1810 (Core) \n\n\n主机名解析\n\n以前搭建hadoop集群实验时做过了，正好接着用，同时都配置了免密登录\n企业中建议配置DNS服务器\n[root@tbh-0001 ~]# cat /etc/hosts::1\tlocalhost\tlocalhost.localdomain\tlocalhost6\tlocalhost6.localdomain6192.168.0.181\ttbh-0001\ttbh-0001192.168.0.75\ttbh-0003\ttbh-0003192.168.0.105\ttbh-0002\ttbh-0002127.0.0.1\tlocalhost\tlocalhost.localdomain\tlocalhost4\tlocalhost4.localdomain4127.0.0.1\ttbh\ttbh\n\n\n时间同步\n\nkubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间\n企业中建议配置内部的时间同步服务器\n这里三个都要配，我这里用的是xshell的“发送键至所有的会话框”，下面就展示一个了\n# 启动chronyd服务[root@tbh-0001 ~]# systemctl start chronyd# 设置chronyd服务开机自启[root@tbh-0001 ~]# systemctl enable chronyd# chronyd服务启动稍等几秒钟，就可以使用date命令验证时间了[root@tbh-0001 ~]# date\n\n看到三个的输出时间一致证明配置成功\n\n禁用iptables和firewalld服务\n\nkubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则\n# 1 关闭firewalld服务[root@tbh-0001 ~]# systemctl stop firewalld[root@tbh-0001 ~]# systemctl disable firewalld# 2 关闭iptables服务[root@tbh-0001 ~]# systemctl stop iptables[root@tbh-0001 ~]# systemctl disable iptables\n\n\n禁用selinux\n\n selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题\n# 编辑 /etc/selinux/config 文件，修改SELINUX的值为disabled# 注意修改完毕之后需要重启linux服务SELINUX=disabled\n\n\n禁用swap分区\n\nswap分区指的是虚拟内存分区，它的作用是在物理内存使用完之后，将磁盘空间虚拟成内存来使用\n启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备\n但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明\n# 编辑分区配置文件/etc/fstab，注释掉swap分区一行# 注意修改完毕之后需要重启linux服务 UUID=455cc753-7a60-4c17-a424-7741728c44a1 /boot    xfs     defaults        0 0 /dev/mapper/centos-home /home                      xfs     defaults        0 0# /dev/mapper/centos-swap swap                      swap    defaults        0 0\n\n7）修改linux的内核参数\n# 修改linux的内核参数，添加网桥过滤和地址转发功能# 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置:net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1# 重新加载配置[root@tbh-0001 ~]# sysctl -pvm.swappiness = 0net.core.somaxconn = 1024net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_max_syn_backlog = 1024# 加载网桥过滤模块[root@tbh-0001 ~]# modprobe br_netfilter# 查看网桥过滤模块是否加载成功[root@tbh-0001 ~]# lsmod | grep br_netfilterbr_netfilter           22256  0 bridge                151336  1 br_netfilter\n\n\n配置ipvs功能\n\n在kubernetes中service有两种代理模型，一种是基于iptables的，一种是基于ipvs的\n两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块\n# 1 安装ipset和ipvsadm[root@tbh-0001 ~]# yum install ipset ipvsadmin -y# 2 添加需要加载的模块写入脚本文件[root@tbh-0001 ~]# cat &lt;&lt;EOF &gt;  /etc/sysconfig/modules/ipvs.modules#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF# 3 为脚本文件添加执行权限[root@tbh-0001 ~]# chmod +x /etc/sysconfig/modules/ipvs.modules# 4 执行脚本文件[root@tbh-0001 ~]# /bin/bash /etc/sysconfig/modules/ipvs.modules# 5 查看对应的模块是否加载成功[root@tbh-0001 ~]# lsmod | grep -e ip_vs -e nf_conntrack_ipv4\n\n\n重启服务器\n\n上面步骤完成之后，需要重新启动linux系统\n[root@tbh-0001 ~]# reboot\n\n安装docker# 1 切换镜像源[root@tbh-0001 ~]# wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo# 2 查看当前镜像源中支持的docker版本[root@tbh-0001 ~]# yum list docker-ce --showduplicates# 3 安装特定版本的docker-ce# 必须指定--setopt=obsoletes=0，否则yum会自动安装更高版本[root@tbh-0001 ~]# yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y# 4 添加一个配置文件# Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs[root@tbh-0001 ~]# mkdir /etc/docker[root@tbh-0001 ~]# cat &lt;&lt;EOF &gt;  /etc/docker/daemon.json&#123;  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;registry-mirrors&quot;: [&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;]&#125;EOF# 5 启动docker[root@tbh-0001 ~]# systemctl restart docker[root@tbh-0001 ~]# systemctl enable docker# 6 检查docker状态和版本[root@tbh-0001 ~]# docker version\n\n安装kubernetes组件# 由于kubernetes的镜像源在国外，速度比较慢，这里切换成国内的镜像源# 编辑/etc/yum.repos.d/kubernetes.repo，添加下面的配置 [kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg# 安装kubeadm、kubelet和kubectl[root@tbh-0001 ~]# yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y# 配置kubelet的cgroup# 编辑/etc/sysconfig/kubelet，添加下面的配置KUBELET_CGROUP_ARGS=&quot;--cgroup-driver=systemd&quot;KUBE_PROXY_MODE=&quot;ipvs&quot;# 4 设置kubelet开机自启[root@tbh-0001 ~]# systemctl enable kubelet\n\n准备集群镜像# 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看[root@tbh-0001 ~]# kubeadm config images list# 下载镜像# 此镜像在kubernetes的仓库中,由于网络原因,无法连接，下面提供了一种替代方案images=(    kube-apiserver:v1.17.4    kube-controller-manager:v1.17.4    kube-scheduler:v1.17.4    kube-proxy:v1.17.4    pause:3.1    etcd:3.4.3-0    coredns:1.6.5)for imageName in $&#123;images[@]&#125; ; do\tdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName\tdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName \t\tk8s.gcr.io/$imageName\tdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageNamedone\n\n集群初始化下面开始对集群进行初始化，并将node节点加入到集群中\n\n下面的操作只需要在tbh-0001节点上执行即可\n\n# 创建集群[root@tbh-0001 ~]# kubeadm init \\\t--kubernetes-version=v1.17.4 \\    --pod-network-cidr=10.244.0.0/16 \\    --service-cidr=10.96.0.0/12 \\    --apiserver-advertise-address=192.168.0.181\n\n直接kubectl get nodes会报错：The connection to the server localhost:8080 was refused - did you specify the right host or port?，出现这个问题的原因是kubectl命令需要使用kubernetes-admin来运行，上文输出中提示了解决办法：\n# 创建必要文件[root@tbh-0001 ~]# mkdir -p $HOME/.kube[root@tbh-0001 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config[root@tbh-0001 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config# 成功运行[root@tbh-0001 ~]# kubectl get nodesNAME       STATUS     ROLES    AGE    VERSIONtbh-0001   NotReady   tbh-0001   5m7s   v1.17.4\n\n\n下面的操作只需要在node节点上执行即可\n\n在tbh-0001上执行后会输出node节点加入集群所需要输入的命令，直接复制即可\n# 将node节点加入集群[root@tbh-0002 ~]# kubeadm join 192.168.0.181:6443 --token 1p2izv.b6arlpik2red8wyq \\    --discovery-token-ca-cert-hash \\     sha256:514ef66c3a916ef5a9174e3414140d668e24db612ebd24ca068eedcc288d07e1\t# 查看集群状态 此时的集群状态为NotReady，这是因为还没有配置网络插件[root@tbh-0001 ~]# kubectl get nodesNAME       STATUS     ROLES    AGE     VERSIONtbh-0001   NotReady   tbh-0001   8m10s   v1.17.4tbh-0002   NotReady   &lt;none&gt;   11s     v1.17.4tbh-0003   NotReady   &lt;none&gt;   4s      v1.17.4\n\n安装网络插件kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel\n\n下面操作依旧只在tbh-0001节点执行即可，插件使用的是DaemonSet的控制器，它会在每个节点上都运行\n\n# 获取fannel的配置文件[root@tbh-0001 ~]# wget https://raw.githubusercontent.com/coreos/flannel/tbh-0001/Documentation/kube-flannel.ymlvim kube-flannel.yml# 查询image，注释掉第一个留下带mirror的那个即可(换源)# 使用配置文件启动fannel[root@tbh-0001 ~]# kubectl apply -f kube-flannel.yml# 稍等片刻，再次查看集群节点的状态(得等一会儿)[root@tbh-0001 ~]# kubectl get nodesNAME       STATUS   ROLES    AGE   VERSIONtbh-0001   Ready    tbh-0001   21m   v1.17.4tbh-0002   Ready    &lt;none&gt;   13m   v1.17.4tbh-0003   Ready    &lt;none&gt;   13m   v1.17.4\n\n至此，kubernetes的集群环境搭建完成\n服务部署接下来在kubernetes集群中部署一个nginx程序，测试下集群是否在正常工作。\n# 部署nginx[root@tbh-0001 ~]# kubectl create deployment nginx --image=nginx:1.14-alpine# 暴露端口[root@tbh-0001 ~]# kubectl expose deployment nginx --port=80 --type=NodePort# 查看服务状态[root@tbh-0001 ~]# kubectl get pods,serviceNAME                         READY   STATUS              RESTARTS   AGEpod/nginx-6867cdf567-flcfc   0/1     ContainerCreating   0          13sNAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEservice/kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        23mservice/nginx        NodePort    10.99.122.158   &lt;none&gt;        80:31450/TCP   7s# 4 最后访问下部署的nginx服务[root@tbh-0001 ~]# curl 192.168.0.181:31450&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\nk8s部署测试成功！\n","categories":["技术","杂项"],"tags":["k8s"]},{"title":"业务常见词语","url":"/2023-04-17/cd89cb46eb74/","content":"[TOC]\nGit 团队协作中使用的术语比较常用的是WIP、LGTM、CC\n\nWIP   Work in progress, do not merge yet. &#x2F;&#x2F; 开发中\nLGTM Looks good to me. &#x2F;&#x2F; Riview 完别人的 PR ，没有问题\nPTAL Please take a look. &#x2F;&#x2F; 帮我看下，一般都是请别人 review 自己的 PR\nCC Carbon copy &#x2F;&#x2F; 一般代表抄送别人的意思\nRFC  —  request for comments. &#x2F;&#x2F; 我觉得这个想法很好, 我们来一起讨论下\nIIRC  —  if I recall correctly. &#x2F;&#x2F; 如果我没记错\nACK  —  acknowledgement. &#x2F;&#x2F; 我确认了或者我接受了,我承认了\nNACK&#x2F;NAK — negative acknowledgement. &#x2F;&#x2F; 我不同意\n\n技术方面常见的词语\nCS：案例研究（CaseStudy），一般指出现故障后的学习与反思，case可以理解为出现的故障\nOncall：值班\nLB：负载均衡（Load Balancing）\nSLB：服务器负载均衡器（Server Load Balancer）\nDS：分布式存储（Distributed Storage）\nSRE：网站可靠性工程师（Site Reliability Engineer）\nSLO：服务水平目标（Service Level Objective）用于描述和衡量服务质量的手段。SLO 可以是服务质量的各种指标，例如服务可用性、服务性能、服务容错性等等。通常可以基于服务质量的历史数据，对 SLO 进行设定和调整，并通过监测指标变化来检测服务质量是否达到预期的 SLO 水平，及时发现和排查异常，以确保服务一直保持高水平的稳定性和可靠性，同时也是评估服务质量表现的重要指标。\nXSS：跨站脚本攻击（Cross-Site Scripting）\nCSRF：跨站请求伪造（Cross-Site Request Forgery）\nAgile：敏捷开发（Agile Software Development）的缩写，是一种以迭代、循序渐进的方式进行软件开发的方法论\n\nPM、RD、QA、OP 角色\nPM: Product Manager，产品经理，又称品牌经理。举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控。\nRD: Research and Development engineer，研发工程师，对某种不存在的事物进行系统的研究和开发并具有一定经验的专业工作者,或者对已经存在的事物进行改进以达到优化目的的专业工作者。 \nQA: Quality Assurance，品质保证。QA的主要职责就是质量保证工作。\nOP: Operator，操作员，管理员。\n\n技术ownerowner是临时授予的负责人，负责主导某个项目某个端(后端或者前端)的整体工作。\n对内\n\n关键模块技术分析、设计、开发；\n切分开发任务且制定任务优先级和提测节奏；\n关注组员开发进度，如果有出现不能按时开发联调的，要立刻帮忙处理；\n解决开发过程中，组员提出的各种疑难杂症；\n\n对外\n\n保护模块内成员，尽量使得只有自己与外部（测试、大数据、pmo、产品）对接，让组员集中精力做业务开发；\n跟踪开发联调进度；\n关注【开发环境】的稳定性，随时介入解决；\n关注整个模块bug数，日清bug；\n辅助测试人员上线，且成功上线后，要关注上线的功能是否稳定；\n\nOKROKR是目标管理工具，KPI是绩效管理工具。\n\nOKR侧重过程管理，自我驱动。而KPI更多是围绕目标考核。\nOKR是透明可视化的，人人可看见。同时OKR更多服务创新、挑战性目标，可以与KPI互补。\nOKR突出团队合作，共同达成目标。KPI偏向考核个人贡献。\n\nOKR的具体运用\n\nOKR中的O是定性的，KR是完成OBJECTIVE的具体事件，需要符合SMART原则。\nOKR中的O是透明的，但遇到具体商业保密性质的事件，也是可以进行脱敏，比如进行查看权限限制或者是数字脱敏\nOKR中的KR是动态调整的，比如O发生了变化或者是客观环境导致了KR无法执行\n\n整体每个员工的OKR，第一是支撑领导（拆解领导的O或者是认领上级的KR），第二是指引下属，第三是协助跨团队打通\n整体OKR管理上，可以按照 达成共识（制定OKR）- 日常跟进（进度管理）- 整体复盘来进行。\n降级 熔断 限流出处：作者 yes的练级攻略   链接：https://juejin.cn/post/6844903838231576589  \n降级降级也就是服务降级，当我们的服务器压力剧增为了保证核心功能的可用性 ，而选择性的降低一些功能的可用性，或者直接关闭该功能。这就是典型的丢车保帅了。 就比如贴吧类型的网站，当服务器吃不消的时候，可以选择把发帖功能关闭，注册功能关闭，改密码，改头像这些都关了，为了确保登录和浏览帖子这种核心的功能。\n一般而言都会建立一个独立的降级系统，可以灵活且批量的配置服务器的降级功能。当然也有用代码自动降级的，例如接口超时降级、失败重试多次降级等。具体失败几次，超时设置多久，由你们的业务等其他因素决定。开个小会，定个值，扔线上去看看情况。根据情况再调优。\n熔断降级一般而言指的是我们自身的系统出现了故障而降级。而熔断一般是指依赖的外部接口出现故障的情况断绝和外部接口的关系。\n例如你的A服务里面的一个功能依赖B服务，这时候B服务出问题了，返回的很慢。这种情况可能会因为这么一个功能而拖慢了A服务里面的所有功能，因此我们这时候就需要熔断！即当发现A要调用这B时就直接返回错误(或者返回其他默认值啊啥的)，就不去请求B了。我这还是举了两个服务的调用，有些那真的是一环扣一环，出问题不熔断，那真的是会雪崩。\n当然也有人认为熔断不就是降级的一种的，我觉得你非要说熔断也属于一种降级我也没法反驳，但是它们本质上的突出点和想表达的意思还是有一些不同的。\n那什么时候熔断合适呢？也就是到达哪个阈值进行熔断，5分钟内50%的请求都超过1秒？还是啥？参考降级。\n限流上面说的两个算是请求过来我们都受理了，这个限流就更狠了，直接跟请求说对不起再见！也就是系统规定了多少承受能力，只允许这么些请求能过来，其他的请求就说再见了。\n一般限制的指标有：请求总量或某段时间内请求总量。\n请求总量：比如秒杀的，秒杀100份产品，我就放5000名进来，超过的直接拒绝请求了。\n某段时间内请求总量：比如规定了每秒请求的峰值是1W，这一秒内多的请求直接拒绝了。咱们下一秒再见。\nUGC、PGC、OGC参考文章\n概念\nUGC：User-Generated Content，用户生产内容，泛指以任何形式在网络上发表的由用户创作的文字、图片、音频、视频等内容，它的发布平台包括微博、博客、视频分享网站、维基、在线问答、SNS 等社会化媒体。\nPGC：Professionally-generated Content，专业生产内容， 生产创作主体是由专业精英构成，其发展历程早于 UGC，生产程序偏向专业性，内容质量可控性更强，对生产者知识背景和专业资质的要求较高。\nOGC：Occupationally-generated Content，即职业生产内容，指主要通过具有一定知识和专业背景的行业人士生产内容，并且这些人会领取相应的报酬（如部分新闻网站雇佣的内容编辑）\n\n目前又出现了AIGC，顾名思义，AI所产出的内容\n区别UGC和PGC的区别是有无专业的学识、资质，PGC的生产创作主体在所共享内容的领域具有一定的知识背景和工作资历，UGC则没有。\nPGC和OGC以是否领取相应报酬作为分界。PGC的生产创作主体往往是出于“爱好”，义务的贡献内容，不收取报酬；而OGC是以职业为前提，其创作内容属于职务行为，获取报酬。\nUGC和OGC没有交集。在一个平台（网站）上，用户和提供商总是相对的，既是该平台的用户也是该平台的提供商的角色可能有，但属于极少的群体。\nPUGCPUGC (Professional User Generated Content)，即专业用户生产内容，以UGC形式产出的相对接近PGC的专业内容。PUCC模式是UGC、PGC模式发展中逐渐演化出的一种全新生产模式，率先由国内数字音频领域提出，后延伸到视频内容生产领域，被认为是“互联网短视频长远发展的趋势”。PUGC短视频既满足了用户对专业化、高品质内容的需求，又达到了贴近性且个性化的效果，满足了短视频用户的多种需求，极大程度提升了短视频平台内容的品味。You Tube与B站目前是全球PUGC较为集中的社交型视内容网站，其中B站已经在内容战略上明确转向“建设PUGV( Professional User Generated Viden)社区”。\n盲审盲审是一种评审方式，就像考试时老师不知道你的名字一样。\n在盲审过程中，评审者或审查者不知道作者或制作者的身份，只能根据作品本身的质量、内容和结构来做出评价或决定是否通过审查。这种方式可以保证评审或审查的公正性和客观性，通常用于学术、出版、电影等领域。\n盲审有单盲和双盲两种形式，单盲是评审者不知道作者的身份，双盲是作者和评审者都不知道对方的身份。\n","categories":["技术","杂项"],"tags":["业务"]},{"title":"假设知道服务器IP，如何查询它绑定的域名？","url":"/2021-09-13/3871e672fe5a/","content":"假设知道服务器IP，如何查询它绑定的域名？\n【转载】\n\n在一些场景中，我们往往只得到了一个IP地址，那么如何通过IP地址快速地找到它绑定的域名呢？\n1、IP历史解析记录\n输入查询的IP地址，获取IP绑定过的域名记录。\nip138查询：https://site.ip138.com/\n\n2、同站&#x2F;旁站查询\n关键词：IP反查域名、同IP网站查询、旁站查询，通过一些在线查询工具获取域名。\nIP反查域名：\nhttps://dns.aizhan.com/=https://www.yougetsignal.com/tools/web-sites-on-web-server/https://tools.ipip.net/ipdomain.php?ip=x.x.x.x\n\n同IP网站查询：\nhttp://s.tool.chinaz.com/samehttps://www.webscan.cc/search/\n\n查旁站：\nhttps://chapangzhan.comhttps://phpinfo.me/bing.php\n\n3、通过证书反查域名\n部分Web服务端口使用了SSL证书，比如访问443端口显示404错误（因非域名访问，所以证书会显示不安全），查看证书可获取域名相关信息。\n\n4、网站信息收集\n通过服务器开放的web应用，如80、443等，根据网站的title、keywords等关键词，通过搜索引擎找到站点域名。\n5、网络空间安全引擎搜索\n通过网络空间安全引擎搜索IP地址，快速获取IP地址相关信息，进一步找到网站域名。\nzoomeye(钟馗之眼)：https://www.zoomeye.orgshodan：https://www.shodan.ioFofa：https://fofa.soCensys：https://censys.io/ipv4/Dnsdb搜索引擎：https://www.dnsdb.io\n\n本文由Bypass整理发布，转载请保留出处。\n","categories":["技术","杂项"],"tags":["网站搭建"]},{"title":"关于“expected ';', ',' or ')' before '&' token”错误","url":"/2022-03-30/2cf6703aefa4/","content":"在GCC编译器上：出现该错误的主要原因是：在C语言里没有C++所谓的“按引用传递”，例如C++可以写这样一个函数：\nvoid func(int &amp;a)&#123;//函数功能&#125;\n\n在C语言无法这样使用，所以需要改为地址引用：\nvoid func(int *a)&#123;//函数功能&#125;\n\n具体调用该函数时候就修改为：\nint num=10;//......func(&amp;num);//......","categories":["技术","杂项"],"tags":["C"]},{"title":"wordpress博客搭建记录","url":"/2021-07-11/bc99b0764be8/","content":"记录一下自己的博客搭建流程。\n1.购买服务器笔者选用了阿里云的ECS服务器\n2.开放端口因为笔者是使用宝塔进行搭建，所以需要先开放服务器的8888端口\n3.在服务器上配置宝塔面板配置宝塔面板（参考文章）以centos为例：\nyum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh\n\n4.部署wordpress在宝塔中具有一键部署wordpress功能，直接进行部署即可\n5.选择合适的主题可以选用官方的主题，也可以在github等处寻找更适合自己的主题，在此笔者选用了 Argon\n6.安装合适的插件安装一些必要的插件可以使我们的网站具备更为强大的功能，获取更为舒适的体验。笔者安装的插件有以下：\nAll-in-One WP Migration所有博客数据的迁移工具。 只需点击一下即可导入或导出您的博客内容。\nSimple Local Avatars添加一个头像上传字段到用户个人资料。像Gravatar一样按需生成头像尺寸，简单而轻便。\nWP Mail SMTP by WPFormsWordPress 电子邮件 SMTP 寄件插件（发送邮件）\nLogin Designer完全定制WordPress登录页面的最简单方法。创建惊人的登录模板在几秒钟内与最美丽和优雅的登录自定义WordPress插件。\n当然还用很多很好用的插件，在此就不列举了，可自行查阅\n7.调整网站页面自定义网站页面，是网站页面更为美观\n8.调整安全配置，只允许特定IP访问该网站如果说想要设置仅校园网访问等一些功能的时候我们可以通过调整安全配置进行时实现\n9.备案在购买服务器的地方备案就行，一般7、8天那种\n10.SSL证书申请证书，然后到宝塔上面部署，下面给大家排个雷：\n\n这里是限制了大小，看了一下打码的这个conf，里面有一行ssl_session_cache    shared:SSL:1m;注释掉重启nginx就可以了。\n","categories":["技术","杂项"],"tags":["网站搭建"]},{"title":"字符编码部分总结","url":"/2021-10-24/da3ad2e3fe8a/","content":"慢慢补充吧，先记录一些。\n字符编码以及问题的起源先是来自百度大佬的发言（原文链接）\n先从字符编码讲起。\n\n美国人首先对其英文字符进行了编码，也就是最早的ascii码，用一个字节的低7位来表示英文的128个字符，高1位统一为0；\n后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。欧美人就是喜欢直来直去，字符少，编码用得位数少；\n但是即使位数少，不同国家地区用不同的字符编码，虽然0–127表示的符号是一样的，但是128–255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号；\n更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧。\n这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，尼玛显示都是乱码啊。为了统一，于是就发明了unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。\n然而，unicode虽然统一了全世界字符的二进制编码，但没有规定如何存储啊，亲。x86和amd体系结构的电脑小端序和大端序都分不清，别提计算机如何识别到底是unicode还是acsii了。如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。\n互联网的兴起，网页上要显示各种字符，必须统一啊，亲。utf-8就是Unicode最重要的实现方式之一。另外还有utf-16、utf-32等。UTF-8不是固定字长编码的，而是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。这是种比较巧妙的设计，如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。\n注意unicode的字符编码和utf-8的存储编码表示是不同的，例如”严”字的Unicode码是4E25，UTF-8编码是E4B8A5，这个7里面解释了的，UTF-8编码不仅考虑了编码，还考虑了存储，E4B8A5是在存储识别编码的基础上塞进了4E25。\nUTF-8 使用一至四个字节为每个字符编码。128 个 ASCII 字符（Unicode 范围由 U+0000 至 U+007F）只需一个字节，带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及马尔代夫语（Unicode 范围由 U+0080 至 U+07FF）需要二个字节，其他基本多文种平面（BMP）中的字符（CJK属于此类-Qieqie注）使用三个字节，其他 Unicode 辅助平面的字符使用四字节编码。\n最后，要回答你的问题，常规来看，中文汉字在utf-8中到底占几个字节，一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 1 0xxxxxx。\n\nUnicode、ASCII 以及 UTF-8 的比较然后是廖雪峰老师的发言（原文链接）\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n字母A用ASCII编码是十进制的65，二进制的01000001；\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&#39;0&#39;和整数0是不同的；\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：\n\n\n\n字符\nASCII\nUnicode\nUTF-8\n\n\n\nA\n01000001\n00000000 01000001\n01000001\n\n\n中\nx\n01001110 00101101\n11100100 10111000 10101101\n\n\n从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n简单的一个小整理，廖老师写的还是非常全的（后面还有很多）\npython编码原理还是廖老师的那篇文章，写的挺全的（原文链接）\n另外还有一篇文章也很好：吐血总结，彻底明白 python3 编码原理\n锟斤拷，烫烫烫锟斤拷如果我们想要用Unicode编码记录一些文本，特别是一些遗留的老字符集内的文本，但是这些字符在Unicode中可能并不存在。于是，Unicode会统一把这些字符记录为U+FFFD这个编码\n如果用UTF-8的格式存储下来，就是\\xef\\xbf\\xbd。如果连续两个这样的字符放在一起，\\xef\\xbf\\xbd\\xef\\xbf\\xbd，这个时候，如果程序把这个字符，用GB2312的方式进行decode，就会变成“锟斤拷”。这就好比我们用GB2312这本密码本，去解密别人用UTF-8加密的信息，自然没办法读出有用的信息。\n烫烫烫“烫烫烫”，则是因为如果你用了Visual Studio的调试器，默认使用MBCS字符集\n“烫”在里面是由0xCCCC来表示的，而0xCC又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。\n后记GB2312、GBK、GB18030-2000什么的没整合，改天补充吧。\nps：这个老大哥说的也很不错（链接）\n","categories":["技术","杂项"],"tags":["字符编码"]},{"title":"开发环境区别","url":"/2023-03-03/ccb54946dea5/","content":"\n目标：了解FAT, UAT, PRE, PROD环境的区别\n\n\nFAT (Feature Acceptance Test environment) : 功能验收测试环境，用于软件测试者测试使用\nUAT(User Acceptance Test environment): 用户验收测试环境，用于生产环境下的软件测试者测试使用\nPRE ：灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样，外部用户可以访问，版本发布初期，正式版本发布前\nPROD（Production environment）：生产环境，面向外部用户的环境，正式环境，连接上互联网即可访问\n\n补充：\n\nSIT(System Integration Test ): 系统集成测试，开发人员自己测试流程是否走通\nTEST: 测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定\nDEV （Development environment） ： 开发环境，外部用户无法访问，开发人员使用，版本变动很大\n\n\n什么是CI&#x2F;CD\n\n\nCI：持续集成（CONTINUOUS INTEGRATION）\nCD：持续部署（CONTINUOUS DEPLOYMENT）\nCD：持续交付（CONTINUOUS DELIVERY）\n\n持续集成（Continuous Integration）简称CI，持续集成强调开发人员提交了新代码之后，立刻自动的进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 \n持续部署（Continuous Deployment）  代码通过评审之后，自动部署到生产环境中。持续部署是持续交付的最高阶段。  强调  1、持续部署是自动的  2、持续部署是持续交付的最高阶段  3、持续交付表示的是一种能力，持续部署则是一种方式\n参考文章\n\n环境整理（pro、sit、uat、test、pre、dev、fat ）\n软件运维开发过程中常用的名称解释DEV、FAT 、UAT、PRO 、CI、CD\n\n","categories":["技术","杂项"],"tags":["开发环境"]},{"title":"远程桌面与内网穿透","url":"/2021-09-29/6b9e32226583/","content":"Win10 家庭版如何启用远程桌面服务\n内网穿透工具“39nat”的使用教程\n在自己电脑上设置开机自启动39nat\n如何使用远程桌面连接CentOS 8\n内网穿透没有在自己的服务器上弄，自己的服务器带宽太低，弄了也卡，等以后换了服务器再弄吧。\n","categories":["技术","杂项"],"tags":["远程桌面"]},{"title":"Go ACM模式处理输入输出","url":"/2023-08-01/ec40e5e5fa07/","content":"背景面试时ACM模式较多，力扣以核心代码模式为主，特地训练下ACM模式处理输入输出\n推荐阅读\nACM模式较好的练习地点：https://kamacoder.com/\nGolang常规处理输入输出：https://blog.csdn.net/weixin_44211968/article/details/124632136\nbufio处理输入输出：https://www.acwing.com/blog/content/28740/\n\n举例在此用洛谷中的一道题说明一下：P1886 滑动窗口 &#x2F;【模板】单调队列\n使用常规输入输出：\npackage mainimport (\t&quot;fmt&quot;\t&quot;strings&quot;)func main() &#123;\tvar n, k int\tfmt.Scanln(&amp;n, &amp;k)\tlist := make([]int, n)\tfor i := 0; i &lt; n; i++ &#123;\t\tfmt.Scan(&amp;list[i])\t&#125;\tmax, min := slidingWindow(list, k)\t// 直接for循环输出也可\tfmt.Println(strings.Trim(fmt.Sprint(min), &quot;[]&quot;))\tfmt.Println(strings.Trim(fmt.Sprint(max), &quot;[]&quot;))&#125;func slidingWindow(list []int, k int) (max, min []int) &#123;\tvar maxWindow, minWindow []int\t// 单调递减队列\tmaxPush := func(i int) &#123;\t\tfor len(maxWindow) &gt; 0 &amp;&amp; list[maxWindow[len(maxWindow)-1]] &lt; list[i] &#123;\t\t\tmaxWindow = maxWindow[:len(maxWindow)-1]\t\t&#125;\t\tmaxWindow = append(maxWindow, i)\t&#125;\t// 单调递增队列\tminPush := func(i int) &#123;\t\tfor len(minWindow) &gt; 0 &amp;&amp; list[minWindow[len(minWindow)-1]] &gt; list[i] &#123;\t\t\tminWindow = minWindow[:len(minWindow)-1]\t\t&#125;\t\tminWindow = append(minWindow, i)\t&#125;\tfor i := 0; i &lt; k; i++ &#123;\t\tmaxPush(i)\t\tminPush(i)\t&#125;\tmax = append(max, list[maxWindow[0]])\tmin = append(min, list[minWindow[0]])\tfor i := k; i &lt; len(list); i++ &#123;\t\tmaxPush(i)\t\tminPush(i)\t\t// 删除超出窗口的部分\t\tfor maxWindow[0] &lt; i-k+1 &#123;\t\t\tmaxWindow = maxWindow[1:]\t\t&#125;\t\tfor minWindow[0] &lt; i-k+1 &#123;\t\t\tminWindow = minWindow[1:]\t\t&#125;\t\tmax = append(max, list[maxWindow[0]])\t\tmin = append(min, list[minWindow[0]])\t&#125;\treturn&#125;\n\n结果就是有三个超时，其他通过，可自行尝试\n分析下原因，每次fmt.Scan时都会进行一次系统调用，如果N较大，那时间开销相对就比较大，我们可以使用bufio库将数据直接读取到缓存中，整体只需要一次系统调用，时间开销要小很多\n相应的，输出时如果我们选择for循环每次print一个数据，那时间开销也会很长，但将数据通过strings.Trim(fmt.Sprint(min), &quot;[]&quot;)处理好之后再输出，总共两次fmt.Println系统开销要小很多。同时我们也可以把结果放到缓冲区中，再通过Flush将数据写出\n我们先来看处理输入：\nimport (\t&quot;bufio&quot;\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;strings&quot;)func main() &#123;\tvar n, k int\tfmt.Scanln(&amp;n, &amp;k)\tlist := make([]int, n)\t//fmt.Scanf(&quot;%d %d/n&quot;, &amp;n, &amp;k)\t// os.Stdin标准输入，写入到缓存中\tin := bufio.NewReader(os.Stdin)\t// os.Stdout标准输出\t// out := bufio.NewWriter(os.Stdout)\t// 从缓存中读取数据\tfor i := 0; i &lt; n; i++ &#123;\t\tfmt.Fscan(in, &amp;list[i])\t&#125;\tmax, min := slidingWindow(list, k)\tfmt.Println(strings.Trim(fmt.Sprint(min), &quot;[]&quot;))\tfmt.Println(strings.Trim(fmt.Sprint(max), &quot;[]&quot;))  return&#125;\n\n修改后，所有数据点可通过\n我们再来看下输出，这时我们用了两次fmt.Println，也就是会进行两次系统调用，那我们如果将结果写入输出的缓存中，最后os.Flush是不是可以对时间进一步优化呢，原则上是这样的：\nfunc main() &#123;\tvar n, k int\tfmt.Scanln(&amp;n, &amp;k)\tlist := make([]int, n)\t//fmt.Scanf(&quot;%d %d/n&quot;, &amp;n, &amp;k)\tin := bufio.NewReader(os.Stdin)\tout := bufio.NewWriter(os.Stdout)\tfor i := 0; i &lt; n; i++ &#123;\t\tfmt.Fscan(in, &amp;list[i])\t&#125;\tmax, min := slidingWindow(list, k)\t//fmt.Println(strings.Trim(fmt.Sprint(min), &quot;[]&quot;))\t//fmt.Println(strings.Trim(fmt.Sprint(max), &quot;[]&quot;))\t// 将数据处理好后，写入out缓存中\tfmt.Fprint(out, fmt.Sprint(strings.Trim(fmt.Sprint(min), &quot;[]&quot;)+&quot;\\n&quot;+strings.Trim(fmt.Sprint(max), &quot;[]&quot;)))\t// 将缓存中的数据刷新到io.Writer\tout.Flush()  return&#125;\n\n最后的运行结果是有一个点报MLE了（按照第二种写法，那个点是100.16MB）\n这个也比较好理解，对于数据量比较变态的情况，及时将数据输出，可以预防MLE，所有结果合起来再输出，就有可能会超出规定内存\n当然，输入也有可能会超出默认缓存大小，这个时候需要根据实际情况进行调整，例如 https://www.acwing.com/blog/content/28740/ 中提到的：\n特殊场合 当一次输入超大时：3302. 表达式求值\n将输入缓存设置为20000 * 1024\nin = bufio.NewScanner(os.Stdin)bs = make([]byte, 20000 * 1024)in.Buffer(bs, len(bs))","categories":["技术","算法"],"tags":["go","算法"]},{"title":"leetcode 打家劫舍 II 评论探讨","url":"/2022-08-27/c22def41b5d6/","content":"笔者打家劫舍时碰见碰见了个问题，记录一下，leetcode上的\n题目：213. 打家劫舍 II\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。&amp;nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。输入：nums = [1,2,3]输出：3\n\n这题官方给出的解法如下：假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2] [0,n−2]；如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1, n-1] [1,n−1]。在确定偷窃房屋的下标范围之后，即可用第 198 题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 n 间房屋中可以偷窃到的最高总金额。\n评论区有个发言：感觉有点问题。如果把所有情况分为偷窃第一间房和偷窃最后一间房逻辑上有点说不过去。因为，当偷窃第一间房的时候，官方解答将问题转化为了[0, n-1]求最大收益的问题，这显然并没有保证第一间房被偷，和最开始的假设相矛盾。我觉得问题出在把所有情况分为偷窃第一间房和偷窃最后一间房这里。事实上，有可能存在两个房间都不偷的情况，如[1,10000,1]。更严谨地说，应该把问题分为可以偷第一件房和可以偷最后一件房这两种情况。不可能有这两种情况之外的第三种情况。当可以偷第一间房的时候，我们当然可以理直气壮地把问题转换为[0, n-1]求最大收益的问题。\n一开始觉得很有道理，认为是官方这里出了些问题，后来发现俩好像在各说个的，所以都对。\n首先题目的解肯定是第一间和最后一间至少有一个没偷，而官方给出的确实是这样，分为了不偷最后一间、不偷第一间，那这里得出的最优解肯定就是答案，当然也有人用集合的方式给出了补充证明。而评论的话似乎把官方误认为分为偷第一间、不偷第一间这种了，所以觉得官方少了第一间和最后一间都不偷。\n好家伙，算法题我咋在这里分析语文了。行了，不说了，接着刷去了\n","categories":["技术","算法"],"tags":["算法"]},{"title":"剑指Offer II 刷题笔记（1）","url":"/2022-11-06/1210bedfc8b5/","content":"目前是二刷阶段，记录一下刷题的思路，记录下重点，方便以后复习，目前还没写多少，持续补充\n整数整数这里主要是位运算，常见知识点：\n\n对于一个数num，num &gt;&gt; i &amp; 1表示取第i位上的二进制值\n设置ans二进制的第i位一般或运算：ans = 1 &lt;&lt; i\n异或两次后会自己抵消掉，相当于没干\n\n004 只出现一次的数字一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n\n1 &lt;= nums.length &lt;= 3 * 104\n-2^31 &lt;= nums[i] &lt;= 2^31 - 1\n\n方法一：map遍历 func singleNumber(nums []int) int &#123;    freq := map[int]int&#123;&#125;    for _, v := range nums &#123;        freq[v]++    &#125;    for num, occ := range freq &#123;        if occ == 1 &#123;            return num        &#125;    &#125;    return 0 // 不会发生，数据保证有一个元素仅出现一次&#125;\n\n\n时间复杂度：O(n)，其中 n 是数组的长度\n空间复杂度：O(n)\n\n方法二：依次确定二进制位最先想到的肯定是和3做一些变换，如果看每一个二进制的话，加起来然后与3取余，最后汇总就行了go的话不像python，是不是有符号自己能定义，这点注意一下就行了\nfunc singleNumber(nums []int) int &#123;    ans := int32(0)    for i := 0; i &lt; 32; i++ &#123;        total := int32(0)        for _, num := range nums &#123;            total += int32(num) &gt;&gt; i &amp; 1        &#125;        if total%3 &gt; 0 &#123;            ans = 1 &lt;&lt; i        &#125;    &#125;    return int(ans)&#125;\n\n005 单词长度的最大乘积给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。\n很怪的题目，不过可以发现只包含小写字母，但是map又不太行，那就考虑位运算，把他们对应的整数做个&amp;\nfunc maxProduct(words []string) (ans int) &#123;    masks := make([]int, len(words))    for i, word := range words &#123;        for _, ch := range word &#123;            masks[i] = 1 &lt;&lt; (ch - &#x27;a&#x27;)        &#125;    &#125;    for i, x := range masks &#123;        for j, y := range masks[i:] &#123;            if x&amp;y == 0 &amp;&amp; len(words[i])*len(words[j]) &gt; ans &#123;                ans = len(words[i]) * len(words[j])            &#125;        &#125;    &#125;    return ans&#125;\n\n006 排序数组中两个数字之和给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target整数数组的形式返回答案，数组里放对应下标，增大的顺序假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次\n输入：numbers = [1,2,4,6,10], target = 8输出：[1,3]解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 \n\n方法一：map只有一对符合要求，遇事不决，map解决，但空间O(n)，并且数组已经排序而没用好这个性质\n方法二：双指针头(low)尾( `heigh)一块出发，二者的和记为sum，如果比target小，low++，大的话heigh--，相等直接输出。for循环条件是low&lt;heigh比较难考虑的是会不会错过去，可以这样想，反正low和heigh肯定会有第一个先到答案的位置，这个时候另一个必须根据sum和target的比较做配合，最后肯定能到相应的地方。\nfunc twoSum(numbers []int, target int) []int &#123;    low, high := 0, len(numbers) - 1    for low &lt; high &#123;        sum := numbers[low] + numbers[high]        if sum == target &#123;            return []int&#123;low, high&#125;        &#125; else if sum &lt; target &#123;            low++        &#125; else &#123;            high--        &#125;    &#125;    return []int&#123;-1, -1&#125;&#125;\n\n方法三：二分查找时间复杂度：O(nlog⁡n)，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 O(n)，寻找第二个数使用二分查找，时间复杂度是 O(log⁡n)空间复杂度：O(1)\n复杂度这块不如双指针，主要还是练习一下二分，目前不细说二分\nfunc twoSum(numbers []int, target int) []int &#123;    for i := 0; i &lt; len(numbers); i++ &#123;        low, high := i + 1, len(numbers) - 1        for low &lt;= high &#123;            mid := (high - low) / 2 + low            if numbers[mid] == target - numbers[i] &#123;                return []int&#123;i, mid&#125;            &#125; else if numbers[mid] &gt; target - numbers[i] &#123;                high = mid - 1            &#125; else &#123;                low = mid + 1            &#125;        &#125;    &#125;    return []int&#123;-1, -1&#125;&#125;\n\n数组这块就要寄出我曾经总结的东西了：算法总结——数组，当初打算给大一写的，但似乎没啥人看，不过个人感觉很全面，主要参考的代码随想录\n数组主要知识点：\n\n二分查找（莫得办法，多练）\n前缀和（一维二维）：计算给定区间的和\n差分（一维二维）：某一特定范围内的所有值都加上或减去一个常数\n双指针\n滑动窗口\n螺旋矩阵（就是跟着逻辑来）\n\n建议先看我的算法总结(・∀・)ノ\n007 数组中和为 0 的三个数【典型的双指针】\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n\n思路：先排序，固定一个，另外俩双指针。\n注意点：\n\n但是固定的那个需要考虑去重，去重为了防止把之后的撅了，可以去和前一个比较\n因为双指针遍历时碰到的答案不止一个，所以碰到正解后装入ans，left++（right–也行，反正就是离开舒适区），但是因为要去重，所以for l &lt; r &amp;&amp; nums[l] == n2内进行l++（n2指之前的nums[l]）\n\nfunc threeSum(nums []int) (ans [][]int) &#123;    sort.Ints(nums)    for i := 0 ; i &lt; len(nums)-2 ; i++ &#123;        if nums[i] &gt; 0 &#123;            continue        &#125;        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123;            continue        &#125;        l,r := i+1,len(nums)-1        n1 := nums[i]        for l&lt;r &#123;            n2,n3 := nums[l],nums[r]            sum := n1+n2+n3            if sum == 0 &#123;                ans = append(ans,[]int&#123;n1,n2,n3&#125;)                for l &lt; r &amp;&amp; nums[l] == n2 &#123;                    l++                &#125;            &#125; else if sum &gt; 0 &#123;                r--            &#125; else &#123;                l++            &#125;        &#125;    &#125;    return&#125;\n\n008 和大于等于 target 的最短子数组给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n二分查找算法总结——数组，当初总结的，二分查找模块挺细的\nleft&lt;right时，一般left=mid+1，right=mid，而不是left=mid，right=mid-1，要不容易出现死循环\n068 查找插入位置给定一个排序的整数数组 nums 和一个整数目标值target ，请在数组中找到 target，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\nfunc searchInsert(nums []int, target int) int &#123;    left, right := 0, len(nums)-1    mid := (left + right) / 2    for left &lt;= right &#123;        if nums[mid] == target &#123;            return mid        &#125; else if nums[mid] &lt; target &#123;            left++        &#125; else &#123;            right--        &#125;        mid = (left + right) / 2    &#125;    return left&#125;\n\n069 山峰数组的顶部符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：\n\narr.length &gt;= 3\n存在i(0 &lt; i &lt; arr.length - 1)\narr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]\narr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]\n\n给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。\n\n3 &lt;= arr.length &lt;= 104\n0 &lt;= arr[i] &lt;= 106\n题目数据保证 arr 是一个山脉数组\n\n虽然形式变了，但是我们可以变换比较方式，还是用二分查找，left&lt;&#x3D;right时最后return是什么可能不太好理解，最好自己找些数对比对比就出来了，当然最好还是left&lt;right，把区间当成左闭右开，这样直接无脑返回右就行了（但其实左右是相等的）\nfunc peakIndexInMountainArray(arr []int) int &#123;    left, right := 0,len(arr)-2    mid := (left+right)&gt;&gt;1    for left &lt;= right &#123;        if arr[mid] &lt; arr[mid+1] &#123;            left = mid + 1        &#125; else &#123;            right = mid - 1        &#125;        mid = (left+right)&gt;&gt;1    &#125;    return left&#125;\n\nsort.search使用模板index := sort.Search(n int,f func(i int) bool) int使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True如果无法找到该index值，则该方法为返回n\n例如：\nfunc main() &#123;    a := []int&#123;1,2,3,4,5&#125;    d := sort.Search(len(a), func(i int) bool &#123; return a[i]&gt;=3&#125;)    fmt.Println(d)&#125;// output 2\n\n// 使用sort.search的做法func peakIndexInMountainArray(arr []int) int &#123;    return sort.Search(len(arr)-1, func(i int) bool &#123; return arr[i] &gt; arr[i+1] &#125;)&#125;\n\n070 排序数组中只出现一次的数字给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。\n你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。\n方法一：全数组的二分查找相对好想一些，这个是保证每次比较时根据索引与对应的位置比较\n\n如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；\n如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。\n\n利用按位异或的性质，可以得到 mid 和相邻的数之间的如下关系，其中 ⊕ 是按位异或运算符：\n\n当 mid 是偶数时，mid+1&#x3D;mid⊕1；\n当 mid 是奇数时，mid−1&#x3D;mid⊕1。\n\nfunc singleNonDuplicate(nums []int) int &#123;    low, high := 0, len(nums)-1    for low &lt; high &#123;        mid := low + (high-low)/2        if nums[mid] == nums[mid^1] &#123;            low = mid + 1        &#125; else &#123;            high = mid        &#125;    &#125;    return nums[low]&#125;\n\n方法二：偶数下标的二分查找保证索引都是偶数，每次比较直接与+1位置比较\n通过mid -= mid &amp; 1保证mid每次变为偶数\nfunc singleNonDuplicate(nums []int) int &#123;    low, high := 0, len(nums)-1    for low &lt; high &#123;        mid := low + (high-low)/2        mid -= mid &amp; 1        if nums[mid] == nums[mid+1] &#123;            low = mid + 2        &#125; else &#123;            high = mid        &#125;    &#125;    return nums[low]&#125;\n\n071 按权重生成随机数给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。\n例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。\n也就是说，选取下标 i 的概率为 w[i] / sum(w)\n方法：前缀和 + 二分查找我人傻了，这思路，咋想出来的\n例如[3,1,2,4]，求前缀和[3,4,6,10]，然后随机数落在1-10十个数之间，记这个数为x，再看看大于等于x的第一个位置是哪里，例如x&#x3D;2，落在了1-2-3之间，所以3是选择的数。因为前缀和有序，且要查找第一个比x大的数，所以用二分查找。\ntype Solution struct &#123;    preSum []int&#125;func Constructor(w []int) Solution &#123;    for i:=1;i&lt;len(w);i++ &#123;        w[i] += w[i-1]    &#125;    return Solution&#123;w&#125;&#125;// 自己实现二分查找func (s *Solution) PickIndex() int &#123;    target := rand.Intn(s.preSum[len(s.preSum)-1]) + 1    left,right := 0,len(s.preSum)-1    mid := (left+right)&gt;&gt;1    for left &lt; right &#123;        if s.preSum[mid] == target &#123;            return mid        &#125;else if s.preSum[mid] &lt; target &#123;            left = mid + 1         &#125; else &#123;            right = mid        &#125;        mid = (left+right)&gt;&gt;1    &#125;    return left&#125;// 调用sort.SearchInts进行二分查找func (s *Solution) PickIndex() int &#123;    target := rand.Intn(s.preSum[len(s.preSum)-1]) + 1    return sort.SearchInts(s.preSum,target)&#125;\n\n072 求平方根给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数正数的平方根有两个，只输出其中的正数平方根如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去\n// 注意：要返回的是平方小于或等于x的第一个数// 如果找不到合适的：// left: 乘积大于x    right: 乘积小于xfunc mySqrt(x int) int &#123;    left,right := 0,x    mid := (left+right)&gt;&gt;1    for left &lt;= right &#123;        value := mid * mid        if value == x &#123;            return mid        &#125;else if value &lt; x &#123;            left = mid + 1        &#125; else &#123;            right = mid - 1        &#125;        mid = (left+right)&gt;&gt;1    &#125;    return right&#125;\n\n073 狒狒吃香蕉狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。\n狒狒可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。\n狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n","categories":["技术","算法"],"tags":["算法"]},{"title":"力扣全局变量","url":"/2022-12-14/80125311f713/","content":"力扣这里的全局变量只会初始化一次，之后只是单纯的调用这个函数，所以如果想用全局变量一定要在目标函数那里重新初始化一下，要不会出现一些莫名其妙的错误。\n另外不太推荐力扣这里使用全局变量，毕竟我们要完成的是一个小功能，如果在这种小功能上加上一堆全局变量写大了会比较难受。当想用的时候可以考虑一下闭包，很大概率能解决我们的问题。\n","categories":["技术","算法"],"tags":["算法"]},{"title":"只出现一次的数字(Leetcode)","url":"/2022-10-14/e4137cb959d4/","content":"刷这道137. 只出现一次的数字 II的时候，因为最近刚把redis学了，所以第一反应是Bitmap，虽然一开始就跑偏了，但还是学到了一些东西\n首先是golang实现Bitmap，可以参考下面这篇文章，写的还是很详细的，也有代码，注意判断该位是否存在时(bitmap.words[word]&amp;(1&lt;&lt;bit)) != 0不要想当然把()!=0改为()==1。当这一位存在时，会一位与运算而只剩下这一位，也就是非0，但并不一定是1。当然也可以选择bitmap右移( (bitmap.words[word]&gt;&gt;bit) &amp; 1 ) != 0这种的话就肯定是1或0了\n另外这个既然是一个系列，就全做了做，136. 只出现一次的数字，其他的数字出现了两次，这道题相对简单，A^A=0, 0^A=A，那么我们只需要把所有数都进行异或，成对的会自然变为0，剩下的就是答案了\n然后回到出现三次的题目，答案的第二种方法还是很巧妙的，直接与3求余判断出现次数，但对于go来说要注意int一般是64位的（看电脑），如果我们用64位的数字，并且i只遍历到32位会导致符号位没法算上，也就是负数为答案的情况下会出错，可以考虑统一换成32位的，也可以让i遍历到64位。\n至于第三题只出现一次的数字 III，第一个题解采用分治的思想将问题降维就很巧妙，主要就是把二者分开，转换为136题这种。\n另外记录一下，计算机在进行位运算时是按照补码进行计算的。\n","categories":["技术","算法"],"tags":["leetcode"]},{"title":"回溯算法总结[更新ing]","url":"/2023-03-01/69e9bf3172dc/","content":"Golang写回溯注意事项!重点! 最需要注意的三个地方\n简记：调用回溯函数、path切片复制装入res、for循环区分 idx 和 i\n\n闭包写完回溯函数后，不要忘记 调用回溯函数\n将path装入result时，不可直接添加需要复制【res = append(res, path)，如果path还接着用，那原本装在res的切片也会跟着更改，正确做法：res = append(res, append([]int&#123;&#125;, path...))】\nfor循环内部调用时，注意dfs里传入start(初始值) 还是i(当前值) 还是 其他【比较容易马虎写串】\n\n复制数组时，可以copy，也可以...拆分后重组\n// 方法一：copytmp := make([]int,len(path)) // 注意：长度必须和path一致copy(tmp, path)res = append(res, tmp)// 方法二：拆分后重组res = append(res,append([]int&#123;&#125;,path...))\n\n注意copy的用法：不会因为srcSlice大而发生扩容，destSlice分配过多少空间就写多少空间\ncopy( destSlice, srcSlice []T) int\n前言回溯算法规律性太强了，写个总结以后也方便复习。根据代码随想录总结的，插了些自己的看法\n回溯介绍介绍回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯的本质是穷举，但也可以加一些剪枝的操作\n有的问题暴力直接写写不出来，此时需要借助回溯实现暴力，回溯可解决的常见问题有：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n排列问题：N个数按一定规则全排列，有几种排列方式\n棋盘问题：N皇后，解数独等\n\n回溯法解决的问题都可以抽象为树形结构\n\nvoid backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;\n\n需要注意力扣中全局变量的用法：力扣全局变量，力扣里面，全局变量只初始化一次，之后只是调用目标函数，所以在函数内部初始化\nvar (\tpath   []int\tresult [][]int)// 假设combine为力扣入口函数func combine(n int, k int) [][]int &#123;\tpath = make([]int, 0,k)\t\t// 全局变量必须函数内部再次初始化\tresult = make([][]int, 0)\tbacktrack(n, k, 1)\treturn result&#125;\n\n我这里推荐直接写闭包，个人喜欢将回溯函数命名dfs\n题目分类\n组合\n77 组合\n17 电话号码的字母组合\n39 组合总和\n40 组合总和 II\n216 组合总和 III\n\n\n分割\n131 分割回文串\n93 复原 IP 地址\n\n\n子集\n78 子集\n90 子集 II\n\n\n排序\n46 全排列\n47 全排列 II\n\n\n棋盘\n51 N 皇后\n37 解数独\n\n\n其他\n491 递增子序列\n332 重新安排行程\n\n\n\n组合问题介绍77 组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]\n\n示例 2：\n输入：n = 1, k = 1输出：[[1]]\n\n提示：\n\n1 &lt;= n &lt;= 20\n1 &lt;= k &lt;= n\n\n\n重点：左侧取1的那个分支 会包含 所有 取数组中下表为0的情况，所以之后从2、3、4开始取时不用管那个1了，这个是在回溯内部的for循环中实现的，而 树往下延申 是 通过回溯实现\n图中可以发现n相当于树的宽度，k相当于树的深度，每次搜索到了叶子节点，我们就找到了一个结果\n只需要把达到叶子节点的结果收集起来，就可以求得n个数中k个数的组合集合\nfunc combine(n int, k int) [][]int &#123;\tpath := make([]int, 0, k)\tres := make([][]int, 0)\t// 先声明再赋值，若直接dfs := func(...)&#123;...&#125; 无法在内部递归调用\tvar dfs func(int)\tdfs = func(idx int) &#123;\t\tif len(path) == k &#123;\t\t\tres = append(res, append([]int&#123;&#125;, path...))\t\t&#125;\t\tfor i := idx; i &lt;= n; i++ &#123;\t\t\tpath = append(path, i)\t\t\t// 进入包含下标为i的分支\t\t\tdfs(i+1)  // 子节点不再重复选自己，所以 i+1\t\t\tpath = path[:len(path)-1]\t\t&#125;\t&#125;\tdfs(1)  // 记着调用\treturn res&#125;\n\n注意，回溯的题都要考虑是否可以 剪枝优化\n这道题，当 还剩的节点数目 + path中已经选中的 &lt; k ，即 n-i+1 + len(path) &lt; k该节点及其子节点肯定都不满足，没必要接着for循环了，直接return\nfunc combine(n int, k int) [][]int &#123;\tpath := make([]int, 0, k)\tres := make([][]int, 0)\tvar dfs func(int)\tdfs = func(idx int) &#123;\t\tif len(path) == k &#123;\t\t\tres = append(res, append([]int&#123;&#125;, path...))\t\t&#125;\t\tfor i := idx; i &lt;= n; i++ &#123;\t\t\t// 剩下?数可选 &lt; 总共还要选?个数\t\t\t// 也可移项后写入for判断条件中            if n - i + 1 &lt; k - len(path) &#123; // 剪枝                return\t        &#125;\t\t\tpath = append(path, i)\t\t\t// 进入包含下标为i的分支\t\t\tdfs(i+1)  // 子节点不再重复选自己，所以 i+1\t\t\tpath = path[:len(path)-1]\t\t&#125;\t&#125;\tdfs(1)  // 记着调用\treturn res&#125;\n\n216 组合总和 III找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n\n只使用数字1到9\n每个数字 最多使用一次\n\n返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n示例 1:\n输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。\n\n示例 2:\n输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。\n\n示例 3:\n输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。\n\n提示:\n\n2 &lt;= k &lt;= 9\n1 &lt;= n &lt;= 60\n\nk 相当于树的深度，9（因为整个集合就是9个数）就是树的宽度\n例如 k &#x3D; 2，n &#x3D; 4 的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） &#x3D; 2, n（和） &#x3D; 4的组合。\n\n","categories":["技术","算法"],"tags":["算法"]},{"title":"常用排序算法总结","url":"/2022-11-26/bbb1b494558e/","content":"前言最近复习了下排序算法，常用的都用go敲了一遍。练习排序可以在牛客的这道试题中进行测试。\n菜鸟教程关于排序这块介绍的挺详细的，还配有动图，比较推荐。另外B站上马士兵老师在计数排序、基数排序这块进行了拓展，感觉说的也很棒\n简要总结\n排序算法总结\n\n快速排序和归并排序都使用了分治和递归\n从时间性能上看，快速排序是所有排序算法中实际性能最好的，然而快速排序在最坏情况下（数据基本有序）的时间性能不如堆排序和归并排序，并且空间复杂度高，所以更适合数据不大的情况\n堆排序在任何情况下，其时间复杂度为 Ο(nlogn)。这相对于快速排序而言是堆排序的最大优点。堆排序在元素较少时由于消耗较多时间在初始建堆上，因此不值得提倡，然而当元素较多时还是很有效的排序算法\n与快速排序和堆排序相比，归并排序的优点是它是一种稳定的排序方法，最坏情况下时间性能好\n从方法稳定性上来看，大多数时间复杂度为Ο(n^2)的排序均是稳定的排序方法，除简单选择排序之外。而多数时间性能较好的排序方法，例如快速排序、堆排序、希尔排序都是不稳定的\n基于比较的排序的时间复杂度下限是O(nlogn)，即这已经是最高的效率了\n\n基数排序和计数排序是非比较的排序的排序，都是桶思想，可以达到线性时间O(n)复杂度的排序，但是使用范围不太广。其中计数排序如果直接计数然后按照数量输出相应次数是不具有稳定性的，但是可以通过累加数组（前缀和）的形式先加一遍，然后逆序遍历原数组输出，即可保证稳定性。\n计数排序场景示例：300W考生排名\n冒泡排序依次比较相邻的两个元素，按照升序或者降序的规则进行交换\n稳定、平均时间O(n^2)、最好时间O(n)、最差时间O(n^2)、空间复杂度O(1)\n// 冒泡排序func bubbleSort(length int, source []int) []int &#123;    for i := 0; i &lt; length; i++ &#123;        isSort := true // 判断是否已经有序        for j := 0; j &lt; length-i-1; j++ &#123;            if source[j] &gt; source[j+1] &#123;                source[j], source[j+1] = source[j+1], source[j]                isSort = false            &#125;        &#125;        // 如果切片已经有序直接退出        if isSort &#123;            break        &#125;    &#125;    return source&#125;\n\n选择排序平均时间O(n^2)、最好时间O(n^2)、最坏时间O(n^2)、不稳定、空间复杂度O(1)\n从待排序的数据元素中选出最小（或最大）的一个元素，存放在待排序序列起始位置，直到全部待排序的数据元素的个数为零\n// 选择排序func selectSort(length int, source []int) []int &#123;    for i := 0; i &lt; length-1; i++ &#123;        minIdx, maxMin := i, source[i]        for j := i + 1; j &lt; length; j++ &#123;            if source[j] &lt; maxMin &#123;                minIdx = j                maxMin = source[j]            &#125;        &#125;        if minIdx != i &#123;            source[minIdx], source[i] = source[i], source[minIdx]        &#125;    &#125;    return source&#125;\n\n插入排序将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据\n平均时间O(n^2)、最好时间O(n)、最差时间O(n^2)、稳定、空间复杂度O(1)\n// 插入排序func insertSort(length int, source []int) []int &#123;    for i := 1; i &lt; length; i++ &#123;        insertVal := source[i]        insertIdx := i        for insertIdx &gt; 0 &amp;&amp; source[insertIdx-1] &gt; insertVal &#123;            source[insertIdx] = source[insertIdx-1]            insertIdx--        &#125;        if insertIdx != i &#123;            source[insertIdx] = insertVal        &#125;    &#125;    return source&#125;\n\n希尔排序简要概括按照下标一定增量进行分组，每组再按照直接插入算法排序，随着组的减少，每组的元素也越来越少，当组数减少至为1时，整个文件分成1组，算法便终止。\n希尔排序写的时候最好先把直接插入排序想一遍，要不循环那里容易晕\n平均时间O(n^1.3~n^2)、最好时间O(n)、最坏时间O(n^2)、不稳定、空间复杂度O(1)\n代码// 希尔排序func shellSort(length int, source []int) []int &#123;   // 步长每次缩小一半，当步长为0时退出   for gap := length / 2; gap &gt; 0; gap /= 2 &#123;      // 遍历每个小分组      for i := 0; i &lt; gap; i++ &#123;         // 小分组内部插入排序，可以把i现象成之前的0，j的增长变为gap         for j := i + gap; j &lt; length; j += gap &#123;            insertIdx := j            insertVal := source[j]            for insertIdx &gt; i &amp;&amp; source[insertIdx-gap] &gt; insertVal &#123;               source[insertIdx] = source[insertIdx-gap]               insertIdx -= gap            &#125;            if insertIdx != j &#123;               source[insertIdx] = insertVal            &#125;         &#125;      &#125;   &#125;   return source&#125;\n\n快速排序简要概括通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。大致意思就是在一个数组中取中间元素比它小的方左边比它大的则放右边两边元素再按照快排要求，最终变成有序序列。\n平均时间O(nlogn)、最好时间O(nlogn)、最坏时间O(n^2)、不稳定、空间复杂度O(nlogn)\n注意：当序列为为正序或逆序排列时为最坏时间，此时时间复杂度O(n^2)\n快排实现思路快速排序通过递归实现，一般是俩函数：\n\nquickSort递归函数:\n快排的入口并调用递归\n终止条件: l &gt;&#x3D; r\n参数: 切片 l r\n返回值: 无\n\n\npartition定位pivot函数\n交换\n返回pivot最后的位置\n\n\n\n代码func quickSort(source []int, l int, r int) &#123;   // 递归终止条件   if l &gt;= r &#123;      return   &#125;   q := partition(source, l, r)   quickSort(source, l, q-1)   quickSort(source, q+1, r)&#125;// 快排定位pivot的函数func partition(nums []int, l int, r int) int &#123;   end, pivot := r, nums[r] // 这块需要把r存下来，交换pivot用   for l &lt; r &#123;      // l先走 遇到大的就停下      for l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123;         l++      &#125;      // 如果l==r导致的进入这步会直接跳出去等于啥也没干      // 否则去找右侧小于pivot的值并与l交换      for l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123;         r--      &#125;      nums[l], nums[r] = nums[r], nums[l]      // 此处不要写l++ r++ 有可能时l&gt;=r出去的 会导致下面报错   &#125;   // 将pivot与最后的位置进行交换   nums[l], nums[end] = pivot, nums[l]   return l&#125;\n\n堆排序简要概括堆排序这个视频讲的不错，但是这个人讲的计数排序有较大问题\n堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n\n大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列\n小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列\n\n平均时间O(nlogn)、最好时间O(nlogn)、最差时间O(nlogn)、不稳定、空间复杂度O(1)\n重点堆排序中最中要的式子：\n\n下标为 i 的节点的父节点下标：( i - 1) &#x2F; 2\n下标为 i 的节点的左孩子下标：i * 2 + 1\n下标为 i 的节点的右孩子下标：i * 2 + 2\n\n代码// 堆排序// 维持大顶堆的性质(大顶堆最后输出的是从小到大的)func keepHeap(source []int, n int, change int) &#123;   lSon := change*2 + 1   rSon := change*2 + 2   maxIdx := change   if lSon &lt; n &amp;&amp; source[lSon] &gt; source[maxIdx] &#123;      maxIdx = lSon   &#125;   if rSon &lt; n &amp;&amp; source[rSon] &gt; source[maxIdx] &#123;      maxIdx = rSon   &#125;   if maxIdx != change &#123;      source[maxIdx], source[change] = source[change], source[maxIdx]      keepHeap(source, n, maxIdx)   &#125;&#125;// 堆排序入口func heapSort(source []int, length int) &#123;   // 建堆   // 父节点: F = (i-1)/2   for i := length/2 - 1; i &gt;= 0; i-- &#123;      keepHeap(source, length, i)   &#125;   // 排序   for i := length - 1; i &gt;= 0; i-- &#123;      source[0], source[i] = source[i], source[0]      keepHeap(source, i, 0)   &#125;&#125;\n\n归并排序简要概括建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用\n将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n平均时间O(nlogn)、最好时间O(nlogn)、最坏时间O(nlogn)、稳定、空间复杂度O(n)\n代码实现go这块因为操作的切片底层数组时一样的，所以没必要用left、right标记头尾，直接切割就行，反正会复用底层数组，不会浪费空间\n// 归并排序入口func mergeSort(arr []int) []int &#123;   length := len(arr)   // 递归退出条件: 只有一个元素了   if length &lt; 2 &#123;      return arr   &#125;   middle := length / 2   left := arr[0:middle] // 左开右闭   right := arr[middle:]   // 直接递归 对结果进行合并   return merge(mergeSort(left), mergeSort(right))&#125;func merge(left []int, right []int) []int &#123;   var result []int // 储存结果的辅助切片   for len(left) != 0 &amp;&amp; len(right) != 0 &#123;      if left[0] &lt;= right[0] &#123;         result = append(result, left[0])         left = left[1:]      &#125; else &#123;         result = append(result, right[0])         right = right[1:]      &#125;   &#125;   // 合并剩余左半区域   for len(left) != 0 &#123;      result = append(result, left[0])      left = left[1:]   &#125;   // 合并剩余右半区域   for len(right) != 0 &#123;      result = append(result, right[0])      right = right[1:]   &#125;   return result&#125;\n\n参考文章\n常见的八种排序方式\n菜鸟教程十大经典排序算法\n牛客[编程题]排序\n马士兵老师的B站视频\n排序算法：堆排序【图解+代码】\n\n","categories":["技术","算法"],"tags":["go","算法"]},{"title":"数据结构-树","url":"/2021-06-28/409bacb9e831/","content":"作者：吴华骅  钟希鸣 田冰航\n3.1 树的定义3.1.1 树的基本定义树(tree)是n(n≥0)个结点的有限集。n&#x3D;0时称为空树。在任意一棵非空树中：(1)有且仅有一个特定的称为根(root)的节点；(2)当n&gt;1时，其余结点可分为m个互不相交的有限集T1、T2、T3……Tm，其中每一个集合本身又是一棵树，并且称为根的子树(subtree)，如图3-1-1所示\n\n图3-1-1\n3.1.2 结点的相关概念树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(degree)。度为0的结点称为叶结点(leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点度的最大值。如图3-1-2所示，因为这棵树结点度的最大值是结点D的度，为3，所以树的度也为3。\n\n图3-1-2\n结点的子树的根称为该结点的孩子(child)，相应地，该结点称为孩子的双亲(parent)（笔者按:私以为以英文原意来看，所谓双亲的译法易造成歧义，应理解为某一位直系亲属）。同一个双亲的孩子之间互称兄弟(sibling)。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D、B、A都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。B的子孙有D、G、H、I，如图3-1-3所示\n\n图3-1-3\n3.1.3 树的其他相关概念结点的层次(level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第m层，则其子树的根在第m+1层。其双亲在同一层的结点互为堂兄弟。如图3-1-4中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。树中结点的最大层次称为树的深度(depth)或高度，当前树的深度为4。\n\n图3-1-4\n如果将树中结点的各子树看成从左至右是有次序、不能互换的，则称该树为有序树，否则为无序树。\n森林(forest)是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。\n3.2 树的储存结构3.2.1 双亲表示法一棵树中除根结点外每个结点有且仅有一个双亲。假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。如图3-2-1为双亲表示法的结构定义代码。\n\n图3-2-1\n由此我们可以实现双亲表示法了。由于根结点没有双亲，约定根结点位置域设为-1，则所有结点都有双亲的位置。如图3-2-2中的树结构可由图3-2-3中的双亲表所表示。\n\n图3-2-2\n\n图3-2-3\n若增加一个结点最左边孩子的域，不妨称之为长子域，则可以更方便地得到结点的孩子。若无孩子，则长子域设为-1，如图3-2-4所示。\n\n图3-2-4\n若还需关注各兄弟之间的关系，则可以增加一个右兄弟域体现此关系。同样的，若无右兄弟，则右兄弟域设为-1，如图3-2-5所示。\n\n图3-2-5\n实际运用中可根据实际需求灵活设置指针域。\n3.2.2 孩子表示法由于每个结点可能有多棵子树，可以考虑用多重链表。即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，该方法称为多重链表表示法。然而树各结点的度各不相同，可以设计三种方案解决。\n方案一令指针域的个数就等于树的度。由于树的度是各个结点度的最大值，则可表示所有结点。如图3-2-6所示。\n\n图3-2-6\n这种方法思路较为简单直接，但对于各结点的度相差较大时，显然十分浪费空间。\n方案二令各结点指针域的个数等于该结点的度，并专门设一数据域存储该结点的度数。如图3-2-7所示。\n\n图3-2-7\n该方法克服了浪费空间的缺点，但由于各结点链表是不相同的结构，运算时会带来时间上的损耗。\n方案三即所谓孩子表示法。将每个结点的孩子结点排列起来，以单链表为存储结构，则n个结点有n个孩子链表，若为叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图3-2-8所示。\n\n图3-2-8\n代码定义如图3-2-9所示\n\n图3-2-9\n当然也可将双亲表示法与孩子表示法综合，则可以很方便地得知一个结点的双亲和所有孩子，如图3-2-10所示。\n\n图3-2-10\n3.3 二叉树的定义3.3.1 二叉树的基本定义二叉树(binary tree)是n(n≥0)个结点的有限集合，该集合或为空集(称为空二叉树)，或由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。如图3-3-1就是一棵二叉树。而图3-2-2中的树，由于D结点有三个子树，所以它不是二叉树。\n\n图3-3-1\n3.3.2 二叉树特点(1)每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。\n(2)左子树与右子树有顺序之分，其次序不可任意颠倒。\n(3)即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。\n3.3.3 二叉树基本形态(1)空二叉树\n(2)只有一个根结点\n(3)根结点只有左子树\n(4)根结点只有右子树\n(5)根结点既有左子树又有右子树。\n由于左右子树的区分，图3-3-2中树2、树3、树4和树5分别代表不同的二叉树。\n\n图3-3-2\n3.3.4 特殊二叉树3.3.4.1 斜树所有结点都只有左子树的二叉树称为左斜树，反之称为右斜树，二者统称为斜树。图3-3-2中树2与树5即为斜树。斜树的每一层都只有一个结点，结点的个数与二叉树深度相同。\n3.3.4.2 满二叉树一棵二叉树中，若所有分支结点都存在左子树与右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。如图3-3-3所示。\n\n图3-3-3\n满二叉树的特点有：\n(1)叶子只能出现在最下一层。\n(2)非叶子结点的度一定是2。\n(3)在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。\n3.3.4.3 完全二叉树若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这样的二叉树称为完全二叉树。最下一层结点从右向左连续缺少是定义的关键所在。如图3-3-4所示即为一棵完全二叉树。而图3-3-5中三棵二叉树由于1~h-1层出现缺失或最下一层左侧出现空档，都不为完全二叉树。\n\n图3-3-4\n\n图3-3-5\n完全二叉树的特点：\n(1)叶子结点只出现在最下两层。\n(2)最下层叶子一定集中于左侧连续位置。\n(3)倒数二层，若有叶子结点，一定都在右部连续位置。\n(4)若结点数为1，则该结点只有左孩子，即不存在只有右孩子的情况。\n(5)同样结点数的二叉树，完全二叉树的深度最小。\n3.4 二叉树的性质(1)二叉树的第i层上最多有2^i-1个结点(i&gt;&#x3D;1)。\n(2)在一棵深度为k的二叉树中，最多有2^k-1个结点(即满二叉树)，最少有k个结点(即斜树)。\n(3)在一棵二叉树中，如果叶子结点的个数为n0，度为2的结点个数为n2，则n0&#x3D;n2+1。\n(4)具有n个结点的完全二叉树的深度为⌊log2(n)⌋+1。(⌊x⌋代表不大于x的最大整数)。\n(5)对一棵具有n个结点的完全二叉树中的结点从1开始按层序编号，则对于任意的编号为i（1&lt;&#x3D;i&lt;&#x3D;n）的结点，有：\n1.如果i&gt;1，则结点i的双亲编号为⌊i&#x2F;2⌋；否则结点i是根结点，无双亲。\n2.如果2i&lt;&#x3D;n，则结点i的左孩子的编号为2i；否则结点i无左孩子。\n3.如果2i+1&lt;&#x3D;n，则结点i的右孩子的编号为2i+1；否则结点i无右孩子。\n3.5 二叉树的存储结构3.5.1 二叉树顺序存储结构二叉树顺序存储结构即用一维数组存储二叉树中的结点，结点存储位置与结点间逻辑关系由数组下标体现。如图3-4-1的二叉树可由其下的数组表示\n\n图3-5-1\n由图可得，数组元素默认按完全二叉树位置排列，若该位置为空，则用“^”符号表示。可见，当二叉树层次较高而结点较少时(极端情况即为斜树)，存储空间浪费较大。所以该存储结构一般仅用于完全二叉树。\n3.5.2 二叉链表二叉树每个结点最多有两个孩子，所以在链式存储结构中，可为它设计一个数据域和两个指针域，这样的链表称为二叉链表。结构定义代码如图3-5-2，结构示意图如图3-5-3。\n\n图3-5-2\n\n图3-5-3\n若有需要，可增添一个指向双亲的指针域，即三叉链表，与树的孩子双亲表示法思路类似，此处不作赘述。\n3.6 二叉树的遍历3.6.1 定义二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。\n3.6.2 二叉树遍历方法基本原理：递归与栈\n3.6.2.1 前序遍历若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再后序遍历右子树。如图3-6-1所示，遍历的顺序为：ABDGHCEIF，代码如图3-6-2所示。\n\n图3-6-1\n\n图3-6-2\n算法流程(中、后序算法与之类似，后不再赘述)以图3-6-3所示二叉树T为例，该数用二叉链表形式存储。\n\n图3-6-3\n(1)调用&amp;&amp;&amp;(T)，T根结点不为NULL，所以执行printf，打印字母A，如图3-6-4所示\n\n图3-6-4\n(2)调用&amp;&amp;&amp;(T-&gt;lchild)；访问了A结点的左孩子，不为NULL，执行printf显示字母B，如图3-6-5所示。\n\n图3-6-5\n(3)此时再次递归调用&amp;&amp;&amp;(T-&gt;lchild)；访问了B结点的左孩子，执行printf显示字母D，如图3-6-6所示。\n]\n图3-6-6\n(4)再次递归调用&amp;&amp;&amp;(T-&gt;lchild)；访问了D结点的左孩子，执行printf显示字母H，如图3-6-7所示。\n\n图3-6-7\n(5)再次递归调用&amp;&amp;&amp;(T-&gt;lchild)；访问了H结点的左孩子，此时因为H结点无左孩子，所以T&#x3D;&#x3D;NULL，返回此函数，此时递归调用&amp;&amp;&amp;(T-&gt;rchild)；访问了H结点的右孩子，printf显示字母K，如图3-6-8所示。\n\n图3-6-8\n(6)再次递归调用&amp;&amp;&amp;(T-&gt;lchild)；访问K结点的左孩子，K结点无左孩子，T&#x3D;&#x3D;NULL，返回，调用&amp;&amp;&amp;(T-&gt;rchild)，亦为NULL，返回。于是此函数执行完毕，返回到上一级的递归函数(即打印H结点时的函数)，也执行完毕，返回到打印结点D时的函数，调用&amp;&amp;&amp;(T-&gt;rchild)；访问D结点的右孩子，不存在，返回到B结点，调用&amp;&amp;&amp;(T-&gt;rchild)；找到了结点E，打印字母E，如图3-6-9所示。\n\n图3-6-9\n(7)由于结点E没有左右孩子返回打印B结点时的递归函数，递归执行完毕，返回到最初的&amp;&amp;&amp;，调用&amp;&amp;&amp;(T-&gt;rchild)；访问结点A的右孩子，打印字母C，如图3-6-10所示。\n\n图3-6-10\n(8)之后类似前面的递归调用，依次继续打印F、I、G、J，最后依次返回，直至最初的&amp;&amp;&amp;执行完毕，步骤略。\n3.6.2.2 中序遍历若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，如图3-6-11所示。遍历顺序为GDHBAEICF，代码如图3-6-12所示。\n\n图3-6-11\n中序遍历算法则将打印结点置于调用左子树函数与调用右子树函数之间即可。\n\n图3-6-12\n3.6.2.3 后序遍历若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图3-6-13所示。遍历顺序为GHDBIEFCA，代码如图3-6-14所示。\n\n图3-6-13\n后序遍历算法则将打印结点置于调用左子树函数与调用右子树函数之后即可。\n\n图3-6-14\n3.6.2.4 层序遍历若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图3-6-15所示。遍历顺序为ABCDEFGHI。\n\n图3-6-15\n层序遍历通常用队列实现，代码如3-6-16所示。\n\n图3-6-16\n3.6.3 *栈的方法实现二叉树遍历用栈实现二叉树的遍历，实质上即为将递归左右子树的过程利用栈的后进后出性而以栈的出栈入栈实现。代码实现如图所示(由于C++中对栈的操作较为简易，以下代码由C++实现，建议同学在了解C++对栈操作的各函数之后再行浏览本节)。\n\n图3-6-17 前序遍历\n\n图3-6-18 中序遍历\n\n图3-6-19 后序遍历\n3.6.4 * 二叉树遍历的python实现如图给出二叉树遍历的python实现作为参考，有一定python基础的同学可以以此加深对二叉树遍历原理的领会。\n\n图3-6-20 树的结点定义\n\n图3-6-21 树的定义\n\n图3-6-22 树的前序遍历\n\n图3-6-23 树的中、后序遍历\n\n图3-6-24 树的层序遍历\n\n图3-6-25 主函数\n3.7 二叉树的建立二叉树的建立通常通过输入树的前序、中序或后序式，再进行遍历操作实现(即将前述遍历结点中的打印结点操作改为输入结点操作即可)。\n如图3-7-1所示的树，为了能让每个结点确认是否有左右孩子，我们对他进行了扩展，转化为如图3-7-2的模式。即将二叉树中每个结点的空指针引出一个虚节点，其值为一特定值，比如“#”。可称处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树即可实现一个遍历序列确定唯一一棵二叉树。则该树前序遍历序列即为AB#D##C##,代码如图3-7-3所示。\n\n图3-7-1\n\n图3-7-2\n相应的，自然也可以使用中序与后序式建立二叉树，只需改动生成根结点的位置即可。\n\n图3-7-3\n3.8 线索二叉树3.8.1 线索二叉树原理如图3-8-1，在实际中使用二叉树时，存在大量空指针域。而由二叉树性质可知，对于一个结点数为n的二叉树存在n+1个空指针。这无疑造成了空间上的极大浪费。同时，在未对二叉树进行遍历时，我们无法得知该二叉树在前序、中序或后序式中前驱和后继分别是哪个结点，每次需得知是都需遍历一次二叉树，又造成时间上的极大浪费。\n从以上角度来看，则可以利用这些空指针域进行某种顺序式前驱和后继的标识。这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树则称为线索二叉树(thread binary tree)。\n如图3-8-1中的二叉树，存在11个空指针。将这棵二叉树进行中序遍历后，将所有空指针域中的rchild，改为指向他的后继结点。于是可知图中H的后继为D，I的后继为B，J的后继为E，E的后继为A，F的后继为C，G的后继因为不存在而指向NULL。此时共有6个空指针被利用(如图3-8-2)。\n\n图3-8-1\n\n图3-8-2\n再将二叉树中所有空指针域中的lchild，改为指向当前结点的前驱。则H的前驱为NULL，I的前驱为D，J的前驱为B，F的前驱为A，G的前驱为C(如图3-8-3)。至此所有空指针域都被利用。\n\n图3-8-3\n通过图3-8-4(空心箭头实线为前驱，虚线黑箭头为后继)，可直观地看出，所谓线索二叉树，实质上即将二叉树转化为双向链表，这样对插入、删除结点、查找某个结点带来方便。对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。\n\n图3-8-4\n然而此时却无法区分某一结点的lchild指向前驱还是左孩子，rchild是指向后继还是右孩子。则可与每个结点处增添两个标志域ltag与rtag。ltag与rtag为布尔型变量，所占用内存量远小于节省的指针域所占用内存量。可规定ltag&#x2F;rtag&#x3D;0时指向前驱或后继，为1时指向左右孩子。即可达到区分效果。\n3.8.2 线索二叉树结构实现线索二叉树存储结构定义代码如图3-8-5所示\n\n图3-8-5\n线索化实质即将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，则线索化的过程即为在遍历的过程中修改空指针的过程。\n中序遍历线索化代码如图3-8-6所示\n\n图3-8-6\n可见该过程与中序遍历的递归过程几乎一致，仅将打印链表的过程改为线索化的过程。线索化过程原理如下。\nif(!p-&gt;lchild)表示若某结点左指针域为空，由于其前驱结点刚被访问过，且赋给了pre，则可将pre赋值给p-&gt;lchild，并将p-&gt;ltag置为0以完成前驱结点的线索化。后继由于此时并为访问，则可对其前驱结点pre的rchild进行判断，if(!pre-&gt;rchild)表示若其右指针域为空则可将其后继结点p赋值给pre-&gt;rchild，并将p-&gt;rtag置为0，则又完成后继结点的线索化。判断结束后将当前结点赋值给pre，以保持pre指向p的前驱。\n如图3-8-7所示，在二叉树线索链表上添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点。且令二叉树中序遍历的第一个结点的lchild域指针与最后一个结点的rchild域指针均指向头结点。则实际上得到了一个双向链表结构。遍历代码如图3-8-8所示。\n\n图3-8-7\n\n图3-8-8\n算法原理如下：\n(1)第5行，令p&#x3D;head-&gt;lchild，即令p指向根结点开始遍历。\n(2)第6~17行，while(p!&#x3D;head)的大循环即确定循环结束条件为p再次指向头结点。\n(3)第8~10行，while(p-&gt;ltag&#x3D;&#x3D;link)，即递归算法中不断调用左子树，直至某结点的ltag不为link(即该结点左子树为空)，打印该结点(即该结点结点调用左子树方程结束，打印结点)。\n(4)第11~15行while(p-&gt;rtag&#x3D;&#x3D;thread&amp;&amp;p-&gt;rchild!&#x3D;head),则沿指向后继的指针移动并打印结点。直至p所指向结点有右子树或遍历结束。\n(5)第16行，p&#x3D;p-&gt;rchild，进入p的右子树再次进行循环，直至遍历结束。\n3.9 树、森林与二叉树的转换我们对二叉树的各项性质与结构已研究得较为透彻，则对于一般的树和森林，可以转化为二叉树进行研究。\n3.9.1 树转换为二叉树步骤如下(如图3-9-1)：\n(1)加线。在所有兄弟结点之间加一条连线。\n(2)去线。对树中每个结点，只保留其与第一个孩子结点的连线，删除其与其他孩子结点间的连线。\n(3)层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。令第一个孩子为二叉树结点的左孩子，兄弟转换过来的结点是结点的右孩子。\n\n图3-9-1\n3.9.2 森林转换为二叉树步骤如下(如图3-9-2)： (1)把每个树转换成二叉树。\n(2)第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，并用线连接起来。\n\n图3-9-2\n3.9.3 二叉树转换为树二叉树转换为树实则即为树转换为二叉树的逆过程，步骤如下(如图3-9-3)：\n(1)加线。若某结点的左孩子结点存在，则将此左孩子的右孩子结点，及右孩子结点的右孩子结点……直至某结点的右孩子结点无右孩子结点，将这些结点都作为此结点的孩子，并用线连接起来。\n(2)去线。删除原二叉树中所有结点与其右孩子的连线。\n(3)层次调整。使之结构层次分明。\n\n图3-9-3\n3.9.4 二叉树转换为森林首先判断一棵二叉树是否能够转换为森林。若有右孩子，则可转换为森林(原因由二叉树转换为森林方法可轻易得知)。\n步骤如下(如图3-9-4)：\n(1)从根结点开始，若右结点存在，则将与右结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除。直至所有右孩子连线都删除为止，得到分离的二叉树。\n(2)再将每棵分离后的二叉树转换为树即可。\n\n图3-9-4\n3.10 赫夫曼树及其应用3.10.1 赫夫曼树的定义与构造定义从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度即从根结点到每一结点的路径长度之和。若一棵树中结点带有权值，则结点的带权路径长度为从该结点到根结点之间的路径长度与结点上权的乘积，树的带权路径长度即为树中所有叶子结点的带权路径长度之和。\n假设有n的权值{w1,w1,w3……wn}，以之构造一棵有n个叶子结点的二叉树，则其中带权路径长度WPL最小的二叉树称为赫夫曼树。\n构造赫夫曼树步骤如下：\n(1)假设有A、B、C、D、E五个叶子结点，权值分别为5、15、40、30、10.则先将其按从小到大的顺序排列成一个有序序列，即：A5,E10,B15,D30,C40。\n(2)取权值最小与第二小的的两个结点作为一个新节点N1的两个子节点，取相对较小者为左孩子，如图3-10-1所示。新结点权值为两叶子结点之和。\n\n图3-10-1\n(3)将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15,B15,D30,C40.\n(4)重复步骤2，将N1与B作为一个新结点N2的两个子结点。如图3-10-2所示。N2的权值为30。\n\n图3-10-2\n(5)不断重复步骤3,4，直至所有叶子结点都在一个二叉树中。最终构成的二叉树即为给定结点的赫夫曼树。如图3-10-3所示。\n\n图3-10-3\n此时树的WPL最短，为40×1+30×2+15×3+10×4+5×4&#x3D;205。\n算法描述如下：\n(1)根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F&#x3D;{T1,T2,…,Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均为空。\n(2)在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树根结点的权值为其左右子树上根结点的权值之和。\n(3)在F中删除这两棵树，同时将新得到的二叉树加入F中。\n(4)重复步骤2,3，直至F中只含一棵树为止。该树即为给定结点的赫夫曼树。\n3.10.2 赫夫曼树的应用3.10.2.1 设置判断条件对于某些需要进行多步判断条件的问题，可以应用赫夫曼树找出最优的判断条件。\n如下面这个情景：学校把学生的成绩分为五个等级:059为E,6069为D,7079为C,8089为B,90~100为A，所占比例分别为5%,15%,40%,30%,10%，现要按标准等级制录入学生成绩。\n通常直接想到的判断方法显然是逐个判断条件，如图3-10-4所示。\n\n图3-10-4\n但由于各等级段学生比例并不相同，即各结点权值不同，这样效率并不高。经过计算得WPL&#x3D;5×1+15×2+40×3+30×4+10×4&#x3D;315。\n而对该结点创建赫夫曼树，即3-10-3所创建的赫夫曼树，WPL&#x3D;205，效率提升了1&#x2F;3，在所需判断次数较多的情况下，效率提升的效果是极为显著的。\n3.10.2.2 赫夫曼编码赫夫曼研究这种最优树的目的是为了解决当年远距离通信（主要是电报）的数据传送的最优化问题。\n我们以网络传输一段文字内容为“BADCADFEED”为例。如果用二进制的数字（0和1）来表示，如图3-10-5所示。\n\n图3-10-5\n真正传输的数据就是编码后的“001000011010000011101100100001”。若传输一篇很长的文章，此二进制串显然较大，而不同字母的出现频率并不相同。假设这六个字母的频率如图3-10-6所示。\n\n图3-10-6\n则可尝试构造字母的赫夫曼树，如图3-10-7所示(右侧为将权值的左右分支分别改为0和1之后的赫夫曼树)。\n\n图3-10-7\n此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，得到下表(如图3-10-8所示)\n\n图3-10-8\n同时，由于有长短不一的编码，必须运用前缀编码原则，即任一字符的编码都不是另一字符的前缀。显然，图3-10-8中的编码不存在易与1001、1000混淆的10和100编码。\n再次编码为“1001010010101001000111100”。\n显然新字符串较原字符串变小了，节约了大约17%的存储或传输成本。随着字符串的增加和多字符权重的不同，这种压缩将更显优势。\n而接收方解压缩时，则使用与发送方相同的赫夫曼编码原则解码即可。\n","categories":["技术","算法"],"tags":["C语言","数据结构"]},{"title":"算法总结——数组","url":"/2022-07-09/6b942e53ad3d/","content":"数组[TOC]\n1. 前缀和我们先从问题出发引出前缀和，现在给定一个数组q[8] = &#123;1, 2, 5, 3, 7, 9, 4, 5 &#125;要求计算给定区间的和，如 [ 1 , 2 ] --&gt; 2 + 5 = 7 , [ 3 , 6 ] --&gt; 3 + 7 + 9 + 4 = 23。这个题目我们直接遍历即可，但是如果要算的区间较多呢，例如给出300次询问，那我们便要进行300次遍历。数组长度为n，询问次数为m，则时间复杂度为o(nm)。\n接着我们引出前缀和，所谓前缀和，就是从位置0到位置i这个区间内的所有的数字之和。对于例子中给出的数组我们用sum[8]来表示前缀和，即sum[i] = q[0] + …… + q[i]，我们可以推出：sum[0] = q[0] , 当 i &gt; 0时sum[i] = sum[i-1] + q[i]。所以我们通过一次遍历便可求出数组的前缀和。\nint main() &#123;    int q[8] = &#123;1, 2, 5, 3, 7, 9, 4, 5&#125;;    int sum[8];    sum[0] = q[0];    for (int i = 1; i &lt; 8; i++) &#123;        sum[i] = sum[i - 1] + q[i];    &#125;    return 0;&#125;\n\nfunc main() &#123;  \ta := []int&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;  \tsum := make([]int, len(a))  \tsum[0] = a[0]  \tfor i := 1; i &lt; len(a); i++ &#123;  \t\tsum[i] += sum[i-1] + a[i]  \t&#125;  \tfmt.Println(sum)  &#125;\n\n经过观察可以发现，如果我们要求区间[4, 7]（数组下表）的和，我们只需要将前8位的和减去前4位的和，属于o(1)量级的计算。可以得出计算区间[L, R]的和的公式为sum[R] - sum[L-1]\nint main() &#123;    int q[8] = &#123;1, 2, 5, 3, 7, 9, 4, 5&#125;;    int sum[8];    sum[0] = q[0];    for (int i = 1; i &lt; 8; i++) &#123;        sum[i] = sum[i - 1] + q[i];    &#125;    int m, L, R; // m代表询问次数    scanf(&quot;%d&quot;, &amp;m);    for (int i = 0; i &lt; m; i++) &#123;        scanf(&quot;%d %d&quot;, &amp;L, &amp;R);        printf(&quot;%d\\n&quot;, sum[R] - sum[L - 1]);    &#125;    return 0;&#125;\n\n接着我们将前缀和拓展到二维\n同样的，我们现在有一个二维数组如下：\nint q[4][4] = &#123;    &#123;2,  3,  23, 5&#125;,    &#123;6,  33, 7,  45&#125;,    &#123;23, 4,  9,  56&#125;,    &#123;34, 57, 78, 75&#125;,&#125;;\n\n现在需要给出区域范围求出相应的区域和，例如给出[1, 1]~[3, 2] --&gt; q[1][1] + q[1][2] + q[2][1] + q[2][2] + q[3][1] + q[3][2] = 188\n接着采用前缀和的思想我们将sum[i][j] 记为[0, 0]~[i, j]的区域和。\n如果我们要求[x1, y1]~[x2, y2]的区域和时，通过下表（图以[1, 1]~[3, 2]进行举例）可以直观看出，最终结果为整个大框减去两个橙色框加上重复减去的蓝色框，即：ans = sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]\n\n这时我们可以推出sum[i][j] = sum[i - 1][j] - sum[i][j - 1] + sum[i - 1][j - 1] + q[i][j]，借此迭代出sum。\n考虑到数组越界，我们需要将i和j为0的情况单独计算\nint q[4][4] = &#123;    &#123;2,  3,  23, 5&#125;,    &#123;6,  33, 7,  45&#125;,    &#123;23, 4,  9,  56&#125;,    &#123;34, 57, 78, 75&#125;,&#125;;int sum[4][4];int main() &#123;    sum[0][0] = q[0][0];    for(int i = 1;i&lt;4;i++) sum[i][0] = sum[i-1][0] + q[i][0];    for(int j = 1;j&lt;4;j++) sum[0][j] = sum[0][j-1] + q[0][j];    for(int i = 1;i&lt;4;i++)        for(int j = 1;j&lt;4;j++)            sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + q[i][j];    return 0;&#125;\n\n最后我们分为 x1 &#x3D; y1 &#x3D; 0、x1 &#x3D; 0, y1 !&#x3D; 0、y1 &#x3D; 0, x1 !&#x3D; 0及其他 四种情况计算ans\n\nx1 = y1 = 0时，ans = sum[x2][y2]\nx1 = 0, y1 != 0时，相当于不需要考虑上侧的橙色框，只需减去左侧的橙色框ans = sum[x2][y2] - sum[x2][y1 - 1]\ny1 = 0, x1 != 0时，相当于不需要考虑左侧的橙色框，只需减去上侧的橙色框ans = sum[x2][y2] - sum[x1 - 1][y2]\n其他，ans = sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]\n\nint calcResult(int x1, int y1, int x2, int y2) &#123;    if (!x1 &amp;&amp; !y1) return sum[x2][y2];    if (!x1) return sum[x2][y2] - sum[x2][y1 - 1];    if (!y1) return sum[x2][y2] - sum[x1 - 1][y2];    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];&#125;\n\n完整代码如下\n#include&lt;stdio.h&gt;int q[4][4] = &#123;        &#123;2,  3,  23, 5&#125;,        &#123;6,  33, 7,  45&#125;,        &#123;23, 4,  9,  56&#125;,        &#123;34, 57, 78, 75&#125;,&#125;;int sum[4][4];int calcResult(int x1, int y1, int x2, int y2) &#123;    if (!x1 &amp;&amp; !y1) return sum[x2][y2];    if (!x1) return sum[x2][y2] - sum[x2][y1 - 1];    if (!y1) return sum[x2][y2] - sum[x1 - 1][y2];    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];&#125;int main() &#123;    sum[0][0] = q[0][0];    for (int i = 1; i &lt; 4; i++) sum[i][0] = sum[i - 1][0] + q[i][0];    for (int j = 1; j &lt; 4; j++) sum[0][j] = sum[0][j - 1] + q[0][j];    for (int i = 1; i &lt; 4; i++)        for (int j = 1; j &lt; 4; j++)            sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + q[i][j];    int m,x1,x2,y1,y2;// m代表询问次数    scanf(&quot;%d&quot;,&amp;m);    for(int i=0;i&lt;m;i++)&#123;        scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        printf(&quot;%d&quot;, calcResult(x1, y1, x2, y2));    &#125;    return 0;&#125;\n\n例题1 长度最小的子数组题目题目链接\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的连续子数组并返回其长度。如果不存在符合条件的子数组，返回 0 。\n要求时间复杂度不超过O(nlogn) \n示例 1：输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例 2：输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1\n示例 3：输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0\n其中：\n\n1 &lt;&#x3D; target &lt;&#x3D; 10^9\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n\n分析本题可以采用前缀和 + 二分查找的方式求解，在大一C语言课程中我们应该已经学到过二分查找，这里对二分查找仍不熟悉的同学请将 [附加题](#附加题 二分查找) 认真完成，当然我们在查找与排序模块会对二分查找进一步学习。\n如果我们采用暴力解法（两层for循环直接跑）时间复杂度为o(n^2)显然不太合适，这里因为需要对区域进行求和我们可以考虑前缀和，因为所有数均为正整数，前缀和为有序数组，我们可以用二分查找快速定位到目标位置。\n整体过程为创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和。得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）。\n代码int lower_bound(int *sums, int l, int r, int target) &#123;    if (sums[r] &lt; target) return -1;    while (l &lt; r) &#123;        int mid = l + (r - l) / 2;\t// 等同于(l+r)/2，防止越界        if (sums[mid] &gt;= target) &#123;            r = mid;        &#125; else &#123;            l = mid + 1;        &#125;    &#125;    return l;&#125;int minSubArrayLen(int s, int *nums, int numsSize) &#123;    if (numsSize == 0) &#123;        return 0;    &#125;    int ans = INT_MAX;    int *sums = (int *)malloc(sizeof(int) * (numsSize + 1));    // 为了方便计算，令 size = n + 1    // sums[0] = 0 意味着前 0 个元素的前缀和为 0    // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]    // 以此类推    for (int i = 1; i &lt;= numsSize; i++) &#123;        sums[i] = sums[i - 1] + nums[i - 1];    &#125;    for (int i = 1; i &lt;= numsSize; i++) &#123;        int target = s + sums[i - 1];        int bound = lower_bound(sums, 1, numsSize, target);        if (bound != -1) &#123;            ans = ans &lt; bound - (i - 1) ? ans : bound - (i - 1);        &#125;    &#125;    return ans == INT_MAX ? 0 : ans;&#125;\n\n课后作业题目链接\n对一个给定的自然数M，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为M。\n例子：1998+1999+2000+2001+2002 &#x3D; 10000，所以从1998到2002的一个自然数段为M&#x3D;10000的一个解。\n输入格式包含一个整数的单独一行给出M的值（10 &lt; M &lt; 2,000,000）。\n输出格式每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。\n// 样例输入10000// 样例输出18 142 297 328 388 412 1998 2002\n\n作业答案这道题目有多种解法，在此我们可以考虑通过前缀和的方式求出区间和，通过二分查找缩短时间复杂度，与例题类似，在此不过多解释。\n#include &quot;stdio.h&quot;#include &quot;malloc.h&quot;int lower_bound(long long *sum, long l, long r, long long target) &#123;    while (l &lt; r) &#123;        long middle = l + (r - l) / 2; // 防止越界        if (sum[middle] &gt; target) r = middle;        else if (sum[middle] &lt; target) l = middle + 1;        else if (sum[middle] == target) return middle;    &#125;    return -1;&#125;int main() &#123;    long M;    scanf(&quot;%ld&quot;, &amp;M);    long long *sum = (long long *) malloc(sizeof(long long) * (M+1));    sum[0] = 0;    for (int i = 1; i &lt;= M; i++) sum[i] = sum[i - 1] + i;    for (int i = 1; i &lt;= M; i++) &#123;        int bound = lower_bound(sum, i, M, M + sum[i - 1]);        if (bound != -1)            printf(&quot;%ld %ld\\n&quot;, i, bound);    &#125;    return 0;&#125;\n\n2. 差分一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。\n直接说比较抽象，我们也是先从问题出发引出差分，现在给定一个数组q[8] &#x3D; {1, 2, 5, 3, 7, 9, 4, 5 }，现在需要对这个数组对相应区间中的所有数加上或减去一个值，执行该操作多次，最后返回数组的最终状况。例如：[3, 5]区间中所有元素加10，则将数组变为[1, 2, 5, 13, 17, 19, 4, 5 ]，[1, 4]区间中所有元素减3，则将数组变为[1, -1, 2, 10, 14, 19, 4, 5 ]。\n直接遍历去减就行，但是如果要运算的区间较多呢，例如给出300次变化，那我们便要进行300次遍历。数组长度为n，变化次数为m，则时间复杂度为o(nm)。\n接着我们引出差分，所谓差分，可以简单的看成序列中每个元素与其前一个元素的差。以给出的数组为例，d[8] &#x3D; [1, 1, 3, -2, 4, 2, -5, -1]，这串数看起来似乎没什么意义，但是我们对它求一下前缀和就会发现sum_d[8] &#x3D; [1, 2, 5, 3, 7, 9, 4, 5 ]即原数组。\n在这个过程中如果我们对d中第二个元素加3，就会发现sum_d从第二位起所有元素都加了3，同样的如果对第五位元素减去3，那么从第五位起所有元素又都减了3，这样操作下来，相当于第二个到第四个元素都加了3，同理，如果我们想要实现区间[3, 5]中的元素均加10，只需让d[3] &#x3D; d[3] + 10 , d[6] &#x3D; d[6] - 10，最后会反映在sum_d中。即[L, R]所有元素加value只需d[L] &#x3D; d[L] + value, d[R+1] &#x3D; d[R+1] - value，最后求出数组d的前缀和即为变化后的数组。\n接着我们可以发现，d只用来统计区间变化时的情况，所以我们实际上并不需要计算q的差分，d统一初始为0，记录区间的变化情况，求出sum_d后再加回到q上结果也是一样的。\n#include&lt;stdio.h&gt;// 注意这里d需要多开一个数组，因为add时存在r+1，否则会有数组越界的情况// 当然也可以不多开，在add里面判断是否为边界单独处理，但代价是每次调用add时都要判断是否越界int d[9] = &#123;0&#125;;void add(int l, int r, int v) &#123;    d[l] += v;    d[r + 1] -= v;&#125;int main() &#123;    int q[8] = &#123;1, 2, 5, 3, 7, 9, 4, 5&#125;;    add(2, 4, 5);    add(1, 3, 2);    add(0, 2, -3);    // 计算前缀和    for (int i = 1; i &lt; 8; i++) d[i] += d[i - 1];    for (int i = 0; i &lt; 8; i++) &#123;        q[i] += d[i];        printf(&quot;%d &quot;, q[i]);    &#125;    return 0;&#125;\n\n同样的，我们推广到二维，类比前缀和的二维，我们不会再进行详细的介绍，简单带过一下，先给出个例子我们再去具体介绍，二维数组如下：\nint q[4][4] = &#123;    &#123;2,  3,  23, 5&#125;,    &#123;6,  33, 7,  45&#125;,    &#123;23, 4,  9,  56&#125;,    &#123;34, 57, 78, 75&#125;,&#125;;\n\n区域[1, 1]~[3, 2]加3，区域[1, 2]~[2, 3]减5，最后给出变化后的数组。\n现在我们来看下图，如果我们要将红色区域+v，我们将x1,y1的差分数组+v，那它影响的区域为所有蓝色区域\n\n所以我们需要修改的位置有：\n\nd[x1][y1] + v \nd[x1][y2+1] + v\nd[x2+1][y1] + v\nd[x2+1][y2+1] - v\n\n\n接着我们来看代码\n#include&lt;stdio.h&gt;const int n = 4;    // 行数const int m = 4;    // 列数int q[4][4] = &#123;        &#123;2,  3,  23, 5&#125;,        &#123;6,  33, 7,  45&#125;,        &#123;23, 4,  9,  56&#125;,        &#123;34, 57, 78, 75&#125;,&#125;;int d[5][5];    // 多开一个长度防止越界int sum[4][4];void add(int x1, int y1, int x2, int y2, int v) &#123;    d[x1][y1] += v;    d[x1][y2 + 1] -= v;    d[x2 + 1][y1] -= v;    d[x2 + 1][y2 + 1] += v;&#125;void pre_sum() &#123;    sum[0][0] = d[0][0];    for (int i = 1; i &lt; n; i++) sum[i][0] = sum[i - 1][0] + d[i][0];    for (int j = 1; j &lt; m; j++) sum[0][j] = sum[0][j - 1] + d[0][j];    for (int i = 1; i &lt; n; i++)        for (int j = 1; j &lt; m; j++)            sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + d[i][j];&#125;int main() &#123;    add(1, 1, 3, 2, 3);    add(1, 2, 2, 3, 5);    pre_sum();  // 求出d的前缀和    for (int i = 0; i &lt; n; i++) &#123;        for (int j = 0; j &lt; m; ++j) &#123;            q[i][j] += sum[i][j];            printf(&quot;%d &quot;, q[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n例题1 统计奇数题目题目链接\n长度为n的数组初始全为0，每分钟数组元素的值都会自增1。m次操作，每次选择一个区间，在自增的基础上额外增1，求m次操作后数组中奇数的个数。\n示例：\n// 输入3,2,[1,2],[2,3]// 输出2\n\n示例说明\n第一分钟后 第一个数为2，第二个数为2，第三个数为1第二分钟后 第一个数为3，第二个数为4，第三个数为3，一共两个数为奇数，所以输出2\n\n其中：\n\n1 ≤ n ≤ 2*10^5\n1 ≤ m ≤ 2*10^5\n1 ≤ l[i] ≤ r[i] ≤ n\n\n分析需要注意的是按照题目的说法给出的区间[1,2]指的不是下表，而是第几个数，题目也比较简单，如果前面的部分看懂了这题没啥问题，简单练下手\nstatic int d[200001], sum[200001];int oddnumber(int n, int m, int *l, int lLen, int *r, int rLen) &#123;    for (int i = 0; i &lt; m; i++)        d[l[i]]++, d[r[i] + 1]--;    for (int i = 1; i &lt;= n; i++)        sum[i] = sum[i - 1] + d[i];    int Ans = 0;    for (int i = 1; i &lt;= n; i++)        if ((sum[i] + m) % 2 == 1) Ans++;    return Ans;&#125;\n\n课后作业题目链接\n题目描述在 n x n 的格子上有 m 个地毯。\n给出这些地毯的信息，问每个点被多少个地毯覆盖。\n输入格式第一行，两个正整数 n,m。意义如题所述。\n接下来 m 行，每行两个坐标 (x_1,y_1) 和 (x_2,y_2)，代表一块地毯，左上角是 (x_1,y_1)，右下角是 (x_2,y_2)。\n输出格式输出 n 行，每行 n 个正整数。\n第 i 行第 j 列的正整数表示 (i,j) 这个格子被多少个地毯覆盖。\n样例样例输入\n5 32 2 3 33 3 5 51 2 1 4\n\n样例输出\n0 1 1 1 00 1 1 0 00 1 2 1 10 0 1 1 10 0 1 1 1\n\n样例解释\n覆盖第一个地毯后：\n\n\n\n0\n0\n0\n0\n0\n\n\n\n0\n1\n1\n0\n0\n\n\n0\n1\n1\n0\n0\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n0\n0\n0\n\n\n覆盖第一、二个地毯后：\n\n\n\n0\n0\n0\n0\n0\n\n\n\n0\n1\n1\n0\n0\n\n\n0\n1\n2\n1\n1\n\n\n0\n0\n1\n1\n1\n\n\n0\n0\n1\n1\n1\n\n\n覆盖所有地毯后：\n\n\n\n0\n1\n1\n1\n0\n\n\n\n0\n1\n1\n0\n0\n\n\n0\n1\n2\n1\n1\n\n\n0\n0\n1\n1\n1\n\n\n0\n0\n1\n1\n1\n\n\n数据范围对于 20% 的数据，有 n &lt; 50，m &lt; 100。\n对于 100% 的数据，有 n,m &lt; 1000。\n作业答案典型的二维差分，需要注意的点还是：\n\n注意数组越界，将特殊情况单独进行讨论\n区间指的不是下表，而是第几个数\nmalloc为d开辟空间后需要初始化\n\n#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;void add(int x1, int y1, int x2, int y2, int **d) &#123;    d[x1][y1] += 1;    d[x1][y2 + 1] -= 1;    d[x2 + 1][y1] -= 1;    d[x2 + 1][y2 + 1] += 1;&#125;void pre_sum(int numsSize, int **d, int **sum) &#123;    sum[0][0] = d[0][0];    for (int i = 1; i &lt; numsSize; i++) sum[i][0] = sum[i - 1][0] + d[i][0];    for (int j = 1; j &lt; numsSize; j++) sum[0][j] = sum[0][j - 1] + d[0][j];    for (int i = 1; i &lt; numsSize; i++)        for (int j = 1; j &lt; numsSize; j++)            sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + d[i][j];&#125;int main() &#123;    int n, m;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    int **d = (int **) malloc(sizeof(int *) * (n + 1));    for (int i = 0; i &lt; n + 1; ++i) &#123;        d[i] = (int *) malloc(sizeof(int) * (n + 1));        memset(d[i], 0, sizeof(int) * (n + 1));    &#125;    int **sum = (int **) malloc(sizeof(int *) * n);    for (int i = 0; i &lt; n; i++)        sum[i] = (int *) malloc(sizeof(int) * n);    while (m--) &#123;        int x1, x2, y1, y2;        scanf(&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);        add(x1 - 1, y1 - 1, x2 - 1, y2 - 1, d);    &#125;    pre_sum(n, d, sum);  // 求出d的前缀和    for (int i = 0; i &lt; n; i++) &#123;        for (int j = 0; j &lt; n; j++)            printf(&quot;%d &quot;, sum[i][j]);        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\n\n3. 双指针通过题目我们可以更加直观的了解，会在题目分析中进行详细解释，在此先不做介绍。\n例题1 移除元素题目题目链接\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。不需要考虑数组中超出新长度后面的元素。 \n示例 1：输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。\n示例 2：输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n其中：\n\n0 &lt;&#x3D; nums.length &lt;&#x3D; 100\n0 &lt;&#x3D; nums[i] &lt;&#x3D; 50\n0 &lt;&#x3D; val &lt;&#x3D; 100\n\n分析通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n定义快慢指针\n\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n第一个指针（快指针）负责遍历，第二个指针（慢指针）负责接收第一个指针指向的不是删除元素的值\n// 时间复杂度：O(n)// 空间复杂度：O(1)int removeElement(int *nums, int numsSize, int val)&#123;    int slowIndex = 0;    for (int fastIndex = 0; fastIndex &lt; numsSize; fastIndex++)    &#123;        if (val != nums[fastIndex])        &#123;            nums[slowIndex++] = nums[fastIndex];        &#125;    &#125;    return slowIndex;&#125;\n\n相向双指针方法：基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素\n// 时间复杂度：O(n)// 空间复杂度：O(1)int removeElement(int *nums, int numsSize, int val)&#123;        int leftIndex = 0;        int rightIndex = numsSize - 1;        while (leftIndex &lt;= rightIndex) &#123;            // 找左边等于val的元素            while (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;                ++leftIndex;            &#125;            // 找右边不等于val的元素            while (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;                -- rightIndex;            &#125;            // 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] = nums[rightIndex--];            &#125;        &#125;        return leftIndex;   // leftIndex一定指向了最终数组末尾的下一个元素&#125;\n\n课后作业作业一题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。注意：如果对空文本输入退格字符，文本继续为空。【附加要求：不能使用额外空间】\n示例 1：输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”输出：true解释：s 和 t 都会变成 “ac”。\n示例 2：输入：s &#x3D; “ab##”, t &#x3D; “c#d#”输出：true解释：s 和 t 都会变成 “”。\n示例 3：输入：s &#x3D; “a#c”, t &#x3D; “b”输出：false解释：s 会变成 “c”，但 t 仍然是 “b”。\n其中：\n\n1 &lt;= s.length, t.length &lt;= 200\ns 和 t 只含有小写字母以及字符 &#39;#&#39;\n\n作业二题目链接\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。要求时间复杂度为O(n)\n示例 1：输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]\n示例 2：输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]\n其中：\n\n1 &lt;&#x3D; nums.length &lt;&#x3D; 十的四次方\n负十的四次方&lt;&#x3D; nums[i] &lt;&#x3D; 十的四次方\nnums 已按 非递减顺序 排序\n\n作业答案作业一一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。\n具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：\n\n若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1\n若该字符为普通字符\n若 skip 为 0，则说明当前字符不需要删去\n若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1\n\n这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。\nbool backspaceCompare(char* S, char* T) &#123;    int i = strlen(S) - 1, j = strlen(T) - 1;    int skipS = 0, skipT = 0;    while (i &gt;= 0 || j &gt;= 0) &#123;        while (i &gt;= 0) &#123;            // 接收到字符或者S遍历结束时跳出循环            if (S[i] == &#x27;#&#x27;) &#123;                skipS++, i--;            &#125; else if (skipS &gt; 0) &#123;                skipS--, i--;            &#125; else &#123;                break;            &#125;        &#125;        while (j &gt;= 0) &#123;            // 接收到字符或者T遍历结束时跳出循环            if (T[j] == &#x27;#&#x27;) &#123;                skipT++, j--;            &#125; else if (skipT &gt; 0) &#123;                skipT--, j--;            &#125; else &#123;                break;            &#125;        &#125;        if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;            // S和T均接收到了字符，进行比较            if (S[i] != T[j]) &#123;                return false;            &#125;        &#125; else &#123;            // 至少一个字符串遍历结束，另一个遍历结束或者接收到了字符            if (i &gt;= 0 || j &gt;= 0) &#123;                return false;            &#125;        &#125;        i--, j--;    &#125;    return true;&#125;\n\n作业二方法一：正数负数两侧分别平方，负数侧单调递减，正数侧单调递增，可以使用归并排序，学完排序模块回顾即可。\n方法二：使用两个指针分别指向位置 0 和 n-1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。\nint* sortedSquares(int* nums, int numsSize, int* returnSize) &#123;    int* ans = malloc(sizeof(int) * numsSize);    *returnSize = numsSize;    for (int i = 0, j = numsSize - 1, pos = numsSize - 1; i &lt;= j;) &#123;        if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;            ans[pos] = nums[i] * nums[i];            ++i;        &#125; else &#123;            ans[pos] = nums[j] * nums[j];            --j;        &#125;        --pos;    &#125;    return ans;&#125;\n\n4. 滑动窗口例题1 长度最小的子数组题目题目链接\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n要求时间复杂度不超过O(nlogn) \n示例 1：输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例 2：输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1\n示例 3：输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0\n其中：\n\n1 &lt;&#x3D; target &lt;&#x3D; 十的九次方\n1 &lt;&#x3D; nums.length &lt;&#x3D; 十的五次方\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 十的五次方\n\n分析接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。\n所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。\n这里还是以题目中的示例来举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程：最后找到 4，3 是最短距离。\n其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。\n在本题中实现滑动窗口，主要确定如下三点：\n\n窗口内是什么？\n如何移动窗口的起始位置？\n如何移动窗口的结束位置？\n\n窗口就是满足其和 ≥ s 的长度最小的 连续 子数组。窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。\n代码int minSubArrayLen(int target, int *nums, int numsSize)&#123;    int result = INT_MAX;    int sum = 0;         // 滑动窗口数值之和    int i = 0;           // 滑动窗口起始位置    int subLength = 0;   // 滑动窗口的长度    for (int j = 0; j &lt; numsSize; j++)    &#123;        sum += nums[j];        // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件        while (sum &gt;= target)        &#123;            subLength = (j - i + 1); // 取子序列的长度            result = result &lt; subLength ? result : subLength;            sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）        &#125;    &#125;    // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列    return result == INT_MAX ? 0 : result;&#125;\n\n课后作业题目题目链接\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。要求在o(n) 时间内解决此问题。\n注意：\n\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n示例 1：输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”输出：”BANC”\n示例 2：输入：s &#x3D; “a”, t &#x3D; “a”输出：”a”\n示例 3:输入: s &#x3D; “a”, t &#x3D; “aa”输出: “”解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。\n其中：\n\n1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 10^5\ns 和 t 由英文字母组成\n\n说明这道题虽然标的是困难但实际上没那么难，都是同一题型，对于C++、Java哈希表直接用就行，C的话需要我们自己构造一下，关于哈希表的详细知识会在”查找“模块中进行详细解释，感兴趣的同学也可先行了解\n作业答案分析采用滑动窗口解决该问题。\n我们可以先记录t中字母的种类以及各字母需要的数量，显然，外层循环条件为右侧指针小于s的长度，在右侧指针推进时我们可以判断这个字母是否已经让满足数量，记录窗口中字母满足的个数，如果满足个数与t中的字母种类数相同，证明已达到要求，开始让左侧指针进行移动，减小字符串长度，直到不再满足要求。循环执行下去，就可得到我们想要的结果。\n代码char *minWindow(char *s, char *t)&#123;    int lent = strlen(t), lens = strlen(s);    int len = lens + 1; //用来判断可能会出现的找不到的情况，因为找到的话那字符串总长不会超过lens    int *need = (int *)malloc(sizeof(int) * 128); //字符串T中的字母种类和个数，用字母ASCII码做下标，值作为个数    memset(need, 0, sizeof(int) * 128);    int *window = (int *)malloc(sizeof(int) * 128); //滑动窗口中包含的字母种类和个数，规则同need    memset(window, 0, sizeof(int) * 128);    int left = 0, right = 0; //窗的左右边界，这是一个左闭右开的窗    int cnt = 0;    //字符串T中的字母种类    int valid = 0; //窗口中满足字符串T中的字母种类，比如字符串T中有字母a共10个，那么窗口中有10个a的时候这个值++    int start = 0;    //记录字符串T    for (int i = 0; i &lt; lent; i++)    &#123;        need[t[i]]++;    &#125;    for (int i = 0; i &lt; 128; i++)    &#123; //字符串T中字母种类        if (need[i] != 0)        &#123;            cnt++;        &#125;    &#125;    while (right &lt; lens) //边界条件    &#123;        char c = s[right]; //将要移入窗口的字符        right++;           //扩窗        if (need[c] != 0)        &#123; //窗口数据更新            window[c]++;            if (window[c] == need[c])            &#123;                valid++;            &#125;        &#125;        while (valid == cnt)        &#123; //判断左侧窗口是否要收缩            if (right - left &lt; len)            &#123; //更新最小覆盖子串                start = left;                len = right - left;            &#125;            char d = s[left]; //将要移出窗口的字符            left++;           //缩窗            if (need[d] != 0)            &#123;                if (window[d] == need[d])                &#123;                    valid--;                &#125;                window[d]--;            &#125;        &#125;    &#125;    if (len != lens + 1)    &#123; //返回最小覆盖子串        char *res = (char *)malloc(sizeof(char) * (len + 1));        *res = &#x27;\\0&#x27;;        strncat(res, s + start, len);        return res;    &#125;    return &quot;&quot;;&#125;\n\n5. 螺旋矩阵例题1 螺旋矩阵Ⅱ题目题目链接\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n示例 1：\n输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n示例 2：\n输入：n = 1输出：[[1]]\n\n其中：1&lt;&#x3D; n &lt;&#x3D;20\n分析本体不涉及具体的算法，但是对过程的分析能力较为考察。如果不先对题目进行分析直接判断最后很可能造成混乱。\n当n为奇数时，最后会剩下单独的一个数，这个数我们最后单独处理，总共需要走n&#x2F;2圈（奇数向下取整）当n为偶数时，总共需要走n&#x2F;2圈我们可以写为定义loop为n&#x2F;2，外层循环写为while(loop--)，接着用4次循环进行右下左上的遍历，为保持统一性，我们输出时采用左闭右开。\n代码int **generateMatrix(int n, int *returnSize, int **returnColumnSizes)&#123;    int startx = 0, starty = 0; // 定义每循环一个圈的起始位置    int loop = n / 2;           // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理    int count = 1;              // 用来给矩阵中每一个空格赋值    int offset = 1;             // 每一圈循环，需要控制每一条边遍历的长度    int i, j;    *returnSize = n;    *returnColumnSizes = (int *)malloc(sizeof(int) * n);    int **res = (int **)malloc(sizeof(int *) * n);    for (i = 0; i &lt; n; i++)    &#123;        res[i] = (int *)malloc(sizeof(int) * n);        (*returnColumnSizes)[i] = n;    &#125;    while (loop--)    &#123;        i = startx;        j = starty;        // 下面开始的四个for就是模拟转了一圈        // 模拟填充上行从左到右(左闭右开)        for (j = starty; j &lt; starty + n - offset; j++)        &#123;            res[startx][j] = count++;        &#125;        // 模拟填充右列从上到下(左闭右开)        for (i = startx; i &lt; startx + n - offset; i++)        &#123;            res[i][j] = count++;        &#125;        // 模拟填充下行从右到左(左闭右开)        for (; j &gt; starty; j--)        &#123;            res[i][j] = count++;        &#125;        // 模拟填充左列从下到上(左闭右开)        for (; i &gt; startx; i--)        &#123;            res[i][j] = count++;        &#125;        // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)        startx++;        starty++;        // offset 控制每一圈里每一条边遍历的长度        offset += 2;    &#125;    // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值    if (n % 2)    &#123;        res[n / 2][n / 2] = count;    &#125;    return res;&#125;\n\n课后作业题目题目链接\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]\n示例 2：输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n其中：\n\nm &#x3D;&#x3D; matrix.length\nn &#x3D;&#x3D; matrix[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 10\n-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100\n\n答案这题跟例题差不多，把正方形换成了矩形，过程倒了过来，作为一个巩固练习，在此不多赘述。\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &#123;    if (matrixSize == 0 || matrixColSize[0] == 0) &#123;        *returnSize = 0;        return NULL;    &#125;    int rows = matrixSize, columns = matrixColSize[0];    int total = rows * columns;    int* order = malloc(sizeof(int) * total);    *returnSize = 0;    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;        for (int column = left; column &lt;= right; column++) &#123;            order[(*returnSize)++] = matrix[top][column];        &#125;        for (int row = top + 1; row &lt;= bottom; row++) &#123;            order[(*returnSize)++] = matrix[row][right];        &#125;        if (left &lt; right &amp;&amp; top &lt; bottom) &#123;            for (int column = right - 1; column &gt; left; column--) &#123;                order[(*returnSize)++] = matrix[bottom][column];            &#125;            for (int row = bottom; row &gt; top; row--) &#123;                order[(*returnSize)++] = matrix[row][left];            &#125;        &#125;        left++;        right--;        top++;        bottom--;    &#125;    return order;&#125;\n\n附加题 二分查找二分查找作为程序员的一项基本技能，是面试官最常使用来考察程序员基本素质的算法之一，也是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。\n一般在出现以下特性时考虑二分查找\n\n待查找的数组有序或者部分有序\n要求时间复杂度低于O(n)，或者直接要求时间复杂度为O(log n)\n\n需要注意的是一旦数据中有重复元素，使用二分查找法返回的元素下标可能不是唯一的\n二分查找最重要的便是确定不变量，在二分查找中区间的定义便是不变量，在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)，下面将分别进行展开。\n写法一我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 。\n区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：\n\nwhile (left &lt;= right) 要使用 &lt;&#x3D; ，因为left == right是有意义的，所以使用 &lt;&#x3D;\nif (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle + 1\n\n写法二如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。\n\nwhile (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的\nif (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]\nif (nums[middle] &lt; target) left 更新为 middle + 1，因为左侧与右侧不同，是闭区间，因为当前这个nums[middle]一定不是target，直接指向middle + 1即可\n\n例题1 搜索插入位置题目题目链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n其中：\n\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4\n-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4\nnums 为 无重复元素 的 升序 排列数组\n-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4\n\n分析数组已排序、时间复杂度为 O(log n) ，我们首先可以考虑二分查找\n区间类型的话我们可以选用闭区间（其他区间不再举例），也就是说循环可以写为while (left &lt; right)，当目标值与nums[middle]不相等时，根据情况将right设置为middle - 1，或left设置为middle + 1即可。\n找到数字时返回索引：此时middle的值即为目标值索引未找到数字时返回要插入的位置：此时high或low即为需要插入的位置\n最后注意一个小细节，left、right都是很大的数，计算middle的过程中，二者相加可能会溢出，造成除以二之后的值并不是我们想要的。所以我们可以将middle = (left + right)/2; 修改为middle = left + ((right - left) / 2);。\n代码int searchInsert(int* nums, int numsSize, int target)&#123;    int right=numsSize-1,left=0,middle;    while(left&lt;=right)&#123;        middle = left + ((right - left) / 2);        if(nums[middle]==target)&#123;            return middle;        &#125; else if( nums[middle]&lt;target)&#123;            left = middle + 1;        &#125; else &#123;            right = middle -1;        &#125;    &#125;    return left;&#125;\n\n例题2 在排序数组中查找元素的第一个和最后一个位置题目题目链接\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8输出：[3,4]\n示例 2输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6输出：[-1,-1]\n示例 3输入：nums &#x3D; [], target &#x3D; 0输出：[-1,-1]\n其中：\n\n0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n-10^9&lt;&#x3D; nums[i] &lt;&#x3D; 10^9\nnums 是一个非递减数组\n-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9\n\n分析数组已排序、时间复杂度为 O(log n) ，先考虑二分查找，但是这题看着容易但实现起来细节方面还是比较绕的，我们首先把情况分析一下：\n\n情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5}，target为6，此时应该返回{-1, -1}\n情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7}，target为5，此时应该返回{-1, -1}\n情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7}，target为6，此时应该返回{1, 1}\n\n而我们的目标是左右边界两个\n寻找右边界\n寻找target的右边界（不包括target），记为rightBorder区间选用闭区间，即循环写为while (left &lt;= right)\n// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一int getRightBorder(int *nums, int numsSize, int target) &#123;    // 定义target在左闭右闭的区间里，[left, right]    int left = 0, right = numsSize - 1;     int rightBorder = -2; // 记录rightBorder没有被赋值的情况    while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效        int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2        if (nums[middle] &gt; target) &#123;            right = middle - 1; // target 在左区间，所以[left, middle - 1]        &#125; else &#123; // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界            left = middle + 1;            rightBorder = left;        &#125;    &#125;    // 情况一，这些数都比target大，返回-2    // 情况二，位于中间，但是没有target，由于rightBorder每次都是middle + 1跟进，最后的值是插入位置右侧的数    // 情况三，如果找到了，这里就是目标值的右侧一个数    return rightBorder;\t&#125;\n\n寻找左边界\n// 二分查找，寻找target的左边界leftBorder（不包括target）// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一int getLeftBorder(int *nums, int numsSize, int target) &#123;    int left = 0;    int right = numsSize - 1; // 定义target在左闭右闭的区间里，[left, right]    int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况    while (left &lt;= right) &#123;        int middle = left + ((right - left) / 2);        if (nums[middle] &gt;= target) &#123; // 寻找左边界，就要在nums[middle] == target的时候更新right            right = middle - 1;            leftBorder = right;        &#125; else &#123;            left = middle + 1;        &#125;    &#125;    // 情况一，这些数都比target小，返回-2    // 情况二，位于中间，但是没有target，由于leftBorder每次都是middle - 1跟进，最后的值是插入位置左侧的数    // 情况三，如果找到了，这里就是目标值的左侧一个数    return leftBorder;&#125;\n\n处理三中情况\n\n二者中有一个为-2，代表处于情况一，返回[-1,-1]即可\nrightBorder - leftBorder &gt; 1 代表情况三，这个数存在返回[ leftBorder + 1, rightBorder - 1 ] 即可\n剩余为情况二，返回[-1,-1]即可\n\nint *searchRange(int *nums, int numsSize, int target, int *returnSize)&#123;\t// 为了直观一些写的比较啰嗦    int leftBorder = getLeftBorder(nums, numsSize, target);    int rightBorder = getRightBorder(nums, numsSize, target);    int *answer = malloc(sizeof(int) * 2);    if (leftBorder == -2 || rightBorder == -2)    &#123;        answer[0] = -1;        answer[1] = -1;    &#125;    else if (rightBorder - leftBorder &gt; 1)    &#123;        answer[0] = leftBorder + 1;        answer[1] = rightBorder - 1;    &#125;    else    &#123;        answer[0] = -1;        answer[1] = -1;    &#125;    *returnSize = 2;    return answer;&#125;\n\n代码#include&lt;malloc.h&gt;int *searchRange(int *nums, int numsSize, int target, int *returnSize)&#123;    int leftBorder = getLeftBorder(nums, numsSize, target);    int rightBorder = getRightBorder(nums, numsSize, target);    int *answer = malloc(sizeof(int) * 2);    if (leftBorder == -2 || rightBorder == -2)    &#123;        answer[0] = -1;        answer[1] = -1;    &#125;    else if (rightBorder - leftBorder &gt; 1)    &#123;        answer[0] = leftBorder + 1;        answer[1] = rightBorder - 1;    &#125;    else    &#123;        answer[0] = -1;        answer[1] = -1;    &#125;    *returnSize = 2;    return answer;&#125;int getLeftBorder(int *nums, int numsSize, int target)&#123;    int left = 0;    int right = numsSize - 1; // 定义target在左闭右闭的区间里，[left, right]    int leftBorder = -2;      // 记录一下leftBorder没有被赋值的情况    while (left &lt;= right)    &#123;        int middle = left + ((right - left) / 2);        if (nums[middle] &gt;= target)        &#123; // 寻找左边界，就要在nums[middle] == target的时候更新right            right = middle - 1;            leftBorder = right;        &#125;        else        &#123;            left = middle + 1;        &#125;    &#125;    return leftBorder;&#125;int getRightBorder(int *nums, int numsSize, int target)&#123;    // 定义target在左闭右闭的区间里，[left, right]    int left = 0, right = numsSize - 1;    int rightBorder = -2; // 记录rightBorder没有被赋值的情况    while (left &lt;= right)    &#123;                                             // 当left==right，区间[left, right]依然有效        int middle = left + ((right - left) / 2); // 防止溢出 等同于(left + right)/2        if (nums[middle] &gt; target)        &#123;            right = middle - 1; // target 在左区间，所以[left, middle - 1]        &#125;        else        &#123; // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界            left = middle + 1;            rightBorder = left;        &#125;    &#125;    // 情况一，这些数都比target大，返回-2    // 情况二，位于中间，但是没有target，由于rightBorder每次都是middle + 1跟进，最后的值是插入位置右侧的数    // 情况三，如果找到了，这里就是目标值的右侧一个数    return rightBorder;&#125;\n\n课后作业题目题目链接\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 \n示例 1：输入：x &#x3D; 4输出：2\n示例 2：输入：x &#x3D; 8输出：2解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。\n其中：0 &lt;= x &lt;= 2^31 - 1\n作业答案采用二分查找，下界为1上界为x，比较中间元素的平方与x的大小关系，逐步缩小范围，没有太大难度，简单练习一下二分查找。\nint mySqrt(int x)&#123;    int l = 0, r = x, ans = -1;    while (l &lt;= r)    &#123;        int mid = l + (r - l) / 2;        if ((long long)mid * mid &lt;= x)        &#123;            ans = mid;            l = mid + 1;        &#125;        else        &#123;            r = mid - 1;        &#125;    &#125;    return ans;&#125;\n\n\n时间复杂度：O(log x)，即为二分查找需要的次数。\n空间复杂度：O(1)。\n\n","categories":["技术","算法"],"tags":["算法"]},{"title":"算法总结——队列","url":"/2022-07-09/724029e104d2/","content":"0. 理论基础队列queue\n在计算机科学中，一个队列queue 是一种特殊的抽象数据类型(Abstract Data Type) 或其中元素保持一定顺序的集合。其中最主要的（或则说唯一的）的在此集合上的操作是加元素到队列的末端，被称为入队&#x2F;入列 enqueue；将元素从队列的前段移除，则称为出队&#x2F;出列 dequeue；这让队列成为了先进先出（First-In-First-Out，FIFO）的数据结构。在先进先出的数据结构中，添加到队列中的第一个元素将会是第一个被删除的元素。队列是线性数据结构中的一种，或者更抽象地说，是一种顺序收集sequential collection。\n双端队列 Double-ended queue\n双端队列 Double-ended queue，简称为Deque，和队列的操作方式出列同名但不是一个意思。 在计算机科学中，双端队列(缩写为deque) 是一种抽象数据类型，它概括了一个队列，其中的元素可以从前(头) 或后(尾) 添加或删除。因此也经常被称为首尾链表。\n主要操作\nInitQueue(&amp;Q)：初始化队列，构造一个空队列Q。\nQueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\nEnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾。\nDeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。\nGetHead(Q, &amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给X。\n\n实现\n顺序存储结构—-基于数组\n链式存储结构—-基于单链表\n\n顺序存储结构队列的主要操作在队首和队尾处完成 ，要保留队头、队尾两个位置方便操作实现\n#define MAXSIZE 5typedef struct&#123;    elemtype data[MAXSIZE];    int f, r; //队首和队尾指针&#125; SeQueue;SeQueue q;\n\n说明：elemtype代表队列中数据元素的类型，具体应用时，队列中的数据元素是什么类型的，就将elemtype定义成相应类型\n基本操作：\n// 初始化q.f=0;q.r=0;// 入队if (q.r &lt; MAXSIZE) &#123; // 判断是否溢出    q.data[q.r]=x;    q.r++;&#125; else printf(“overflow”);// 出队if ( q.f != q.r ) q.f++;\n\n思考一个问题，随着不断入队出队，q.f、q.r一直在增长，最后q.r &#x3D; MAXSIZE时，即使队列只有或者为空均会因为没有空间而无法再插入——顺序队列存在假溢出。\n解决方式：\n\n每删除一个数据元素，余下的所有数据元素顺次移动一个位置——效率太低\n循环队列，首尾相接\n\n循环队列\n将正常的数组空间看成环状的，通过求余（%，MOD）运算可实现数组的首尾相接\n\n判断队满\n队空和队满时q.f&#x3D;&#x3D;q.r，无法根据队首和队尾指针的相对位置判断队列是处于“空”还是处于“满”的状态\n\n方法1：设一计数器，初始化时计数器清0，入队时，计数器+1，出队时计数器-1\n方法2：为区分队空、队满，牺牲一个存储位置，当(q.r+1)%MAXSIZE&#x3D;&#x3D;q.f时认为队满了，q.r&#x3D;&#x3D;q.f为队空\n\n基本操作\n// 初始化q.f=0;q.r=0;// 入队if( (q.r+1)%MAXSIZE==q.f ) &#123; // 此处为方法2，判断是否溢出    q.data[q.r]=x;    q.r=(q.r+1)%MAXSIZE;&#125; else printf(“overflow”);// 出队if( q.r==q.f ) q.f = (q.f+1)%MAXSIZE;\n\n链式存储结构f为队首指针，指示链队的队首位置r为队尾指针，指示链队的队尾位置\n比较基础，学完链表之后这个挺轻松的，不多解释\n// 入队s=(LinkList)malloc(sizeof(Node));s-&gt;data=x;r-&gt;next=s;s-&gt;next=NULL;r=s;// 出队s=f-&gt;next;f-&gt;next=s-&gt;next;free(s);\n\n1.循环队列题目链接\n请不要使用内置的队列库。\n设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。\n循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。\n你的实现应该支持如下操作：\n\nMyCircularQueue(k): 构造器，设置队列长度为 k 。\nFront: 从队首获取元素。如果队列为空，返回 -1 。\nRear: 获取队尾元素。如果队列为空，返回 -1 。\nenQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。\ndeQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。\nisEmpty(): 检查循环队列是否为空。\nisFull(): 检查循环队列是否已满。\n\n其中：\n\n所有的值都在 0 至 1000 的范围内；\n操作数将在 1 至 1000 的范围内；\n\n答案\n注意事项：\n\n在C语言中负数求余：被除数的绝对值与除数绝对值取余的值即为余数绝对值，余数符号与被除数一致。\nC语言中使用bool可以#include&lt;stdbool.h&gt;\n\ntypedef struct &#123;    int MAXSIZE;    int *data;    int f, r;&#125; MyCircularQueue;MyCircularQueue *myCircularQueueCreate(int k) &#123;    MyCircularQueue *CQ = (MyCircularQueue *) malloc(sizeof(MyCircularQueue));    CQ-&gt;r = 0, CQ-&gt;f = 0;    CQ-&gt;MAXSIZE = k + 1; // 牺牲一个存储位置，判断队满    CQ-&gt;data = (int *) malloc(sizeof(int *) * CQ-&gt;MAXSIZE);    return CQ;&#125;bool myCircularQueueEnQueue(MyCircularQueue *obj, int value) &#123;    if ((obj-&gt;r + 1) % obj-&gt;MAXSIZE != obj-&gt;f) &#123;        obj-&gt;data[obj-&gt;r] = value;        obj-&gt;r = (obj-&gt;r + 1) % obj-&gt;MAXSIZE;        return true;    &#125; else return false;&#125;bool myCircularQueueDeQueue(MyCircularQueue *obj) &#123;    if (obj-&gt;f != obj-&gt;r) &#123;        obj-&gt;f = (obj-&gt;f + 1) % obj-&gt;MAXSIZE;        return true;    &#125; else return false;&#125;int myCircularQueueFront(MyCircularQueue *obj) &#123;    if (obj-&gt;f != obj-&gt;r) return obj-&gt;data[obj-&gt;f];    else return -1;&#125;int myCircularQueueRear(MyCircularQueue *obj) &#123;    if (obj-&gt;f != obj-&gt;r) return obj-&gt;data[(obj-&gt;r - 1 + obj-&gt;MAXSIZE) % obj-&gt;MAXSIZE];    else return -1;&#125;bool myCircularQueueIsEmpty(MyCircularQueue *obj) &#123;    return obj-&gt;f == obj-&gt;r;&#125;bool myCircularQueueIsFull(MyCircularQueue *obj) &#123;    return (obj-&gt;r + 1) % obj-&gt;MAXSIZE == obj-&gt;f;&#125;void myCircularQueueFree(MyCircularQueue *obj) &#123;    free(obj-&gt;data);    free(obj);&#125;\n\n2. 循环双端队列题目链接\n设计实现双端队列。\n实现 MyCircularDeque 类:\n\nMyCircularDeque(int k) ：构造函数,双端队列最大为 k 。\nboolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。\nboolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。\nboolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。\nboolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。\nint getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。\nint getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。\nboolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false 。\nboolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。\n\n示例 1：\n输入[&quot;MyCircularDeque&quot;, &quot;insertLast&quot;, &quot;insertLast&quot;, &quot;insertFront&quot;, &quot;insertFront&quot;, &quot;getRear&quot;, &quot;isFull&quot;, &quot;deleteLast&quot;, &quot;insertFront&quot;, &quot;getFront&quot;][[3], [1], [2], [3], [4], [], [], [], [4], []]输出[null, true, true, true, false, 2, true, true, true, 4]\n\n其中：\n\n1 &lt;&#x3D; k &lt;&#x3D; 1000\n0 &lt;&#x3D; value &lt;&#x3D; 1000\ninsertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull 调用次数不大于 2000 次\n\n代码\n注意实现与循环队列相同，只需要在循环队列的基础上加上队头删除、队尾插入，其余保持不变，没啥难度，不多介绍\ntypedef struct &#123;    int MAXSIZE;    int *data;    int f, r;&#125; MyCircularDeque;MyCircularDeque *myCircularDequeCreate(int k) &#123;    MyCircularDeque *CD = (MyCircularDeque *) malloc(sizeof(MyCircularDeque));    CD-&gt;r = 0, CD-&gt;f = 0;    CD-&gt;MAXSIZE = k + 1; // 牺牲一个存储位置，判断队满    CD-&gt;data = (int *) malloc(sizeof(int *) * CD-&gt;MAXSIZE);    return CD;&#125;bool myCircularDequeInsertFront(MyCircularDeque *obj, int value) &#123;    if ((obj-&gt;r + 1) % obj-&gt;MAXSIZE != obj-&gt;f) &#123;        obj-&gt;f = (obj-&gt;f - 1 + obj-&gt;MAXSIZE) % obj-&gt;MAXSIZE; // 头指针向前走一位，然后插入数据        obj-&gt;data[obj-&gt;f] = value;        return true;    &#125; else return false;&#125;bool myCircularDequeInsertLast(MyCircularDeque *obj, int value) &#123;    if ((obj-&gt;r + 1) % obj-&gt;MAXSIZE != obj-&gt;f) &#123;        obj-&gt;data[obj-&gt;r] = value;        obj-&gt;r = (obj-&gt;r + 1) % obj-&gt;MAXSIZE;        return true;    &#125; else return false;&#125;bool myCircularDequeDeleteFront(MyCircularDeque *obj) &#123;    if (obj-&gt;f != obj-&gt;r) &#123;        obj-&gt;f = (obj-&gt;f + 1) % obj-&gt;MAXSIZE;        return true;    &#125; else return false;&#125;bool myCircularDequeDeleteLast(MyCircularDeque *obj) &#123;    if (obj-&gt;f != obj-&gt;r) &#123;        obj-&gt;r = (obj-&gt;r - 1 + obj-&gt;MAXSIZE) % obj-&gt;MAXSIZE;        return true;    &#125; else return false;&#125;int myCircularDequeGetFront(MyCircularDeque *obj) &#123;    if (obj-&gt;f != obj-&gt;r) return obj-&gt;data[obj-&gt;f];    else return -1;&#125;int myCircularDequeGetRear(MyCircularDeque *obj) &#123;    if (obj-&gt;f != obj-&gt;r) return obj-&gt;data[(obj-&gt;r - 1 + obj-&gt;MAXSIZE) % obj-&gt;MAXSIZE];    else return -1;&#125;bool myCircularDequeIsEmpty(MyCircularDeque *obj) &#123;    return obj-&gt;f == obj-&gt;r;&#125;bool myCircularDequeIsFull(MyCircularDeque *obj) &#123;    return (obj-&gt;r + 1) % obj-&gt;MAXSIZE == obj-&gt;f;&#125;void myCircularDequeFree(MyCircularDeque *obj) &#123;    free(obj-&gt;data);    free(obj);&#125;\n\n3. 单调队列单调队列，顾名思义，是一种具有单调性的队列。众所周知，单调性有单调递增和单调递减两种，相应的单调队列也分为单调递增队列和单调递减队列两种。\n\n单调递增队列：保证队列头元素一定是当前队列的最小值，用于维护区间的最小值。\n单调递减队列：保证队列头元素一定是当前队列的最大值，用于维护区间的最大值。\n\n单独解释起来比较抽象，下面我们通过例题进行讲解\n例题一 滑动窗口最大值题目链接\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值\n要求：在线性时间复杂度内解决此题\n示例 1：输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7示例 2：输入：nums = [1], k = 1输出：[1]\n\n说明：\n\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4\n1 &lt;&#x3D; k &lt;&#x3D; nums.length\n\n分析在说具体怎么实现一个单调队列之前，先来一个简单的例子，感受一下：\n假设给定数列：[ 1, 3, -1, -3, 5, 3, 6, 7 ]，区间长度为3。\n用单调队列实现时动画如下：\n\n注意：一般的队列只能从队尾入队、队首出队，为了保持单调队列的单调性，单调队列除具有这两种性质外，还可以从队尾出队。\n实现单调队列，主要分为三个部分：\n\n去尾操作：队尾元素出队列。当队列有新元素待入队，需要从队尾开始，删除影响队列单调性的元素，维护队列的单调性。(删除一个队尾元素后，就重新判断新的队尾元素)。去尾操作结束后，将该新元素入队列。\n删头操作：队头元素出队列。判断队头元素是否在待求解的区间之内，如果不在，就将其删除。（这个很好理解呀，因为单调队列的队头元素就是待求解区间的极值）\n取解操作：经过上面两个操作，取出 队列的头元素，就是当前区间的极值。\n\n关于细节方面的操作可见给出的代码注释\n代码int *maxSlidingWindow(int *nums, int numsSize, int k, int *returnSize)&#123;    int q[numsSize];    int hh = 0, tt = 0; // hh表示队头，tt表示队尾    // 先将第一个窗口装填完毕    for (int i = 0; i &lt; k; ++i)    &#123;        // hh &lt; tt --&gt; 队列中有数据  q[tt - 1] --&gt; 队尾的数据        // 如果队列中存在数据且队尾数据比当前数据小，弹出队尾，直到为空或大于等于当前数据        while (hh &lt; tt &amp;&amp; nums[i] &gt;= nums[q[tt - 1]])        &#123;            tt--;        &#125;        // 将当前数据的下标入队        q[tt++] = i;    &#125;    *returnSize = 0;    int *ans = (int *)malloc(sizeof(int) * (numsSize - k + 1));    ans[(*returnSize)++] = nums[q[hh]]; // 将第一个窗口结果写入ans中    for (int i = k; i &lt; numsSize; ++i)    &#123;        // 同上，不做解释        while (hh &lt; tt &amp;&amp; nums[i] &gt;= nums[q[tt - 1]])        &#123;            tt--;        &#125;        q[tt++] = i;        // 判断是否超出窗口大小，如果超出队首出队        while (q[hh] &lt;= i - k)        &#123;            hh++;        &#125;        // 队首为窗口最大数，写入ans中        ans[(*returnSize)++] = nums[q[hh]];    &#125;    return ans;&#125;\n\n课后作业作业一题目链接\n有一个长为 n 的序列 a ，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n以下是一个例子：\n该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。\n窗口位置\n最小值\n最大值\n[1 3 -1] -3 5 3 6 7\n-1\n3\n1 [3 -1 -3] 5 3 6 7\n-3\n3\n1 3 [-1 -3 5] 3 6 7\n-3\n5\n1 3 -1 [-3 5 3] 6 7\n-3\n5\n1 3 -1 -3 [5 3 6] 7\n3\n6\n1 3 -1 -3 5 [3 6 7]\n3\n7\n你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n输入格式：输入一共有两行，第一行有两个正整数 n, k。 第二行 n 个整数，表示序列 a\n输出格式：输出包含两个。第一行输出，从左至右，每个位置滑动窗口中的最小值。第二行输出，从左至右，每个位置滑动窗口中的最大值。\n输入样例：\n8 31 3 -1 -3 5 3 6 7\n\n输出样例：\n-1 -3 -3 -3 3 33 3 5 5 6 7\n\n说明\n题和例题一样，写法和力扣上面的不太一样，就是让大家自己重新写一遍，练一下单调队列。\n答案#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main() &#123;    int numsSize, k;    scanf(&quot;%d&quot;, &amp;numsSize);    scanf(&quot;%d&quot;, &amp;k);    int *nums = (int *) malloc(sizeof(int) * numsSize); // nums接收数组    int q[numsSize - k + 1]; // 单调队列存放于q中，存放数据的下标    int hh = 0, tt = 0; // hh表示队头，tt表示队尾    for (int i = 0; i &lt; numsSize; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        if (i - k + 1 &gt; q[hh]) // 如果队首出窗口，hh++            hh++;        while (hh &lt; tt &amp;&amp; nums[i] &lt;= nums[q[tt - 1]]) // 若队尾不单增，队尾出队            tt--;        q[tt++] = i;        if (i &gt;= k - 1) // 输出最小值结果            printf(&quot;%d &quot;, nums[q[hh]]);    &#125;    printf(&quot;\\n&quot;);    hh = 0, tt = 0;    for (int i = 0; i &lt; numsSize; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        if (i - k + 1 &gt; q[hh]) // 如果队首出窗口，hh++            hh++;        while (hh &lt; tt &amp;&amp; nums[i] &gt;= nums[q[tt - 1]]) // 若队尾不单减，队尾出队            tt--;        q[tt++] = i;        if (i &gt;= k - 1) // 输出最大值结果            printf(&quot;%d &quot;, nums[q[hh]]);    &#125;    return 0;&#125;\n\n作业二题目链接\n题目描述Uim 在公司里面当秘书，现在有 n 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 0，一旦老板心情到了 0 以下就会勃然大怒，炒了 Uim 的鱿鱼。\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\nUim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 n 条消息，Uim 可以按 k,k+1,k+2,……,n,1,2,……,k-1（事件编号）这种顺序通报。\n他希望知道，有多少个 k，可以使从 k 号事件开始通报到 n 号事件然后再从 1 号事件通报到 k-1 号事件可以让老板不发怒。\n输入格式第一行一个整数 n（1 &lt;&#x3D; n &lt;&#x3D;10^6），表示有 n 个消息。\n第二行 n 个整数，按时间顺序给出第 i 条消息的好坏度 Ai（-10^3&lt;&#x3D; Ai &lt;&#x3D; 10^3）。\n输出格式一行一个整数，表示可行的方案个数。\n样例样例输入\n4-3 5 1 2\n\n样例输出\n2\n\n【样例解释】通报事件的可行顺序（用编号表示）为 2–&gt;3–&gt;4–&gt;1 或 3–&gt;4–&gt;1–&gt;2（分别对应 k&#x3D;2 和 k&#x3D;3）通报事件的可行顺序（用好坏度表示）为 5–&gt;1–&gt;2–&gt;(-3) 或 1–&gt;2–&gt;(-3)–&gt;5\n【数据范围】对于 25% 的数据，n&lt;&#x3D;10^3；对于 75% 的数据，n&lt;&#x3D;10^4；对于 100% 的数据，1 &lt;&#x3D; n&lt;&#x3D; 10^6。\n答案首先我们先介入一种思想——断环为链，这样可以方便处理对于每一个k的情况。具体做法可以是将数组双倍展开，说通俗点就是在n后面再接上1到n-1的值\n以样例为例：-3 5 1 2，我们将其断环为链后可以得到这样的一组数据：-3 5 1 2 -3 5 1，并设其下标为1–7。当k&#x3D;1时，需要判断的就是下标1–4；当k&#x3D;2时，就是下标2–5；当k&#x3D;3时，就是下标3–6；当k&#x3D;4时，就是下标4–7（显然k不会等于5）。\n断环为链后，题目要求就变为了：对于每一个合法的k，都要满足k–(n+k-1)中，到任意一点的和都是非负的。根据我们之前学到的前缀和，我们可以通过sum[i]表示1–i的所有数的和，那么sum[j]-sum[i-1]就是i–j所有数的和。所以用前缀和预处理后，sum[i]-sum[k-1]就是k–i(k&lt;&#x3D;i&lt;&#x3D;n+k-1)的和了，我们只要判断这个和是否为负即可。\n既然这么说，那么是否要判断k–n+k-1中每一个数的和呢？当然不是，对比例题一，现在相当于在长度为2n的数组中有一个长度为n的滑动窗口，只需要维护一个单调递增序列，判断每个窗口中最小的sum-sum[k-1]是否为负即可\n那么这题的思路就很明确了，先对输入数据断环为链，然后在链上进行前缀和的预处理，最后，对于每一个k+n-1，我们用单调队列维护k–k+n-1的sum最小值，并将其减去sum[k-1]判断是否合法。\n#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main() &#123;    int n, head = 0, tail = 0, ans = 0;    scanf(&quot;%d&quot;, &amp;n);    long *a = (long *) malloc(sizeof(long) * n);    long *q = (long *) malloc(sizeof(long) * n);    long *sum = (long *) malloc(sizeof(long) * n * 2);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%ld&quot;, &amp;a[i]);    // 计算前缀和    for (int i = 0; i &lt; n; i++)        sum[i] = sum[i - 1] + a[i];    for (int i = n; i &lt; 2 * n; i++)        sum[i] = sum[i - 1] + a[i - n];    // 维护单调队列    for (int i = 0; i &lt; 2 * n; i++) &#123;        if (i - n + 1 &gt; q[head])head++;        while (head &lt; tail &amp;&amp; sum[i] &lt;= sum[q[tail - 1]])tail--;        q[tail++] = i;        if (i - n + 1 &gt; 0 &amp;&amp; sum[q[head]] - sum[i - n] &gt;= 0)ans++;    &#125;    printf(&quot;%d\\n&quot;, ans);    return 0;&#125;\n\n4. 优先队列普通的队列具有先进先出的特性，元素追加在队尾，如果删除的话，从队头删除。而在优先队列中，队列中的数据被赋予了优先级。当访问元素时，优先级最高的会先被删除。所以说优先队列是最高级数据先出。\n优先队列的操作：\n\n删除最小（最大）元素\n插入一个元素\n\n优先队列需要维护一个有序的元素序列，但不要求全部有序，只需要从这些元素中找到最大（或最小）的一个元素，而堆正好满足这一要求。关于堆，我们会在排序模块进行详细介绍，下面我会简单的介绍一下。\n堆就是用数组实现的二叉树，分为大顶堆、小顶堆两种，在大顶堆中，父节点的值比每一个子节点的值都要大。在小顶堆中，父节点的值比每一个子节点的值都要小。\n对于一个完全二叉树，我们可以按照从上到下、从左到右的顺序从1开始编号。同时我们对需要处理的数组从1进行编号\n\n\n接着我们对这个二叉树进行调整（调整过程不再给出），让它满足堆的性质（以大顶堆为例，父节点的值比每一个子节点的值都要大）调整完后如下图\n\n显然此时根节点为数组中的最大值，每次取出根节点后，对这个数组进行调整，让它接着满足堆的性质，一直取下去的话就是堆排序。\n对于优先队列，我们在每次插入元素时对数组重新进行一次调整，每次取出最值后同样进行一次调整。\n实际上STL里面也为我们提供了相关的实现。STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。\nSTL中定义优先队列的类为priority_queue，其原型如下：\ntemplate &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;\n\n模板里面有三个参数，第一个为元素的类型，第二个为所使用的容器（vector或deque），第三个为一个比较的规则，决定是最大优先队列还是最小优先队列，默认的less为最大优先队列。\n// priority_queue的主要方法bool empty() const;size_type size() const;const value_type&amp; top() const;void push (const value_type&amp; val);void pop();\n\n在使用时都要加上queue头文件最大优先队列声明为：priority_queue&lt;int&gt; q最小优先队列声明：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2\n#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;    q.push(9);    q.push(5);    q.push(3);    q.push(11);    while(!q.empty())    &#123;        int val=q.top();        cout&lt;&lt;val&lt;&lt;&quot; &quot;;        q.pop();    &#125;    return 0;&#125;\n\n如果我们需要使用自定义比较函数，我们可以直接选用最大优先队列，然后对&lt;进行重载\nstruct fruit&#123;    int price;    // 自定义比较函数的第一种方式：重载&lt;符号    // 注意此处一定要声明为const，否则编译时无法通过    // const修饰的是类函数隐藏的第一个参数 this指针，这表明this指针只读，也即类成员不可修改    // 注意该用法只能是成员函数，要是类的静态函数或者是非成员函数就不可以在函数名后面加上const    bool operator&lt;(const fruit&amp; f1) const    &#123;        return this-&gt;price &lt; f1.price;    &#125;&#125;int main()&#123;    priority_queue&lt;fruit&gt; q;&#125;\n\n下面我们来看道例题\n例题一 合并果子题目题目链接\n在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 &#x3D;3+12&#x3D;15 。可以证明 15 为最小的体力耗费值。\n输入格式第一行是一个整数 n (1&lt;&#x3D; n &lt;&#x3D; 10000)，表示果子的种类数。第二行包含 n 个整数，用空格分隔，第 i 个整数 a_i(1&lt;&#x3D; a_i &lt;&#x3D; 20000) 是第 i 种果子的数目。\n输出格式一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31。\n样例\n// 样例输入3 1 2 9// 样例输出15\n\n其中\n\n对于 30% 的数据，保证有 n &lt; 1000\n对于 50% 的数据，保证有 n &lt; 5000\n对于全部的数据，保证有 n &lt; 10000\n\n答案这道题显然每次取最小的两个数即可，如果直接进行排序，每次合并果子后重新再排显然会超时。我们可以采用优先队列。代码如下\n#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;int n, x, ans;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;int main() &#123;    cin &gt;&gt; n; // cin是C++编程语言中的标准输入流对象，可以理解为scanf    while (n--)        cin &gt;&gt; x, q.push(x);    while (q.size() &gt;= 2) &#123;        int a = q.top();        q.pop();        int b = q.top();        q.pop();        ans += a + b;        q.push(a + b);    &#125;    cout &lt;&lt; ans &lt;&lt; endl; // cin是C++编程语言中的标准输出流对象，可以理解为printf    return 0;&#125;\n\n作业一题目链接\n写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。\n如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。\n如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。\n一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。\n输入格式输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。\n输出格式按照进程结束的时间输出每个进程的进程号和结束时间。\n样例\n// 输入1 1 5 3 2 10 5 1 3 12 7 2 4 20 2 3 5 21 9 4 6 22 2 4 7 23 5 2 8 24 2 4// 输出1 63 195 306 328 344 357 402 42\n\n分析考虑到CPU在空闲时会从等待队列中取出优先值最高的那个任务开始运行，所以很显然这就是个优先队列。\n对于刚出现的每一个任务，我们直接将它放进队列，然后在下一个任务出现前不断地挨个处理程序。如果一个程序在运行到一半的时候被中断，那么保存剩余运行时间为总运行时间后将它重新压回队列。\n我们使用结构体来存放每个任务的信息。\nstruct task &#123;    int number;//任务编号    int need;//需要时间    int get;//出现时间    int grade;//优先级    bool operator &lt; (const task &amp;b) const &#123;        //给优先队列提供的运算符，我们会将优先级高的，或者是优先级相同但来的更早的任务放到堆顶        return this-&gt;grade &lt; b.grade  (this-&gt;grade == b.grade &amp;&amp; this-&gt;get &gt; b.get);    &#125;&#125;;\n\n然后是优先队列\npriority_queue&lt;task&gt; wait;\n\n最后是主函数\nint main() &#123;    int num, get, times, grade;    int time = -1;    while (scanf(&quot;%d%d%d%d&quot;, &amp;num, &amp;get, &amp;times, &amp;grade) != EOF) &#123;        while ((!wait.empty()) &amp;&amp; time + wait.top().need &lt;= get) &#123;            // 队列不为空，且优先级最高的进程在新加入的事件开始前就会执行完毕            time += wait.top().need;            printf(&quot;%d %d\\n&quot;, wait.top().number, time);            wait.pop();        &#125;        if (!wait.empty()) &#123;            // 队列不为空，进程执行完之前有新进程加入（不一定会抢夺，只是开始时间在原进程结束前）            // 计算当前进程所剩完成时间，重新放入队列（新进程也会在本次循环中放入队列，让优先队列自己比较去）            task cache = wait.top();            wait.pop();            cache.need -= get - time;            wait.push(cache);        &#125;        wait.push(&#123;num, times, get, grade&#125;);        time = get;    &#125;    while (!wait.empty()) &#123;        // 将队列中剩下的时间按照优先级、时间顺序输出        time += wait.top().need;        printf(&quot;%d %d\\n&quot;, wait.top().number, time);        wait.pop();    &#125;    return 0;&#125;\n\n答案#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct task &#123;    int number;//任务编号    int need;//需要时间    int get;//出现时间    int grade;//优先级    bool operator &lt; (const task &amp;b) const &#123;        //给优先队列提供的运算符，我们会将优先级高的，或者是优先级相同但来的更早的任务放到堆顶        return this-&gt;grade &lt; b.grade  (this-&gt;grade == b.grade &amp;&amp; this-&gt;get &gt; b.get);    &#125;&#125;;priority_queue&lt;task&gt; wait;int main() &#123;    int num, get, times, grade;    int time = -1;    while (scanf(&quot;%d%d%d%d&quot;, &amp;num, &amp;get, &amp;times, &amp;grade) != EOF) &#123;        while ((!wait.empty()) &amp;&amp; time + wait.top().need &lt;= get) &#123;            // 队列不为空，且优先级最高的进程在新加入的事件开始前就会执行完毕            time += wait.top().need;            printf(&quot;%d %d\\n&quot;, wait.top().number, time);            wait.pop();        &#125;        if (!wait.empty()) &#123;            // 队列不为空，进程执行完之前有新进程加入（不一定会抢夺，只是开始时间在原进程结束前）            // 计算当前进程所剩完成时间，重新放入队列（新进程也会在本次循环中放入队列，让优先队列自己比较去）            task cache = wait.top();            wait.pop();            cache.need -= get - time;            wait.push(cache);        &#125;        wait.push(&#123;num, times, get, grade&#125;);        time = get;    &#125;    while (!wait.empty()) &#123;        // 将队列中剩下的时间按照优先级、时间顺序输出        time += wait.top().need;        printf(&quot;%d %d\\n&quot;, wait.top().number, time);        wait.pop();    &#125;    return 0;&#125;","categories":["技术","算法"],"tags":["算法"]},{"title":"算法摘抄","url":"/2021-11-12/b4a63bea765e/","content":"最近有一些算法比赛，身为小白的我最近在补习一些基本常识，在这里记录一下。\nACM ICPC规则（虽然我不可能打）\n\n参赛队伍最多由三名参赛队员组成。\n竞赛中命题10题左右，试题描述为英文，比赛时间为5个小时，前四个小时可以实时看到排名，最后一小时封榜，无法看到排名。\n竞赛可以使用的语言：Java, C, C++\n重点考察选手的算法和程序设计能力，不考察实际工程中常用的系统编程，多线程编程等等；\n选手可携带任何非电子类资料\n评委负责将结果（正确或出错的类型）通过网络尽快返回给选手，除此之外不提供任何额外帮助；\n每个题目对应一种颜色的气球，通过该题目的队伍会得到对应颜色气球。每道题目第一支解决掉它的队还会额外获得一个“FIRST PROBLEM SOLVED”的气球。\n\nOJ术语常见术语如下\n\n\n简写\n全称\n中文称谓\n\n\n\nOJ\nOnline Judge\n在线判题系统\n\n\nAC\nAccepted\n通过\n\n\nWA\nWrong Answer\n答案错误\n\n\nTLE\nTime Limit Exceed\n超时\n\n\nOLE\nOutput Limit Exceed\n超过输出限制\n\n\nMLE\nMemory Limit Exceed\n超内存\n\n\nRE\nRuntime Error\n运行时错误\n\n\nPE\nPresentation Error\n格式错误\n\n\nCE\nCompile Error\n无法编译\n\n\n术语说法2.0\n\n\n简写\n全称\n中文称谓\n\n\n\nAC\nAnswer Cubi\n粗鄙的答案\n\n\nWA\nWonderful Answer\n完美的答案\n\n\nTLE\nTime Limit Enough\n时间充裕\n\n\nOLE\nOutput Limit Enough\n输出足够\n\n\nMLE\nMemory Limit Enough\n内存足够\n\n\nRE\nRuntime Excellent\n运行时（过于）优秀\n\n\nPE\nPretty Excellent\n十分优秀\n\n\nCE\nCompile Easily\n轻松通过编译\n\n\nUKE\nUnbelievable Keeping Excellent\n难以置信的保持优秀\n\n\n","categories":["技术","算法"],"tags":["算法"]},{"title":"背包做题笔记","url":"/2023-01-13/8befae7c2511/","content":"你的背包~🎵\n前言这个是刷代码随想录的做题笔记，分析部分大多是我自己的理解，代码我用go写的，现在回头再看一遍还是觉得代码随想录总结的很棒，强推一波！\n背包概括\n面试的话，其实掌握 01背包 完全背包，就够用了，leetcode上连多重背包的题目都没有\n完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。01背包是基础，需要重点掌握。\n01背包01背包初介绍有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n先从暴力的角度来看，通过回溯实现暴力，每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是o(2^n)，这里的n表示物品数量。\n所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化\n入门例题背包最大重量为4，物品为：\n\n\n\n\n重量\n价值\n\n\n\n物品0\n1\n15\n\n\n物品1\n3\n20\n\n\n物品2\n4\n30\n\n\n问背包能背的物品最大价值是多少？\n分析动规五部曲\n\n确定dp数组以及下标的含义\n\n对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n物品0\n\n\n\n\n\n\n\n物品1\n\n\n\n\n\n\n\n物品2\n\n\n\n\n\n\n\n\n确定递推公式\n\n再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少\n那么可以有两个方向推出来dp[i][j]：\n\n不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同)\n放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值\n\n所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])\n\ndp数组如何初始化\n\n首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n物品0\n0\n\n\n\n\n\n\n物品1\n0\n\n\n\n\n\n\n物品2\n0\n\n\n\n\n\n\n状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化\ndp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n物品0\n0\n15\n15\n15\n15\n\n\n物品1\n0\n\n\n\n\n\n\n物品2\n0\n\n\n\n\n\n\n首先j&#x3D;0(容量为0)这里是可以初始值不用管的，并且根据遍历顺序来说也是不用管，这个后面会看到\n初始化的代码：\nfunc main() &#123;\tweight := []int&#123;1, 3, 4&#125;\tvalue := []int&#123;15, 20, 30&#125;\tbigWeight := 4\tdp := make([][]int, len(weight))\tfor i := 0; i &lt; len(weight); i++ &#123;\t\t// 因为容量包含0，所以要+1\t\tdp[i] = make([]int, bigWeight+1)\t&#125;\t// 这里直接从weight[0]起步，前面的肯定是0\tfor j := weight[0]; j &lt;= bigWeight; j++ &#123;\t\tdp[0][j] = value[0]\t&#125;\tfmt.Println(dp)&#125;// output:[[0 15 15 15 15] [0 0 0 0 0] [0 0 0 0 0]]\n\n\n确定遍历顺序\n\n01背包遍历顺序两种都行，但是先遍历物品更好理解\n// 遍历物品for i := 1; i &lt; len(weight); i++ &#123;    // 遍历容量    for j := 0; j &lt;= bagWeight; j++ &#123;        if j &lt; weight[i] &#123;            dp[i][j] = dp[i-1][j]        &#125; else &#123;            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])        &#125;    &#125;&#125;fmt.Println(dp)//output:[[0 15 15 15 15] [0 15 15 20 35] [0 15 15 20 35]]\n\n滚动数组空间优化dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少\n一维数组：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]\n动规五部曲\n\n确定dp数组的定义\n\n在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]\n\ndp数组的递推公式\n\ndp[j] = max(dp[j], dp[j - weight[i]] + value[i])\n\n\ndp数组初始化\n\ndp[0]&#x3D;0，其他情况下可以通过dp[0]直接横着推过来\n\n遍历顺序\n\nfunc main() &#123;\tweight := []int&#123;1, 3, 4&#125;\tvalue := []int&#123;15, 20, 30&#125;\tbagWeight := 4\t// 因为容量包含0，所以要+1\tdp := make([]int, bagWeight+1)\t// 遍历物品\tfor i := 0; i &lt; len(weight); i++ &#123;\t\t// 遍历容量\t\tfor j := bagWeight; j &gt;= weight[i]; j-- &#123;\t\t\tdp[j] = max(dp[j], dp[j-weight[i]]+value[i])\t\t&#125;\t&#125;\tfmt.Println(dp)&#125;//output:[0 15 15 20 35]\n\n这块是重点，注意：必须先遍历物品再遍历背包；必须倒序遍历\n先遍历物品再遍历背包：因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品（举个例子自己走一遍就差不多理解了）\n倒顺遍历：无法知道物品装了没装，容易装多次，倒着来的话本容量下前面的肯定没装该物品，因为还没遍历到\n分割等和子集题目链接\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n示例 1：\n输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\n示例 2：\n输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。\n\n提示：\n\n1 &lt;= nums.length &lt;= 200\n1 &lt;= nums[i] &lt;= 100\n\n分析[1,5,11,5]为例，和为22，相当于一个11的背包看看最多可以装多少个，如果小于11输出false，等于11输出true，一道简单的01背包问题\n代码func canPartition(nums []int) bool &#123;\tvar sum int\tfor _, v := range nums &#123;\t\tsum += v\t&#125;\tif sum%2 != 0 &#123;\t\treturn false\t&#125;\tsum /= 2\tdp := make([]int, sum+1)\tfor i := 0; i &lt; len(nums); i++ &#123;\t\tfor j := sum; j &gt;= nums[i]; j-- &#123;\t\t\tdp[j] = max(dp[j], dp[j-nums[i]]+nums[i])\t\t&#125;\t&#125;\treturn dp[sum] == sum&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n最后一块石头的重量 II题目链接\n有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：\n\n如果 x == y，那么两块石头都会被完全粉碎；\n如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\n\n最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0\n示例 1：\n输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n\n示例 2：\n输入：stones = [31,26,33,21,40]输出：5\n\n提示：\n\n1 &lt;= stones.length &lt;= 30\n1 &lt;= stones[i] &lt;= 100\n\n分析乍一看一脸懵逼，仔细想想的话反正一个是加数一个是减数，分成两拨来碰，和上面那道题好像一样：一组数，分两拨，两拨之间差值如何最小，输出即可，那也就相当于一组数，sum&#x2F;2为容量，看看最大是多少，最后输出sum&#x2F;2-该数\n但是需要考虑sum%2为1的情况，以sum&#x3D;9为例，肯定有一波小于等于4，一波小于等于5，不管是哪一波，一个向中间聚拢，另一个也是，所以背包容量取哪个都没影响。我们可以直接向下取整，因为sum&#x2F;2就是，并且容量小的话for层数也少。\n因为背包容量算出来的是小于等于sum&#x2F;2的，并且还有可能向下取整，所以最后结果为sum-dp[bagWeight] - dp[bagWeight]\n代码func lastStoneWeightII(stones []int) int &#123;\tvar sum int\tfor _, stone := range stones &#123;\t\tsum += stone\t&#125;\tbagWeight := sum / 2\tdp := make([]int, bagWeight+1)\t// 遍历物品\tfor i := 0; i &lt; len(stones); i++ &#123;\t\t// 遍历容量\t\tfor j := bagWeight; j &gt;= stones[i]; j-- &#123;\t\t\tdp[j] = max(dp[j], dp[j-stones[i]]+stones[i])\t\t&#125;\t&#125;\treturn sum - dp[bagWeight]*2&#125;\n\n目标和给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ：\n\n例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot;\n\n返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1：\n输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3\n\n示例 2：\n输入：nums = [1], target = 1输出：1\n\n提示：\n\n1 &lt;= nums.length &lt;= 20\n0 &lt;= nums[i] &lt;= 1000\n0 &lt;= sum(nums[i]) &lt;= 1000\n-1000 &lt;= target &lt;= 1000\n\n分析这道题比较难想，但是有过这一次之后以后同类型的会好很多。\n加号的分为一波，减号的分为一波，假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) &#x3D; target，x &#x3D; (target + sum) &#x2F; 2\n此时问题就转化为，装满容量为x的背包，有几种方法\nbagSize就是(target + sum) &#x2F; 2 ，如果这个数不能整除，那就不可能凑不来方法，return 0即可\n这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个组合问题了\n\n确定dp数组以及下标的含义\n\ndp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\n\n确定递推公式\n\ndp[j]，j 为5\n\n已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。\n已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。\n已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包\n已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包\n已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包\n\n那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\n所以求组合类问题的公式，都是类似这种：\ndp[j] += dp[j - nums[i]]\n\n这个公式在后面在讲解背包解决排列组合问题的时候还会用到！\n\ndp数组如何初始化\n\n从0开始推，容量为0装满的方式有1种，这个是初始值，其他通过这个推过来。\n从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。\n\n确定遍历顺序\n\n一维dp数组，先物品再容量\n代码func findTargetSumWays(nums []int, target int) int &#123;\tsum := target\tfor _, num := range nums &#123;\t\tsum += num\t&#125;\tif sum%2 == 1 &#123;\t\treturn 0\t&#125;\tbagWeight := sum / 2\t// 这里需要判断bagWeight是否小于0    // 例如 [100],-200 的输入    if bagWeight &lt; 0 &#123;        return 0    &#125;\t// dp[j] 表示：填满j这么大容积的包，有dp[j]种方法\tdp := make([]int, bagWeight+1)\tdp[0] = 1\tfor i := 0; i &lt; len(nums); i++ &#123;\t\tfor j := bagWeight; j &gt;= nums[i]; j-- &#123;\t\t\tdp[j] += dp[j-nums[i]]\t\t&#125;\t&#125;\tfmt.Println(dp)\treturn dp[bagWeight]&#125;\n\n一和零给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：\n输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n示例 2：\n输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。\n\n提示：\n\n1 &lt;= strs.length &lt;= 600\n1 &lt;= strs[i].length &lt;= 100\nstrs[i] 仅由 &#39;0&#39; 和 &#39;1&#39; 组成\n1 &lt;= m, n &lt;= 100\n\n分析这个题其实不难看出来是01背包问题但是有两个维度限制（经常见这类型的题），就像有的大招既扣蓝也扣血，这俩都算是背包的容量，所以我们for循环遍历需要三层了：物品、容量0、容量1（我们需要把dp[m][n]中，m、n取值的各种情况都填满！）\n创建dp数组的时候再多创建一个维度即可，例如我们用滚动数组，一维数组即可解决，这里要变成二维\n\n确定dp数组及下标的含义\n\ndp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]\n\n确定递推公式\n\ndp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。\ndp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。\n然后我们在遍历的过程中，取dp[i][j]的最大值。\n所以递推公式：dp[i][j] &#x3D; max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n此时大家可以回想一下01背包的递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);\n对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）\n\ndp数组如何初始化\n\n根据含义dp[0][0]直接为0就行，滚动数组的话也不会覆盖掉什么的\n\n确定遍历顺序\n\n先遍历物品再遍历背包，从后往前遍历\n代码自我感觉注释写的挺清晰的\nfunc findMaxForm(strs []string, m int, n int) int &#123;\t// 滚动数组，所以 创建dp数组时无需考虑物品的容量\t// 因为是两个容量限制，所以是dp[m+1][n+1] (加一是因为含有0)\tdp := make([][]int, m+1)\tfor i := 0; i &lt;= m; i++ &#123;\t\tdp[i] = make([]int, n+1)\t&#125;\t// 遍历物品\tfor _, str := range strs &#123;\t\tzeroNum,oneNum := 0,0\t\tfor _, ch := range str &#123;\t\t\tif ch == &#x27;0&#x27; &#123;\t\t\t\tzeroNum++\t\t\t&#125; else &#123;\t\t\t\toneNum++\t\t\t&#125;\t\t&#125;\t\t// 遍历容量\t\tfor i := m; i &gt;= zeroNum; i-- &#123; // 遍历0的容量\t\t\tfor j := n ; j &gt;= oneNum; j-- &#123; // 遍历1的容量\t\t\t\tdp[i][j] = max(dp[i][j],dp[i-zeroNum][j-oneNum]+1)\t\t\t&#125;\t\t&#125;\t&#125;\treturn dp[m][n]&#125;\n\n01背包总结刚刚刷过的题目总结一下：\n\n纯 0 - 1 背包 求 给定背包容量，尽可能装，最大价值是多少\n416. 分割等和子集 求 给定背包容量，能不能装满这个背包\n1049. 最后一块石头的重量 II 求 给定背包容量，尽可能装，最多能装多少\n494. 目标和 求 给定背包容量，装满背包，有多少种方法\n474. 一和零 求 给定背包容量，尽可能装，最多有多少个物品\n\n所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用\n【不得不说卡哥找的这些题都太典型了，每道题是一种类型，有些佩服】\n完全背包概述完全背包和01背包问题唯一不同的地方就是，每种物品有无限件\n以例题为切入，背包最大重量为4，物品如下：\n\n\n\n重量\n价值\n\n\n\n\n物品0\n1\n15\n\n\n物品1\n3\n20\n\n\n物品2\n4\n30\n\n\n每件商品都有无限个，问背包能背的物品最大价值是多少？\n回顾一下01背包的核心代码：\n// 遍历物品for i := 0; i &lt; len(weight); i++ &#123;\t// 遍历容量\tfor j := bagWeight; j &gt;= weight[i]; j-- &#123;\t\tdp[j] = max(dp[j], dp[j-weight[i]]+value[i])\t&#125;&#125;\n\n其中容量倒序遍历，为了保证每个物品仅被添加一次，而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：\n// 遍历物品for i := 0; i &lt; len(weight); i++ &#123;\t// 遍历容量\tfor j := weight[i]; j &lt;= bagWeight; j-- &#123;\t\tdp[j] = max(dp[j], dp[j-weight[i]]+value[i])\t&#125;&#125;\n\n01背包中必须先遍历物品，再遍历容量，但完全背包中两种遍历方式都可以，因为dp[j]是根据 下标j之前所对应的dp[j]计算出来的，只要保证下标j之前的dp[j]都是经过计算的就可以了，而完全背包从前往后遍历，所以前面的数都是全的，咋遍历都没问题。\n背包遍历顺序\n\n01背包：先物品后容量，容量倒序遍历\n完全背包：容量正序遍历，两种遍历方式都可以\n\n但是！具体问题要具体分析，这里说的仅仅是纯背包问题的遍历顺序\n顺便把例题做了吧，代码如下：\nfunc main() &#123;   weight := []int&#123;1, 3, 4&#125;   value := []int&#123;15, 20, 30&#125;   bagWeight := 4   // 因为容量包含0，所以要+1   dp := make([]int, bagWeight+1)   // 遍历物品   for i := 0; i &lt; len(weight); i++ &#123;      // 遍历容量      for j := weight[i]; j &lt;= bagWeight; j++ &#123;         dp[j] = max(dp[j], dp[j-weight[i]]+value[i])      &#125;   &#125;   fmt.Println(dp)&#125;\n\n零钱兑换 II题目链接\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 \n假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。\n示例 1：\n输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1\n\n示例 2：\n输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。\n\n示例 3：\n输入：amount = 10, coins = [10] 输出：1\n\n提示：\n\n1 &lt;= coins.length &lt;= 300\n1 &lt;= coins[i] &lt;= 5000\ncoins 中的所有值 互不相同\n0 &lt;= amount &lt;= 5000\n\n代码和01背包中的那个题一样，组合问题：dp[j] += dp[j - nums[i]]，没啥好解释的\nfunc change(amount int, coins []int) int &#123;\tdp := make([]int, amount+1) //总金额为i时，有dp[i]种兑换方法\tdp[0] = 1\tfor i := 0; i &lt; len(coins); i++ &#123;\t\tfor j := coins[i]; j &lt;= amount; j++ &#123;\t\t\tdp[j] += dp[j-coins[i]]\t\t&#125;\t&#125;\treturn dp[amount]&#125;\n\n遍历顺序分析但是注意，这里遍历顺序必须时先物品后容量！\n因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。\n外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。\n如果把两个for交换顺序，背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。此时dp[j]里算出来的就是排列数！\n总结\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包\n如果求排列数就是外层for遍历背包，内层for循环遍历物品\n\n组合总和 Ⅳ题目链接\n给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？\n示例 1：\n输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。\n\n示例 2：\n输入：nums = [9], target = 3输出：0\n\n提示：\n\n1 &lt;= nums.length &lt;= 200\n1 &lt;= nums[i] &lt;= 1000\nnums 中的所有元素 互不相同\n1 &lt;= target &lt;= 1000\n\n分析标题写的时组合，实际上时排序，没啥好说的，for循环调换一下，换的时候注意需要把j-nums[i]&lt;0的部刨掉\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包\n如果求排列数就是外层for遍历背包，内层for循环遍历物品\n\n进阶：如果给定的数组中含有负数，则会导致出现无限长度的排列。例如：有个-5，有个3。那我选3个-5，再选5个3，它们的和为0，那就抵消了，按照倍数往上加，像6个-5、10个3也是0，这样成倍增长下去，那就没完了\n代码func combinationSum4(nums []int, target int) int &#123;   dp := make([]int, target+1)   dp[0] = 1   for j := 0; j &lt;= target; j++ &#123;      for i := 0; i &lt; len(nums); i++ &#123;         if j-nums[i] &gt;= 0 &#123; // 这个判断得单独处理            dp[j] += dp[j-nums[i]]         &#125;      &#125;   &#125;   return dp[target]&#125;\n\n爬楼梯进阶版假设你正在爬楼梯。需要 n 阶你才能到达楼顶，你每次可以上1至m个台阶，n、m均为输入。你有多少种不同的方法可以爬到楼顶呢？\n分析\n每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶——完全背包\n跳到楼顶有几种方法——排序问题\n\n从而确定遍历顺序：\n\n完全背包：容量正序遍历\n排序问题：先容量再物品\n\ndp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。递推公式：dp[i] += dp[i - j]。初始化：dp[0]=0\n代码func climbStairs(n int,m int) int &#123;   dp := make([]int,n+1)   dp[0] = 1   for j := 0; j &lt;= n; j++ &#123;      for i := 0; i &lt; m; i++ &#123;         dp[j] += dp[j-i]      &#125;   &#125;   return dp[n]&#125;\n\n零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1\n\n示例 2：\n输入：coins = [2], amount = 3输出：-1\n\n示例 3：\n输入：coins = [1], amount = 0输出：0\n\n提示：\n\n1 &lt;= coins.length &lt;= 12\n1 &lt;= coins[i] &lt;= 2^31 - 1\n0 &lt;= amount &lt;= 10^4\n\n分析\n确定dp数组：凑足总额为j所需钱币的最少个数为dp[j]\n确定递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j])\ndp数组如何初始化[值得注意]：非0的元素都是应该是最大值，dp[0]&#x3D;0\n遍历顺序：求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数\n\n代码func coinChange(coins []int, amount int) int &#123;\tdp := make([]int, amount+1) // 总金额为i时，最少硬币数为dp[i]\t// dp[j] = min(dp[j],dp[j-coins[i]]+1)\tfor i := 1; i &lt;= amount; i++ &#123;\t\tdp[i] = math.MaxInt32\t&#125;\tfor i := 0; i &lt;= len(coins); i++ &#123;\t\tfor j := coins[i]; j &lt;= amount; j++ &#123;\t\t\tdp[j] = min(dp[j], dp[j-coins[i]]+1)\t\t&#125;\t&#125;\treturn dp[amount]&#125;\n\n完全平方数给你一个整数 n ，返回 和为 n 的完全平方数的最少数量\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1：\n输入：n = 12输出：3 解释：12 = 4 + 4 + 4\n\n示例 2：\n输入：n = 13输出：2解释：13 = 4 + 9\n\n提示：\n\n1 &lt;= n &lt;= 10^4\n\n分析题目翻译：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品\n\n完全背包\n遍历顺序没要求\n\n代码func numSquares(n int) int &#123;\tdp := make([]int, n+1) // j需要的最少平方数个数\tfor i := 1; i &lt;= n; i++ &#123;\t\tdp[i] = math.MaxInt32\t&#125;\tm := int(math.Pow(float64(n), 0.5))\t// 遍历物品\tfor i := 0; i &lt;= m; i++ &#123;\t\t// 遍历容量\t\tfor j := i * i; j &lt;= n; j++ &#123;\t\t\tdp[j] = min(dp[j], dp[j-i*i]+1)\t\t&#125;\t&#125;\treturn dp[n]&#125;\n\n多重背包有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。\n多重背包和01背包是非常像的，每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。\n例如：\n背包最大重量为10。\n物品为：\n\n\n\n\n重量\n价值\n数量\n\n\n\n物品0\n1\n15\n2\n\n\n物品1\n3\n20\n3\n\n\n物品2\n4\n30\n2\n\n\n问背包能背的物品最大价值是多少？\n和如下情况有区别么？\n\n\n\n\n重量\n价值\n数量\n\n\n\n物品0\n1\n15\n1\n\n\n物品0\n1\n15\n1\n\n\n物品1\n3\n20\n1\n\n\n物品1\n3\n20\n1\n\n\n物品1\n3\n20\n1\n\n\n物品2\n4\n30\n1\n\n\n物品2\n4\n30\n1\n\n\n毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。\n所以可以直接把它看成01背包来做。当然另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。即01背包里面在加一个for循环遍历一个每种商品的数量。\n// 多重背包可以化解为 01 背包func multiplePack(weight, value, nums []int, bagWeight int) int &#123;    \tfor i := 0; i &lt; len(nums); i++ &#123;\t\tfor nums[i] &gt; 1 &#123;\t\t\tweight = append(weight, weight[i])\t\t\tvalue = append(value, value[i])\t\t\tnums[i]--\t\t&#125;\t&#125;\tres := make([]int, bagWeight+1)\tfor i := 0; i &lt; len(weight); i++ &#123;\t\tfor j := bagWeight; j &gt;= weight[i]; j-- &#123;\t\t\tres[j] = getMax(res[j], res[j-weight[i]]+value[i])\t\t&#125;\t&#125;\treturn res[bagWeight]&#125;\n\n背包总结01背包：\n\n物品只能用一次\n二维数组时，遍历顺序均可\n一维数组只能先物品后容量，容量倒序遍历\n\n完全背包：\n\n物品可用无限次\n容量正序遍历（保证无限次）\n一维数组遍历顺序均可，常见特例如下：\n组合数：先遍历物品，再遍历容量(背包)\n排序数：先遍历容量(背包)，再遍历物品\n\n\n\n多重背包：转换成01背包来做\n组合、排序问题递推通常公式为：dp[i] += dp[i - j]，初始化dp[0]=0\nOK，你已经掌握01背包、完全背包、多重背包了，快去solo面试官吧！\n","categories":["技术","算法"],"tags":["算法"]},{"title":"ubuntu 20.04 lts 重新安装简体中文","url":"/2021-11-25/1eedabb9195d/","content":"笔者手贱，把自带的卸载了，只剩一个中文（香港）的了，重新装了一遍，在此记录一下。\n（ps: Ubuntu 的拖上去安装是哪个鬼才想的。。。）\n输入法安装输入法的话随便安装一个就行\nIBus拼音：sudo apt-get install ibus-pinyin\nIBUS五笔：sudo apt-get install ibus-table-wubi\n谷歌拼音输入法：sudo apt-get install ibus-googlepinyin\nSun拼音输入法：sudo apt-get install ibus-sunpinyin\n中文语言包可以在终端安装中文语言包，终端输入：\nsudo apt-get install language-pack-zh-han* \n\n（就是全下下来了，或者根据自己的需要自己选也行）\n踩坑记录运行 apt-get 时报如下错\nE: unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?\n\n解决方案:\nsudo rm /var/lib/dpkg/lock-frontendsudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock\n\n都运行一遍，具体也不知道哪条起了作用。（该方法出自知乎大神）\n","categories":["技术","系统"],"tags":["Linux","Ubuntu"]},{"title":"服务器socket连接不上","url":"/2021-09-23/958960dec50b/","content":"一直踩坑，记录一下，服务器socket连接不上\n\nServer 用私网 ip\nClient 用公网 ip\n一定要去检查端口是否放行！\n\n参考\n","categories":["技术","系统"],"tags":["socket","网站搭建"]},{"title":"禁用笔记本键盘","url":"/2021-08-14/2025485ff876/","content":"\n用管理员身份运行cmd:\n禁用笔记本键盘 sc config i8042prt start&#x3D; disabled\n启用笔记本键盘 sc config i8042prt start&#x3D; auto\n\n文章出处\n","categories":["技术","系统"],"tags":["电脑使用"]},{"title":"虚拟机如何科学上网","url":"/2021-08-25/625925664847/","content":"\n个人感觉，Linux科学上网有些难配置（很可能只是因为自己比较菜），所以当主机可以科学上网时，我们就可以采用主机进行代理来达到科学上网的目的。\n\n1. 查看主机 ip 地址win + R 调出 cmd ，输入 ipconfig 查询主机 IP 地址，记录下来。\n\n笔者的就是上图的192.168.0.105\n2. 开启主机的允许来自局域网的连接\n（笔者使用的代理软件为 v2rayN ）\n打开的同时也可以去确认下监听端口以及监听协议\n\n如上图，笔者的监听端口为10808，协议为 socks\n3.将网络设置为桥接模式打开 VMware ，将网络模式设置为桥接模式\n\n4.设置虚拟机\n\n这里填写的就是刚刚在主机上面查到的信息了\n5. 测试\n测试成功\n\n转载请标明原文网址\n\n","categories":["技术","系统"],"tags":["科学上网","虚拟机"]},{"title":"阿里云连接socket服务器失败避坑","url":"/2021-08-09/9c0d67d4a04b/","content":"socket一直连接不上阿里云的服务器，经过大致查阅后得到解决，在此记录一下。\n配置安全组连接不上很有可能是阿里云的安全组没有配置，只配置入方向即可。\n服务器与客户端的ip服务器的ip应采用私网ip，或者直接gethostname()也可以。客户端需要选用公网ip。\n粗心大意例如：\nhost = &#x27; 123.4.5.1&#x27;# 对比正确的host = &#x27;123.4.5.1&#x27;\n\n参考文章\n","categories":["技术","系统"],"tags":["python","socket"]},{"title":"Python程序设计：五子棋","url":"/2021-07-14/e08de91a777e/","content":"\n作 者 姓 名： 田冰航、吴华骅、钟希鸣指 导 教 师： 张颖杰项 目 整 理 日 期：2021 年6 月14 日项 目 完 成 日 期：2021 年3 月7 日所 属 学 校：大连理工大学\n\n引 言笔者只实现了五子棋的部分功能，编写的目的主要还是以巩固自己python的理解为主。\n设计方法是以参考网上案例和个人理解相结合，在吸收他人的成果基础上进行类比和再创作。在进行程序设计时，笔者由于能力有限，算法和程序结构较为低级，代码冗长。\n该程序的设计依据首先立足于用户的需求，为开发出能满足用户基本需求的程序，笔者参考了网上已有的程序框架进行编写。\n这其中主要参考了CSDN上许多博主的代码，在此向笔者学习过的博主表示感谢。\n该项目的设计重点，在功能模块上分为四个大模块，第一块是人人对战，第二块是人机对战，第三块是图形界面，第四块是琐碎功能模块。这些模块笔者将在后面进行详细介绍。\n在此项目的编写中，笔者与钟希鸣、吴华骅三人一起组成了一个小组，在这一个月中，我们相互交流，相互讨论，最终完成了这个程序。\n这其中比较有难度的地方是需要与队友实时沟通，如何合理地进行安排分工，如何进行更加高效正确地实现程序的对接，最终实现小组的完美配合。\n该项目的设计重点，在于具有清晰的逻辑思维，避免因逻辑混乱而导致的大面积系统崩溃。\n然后文件的读写也是难点。文件读写是程序必不可少的部分。文件读写将直接决定系统储存的数据能否再次使用，如果数据无法正常保存或输出，那么这个游戏的娱乐性将大打折扣\n为了解决以上难点，笔者不断地学习相关知识，并观察分析实例代码，而为了真正理解代码，笔者也花费了大量时间用于编程操作，在实践中感悟总结。\n程序设计思路系统设计根据功能要求，可将学生成绩管理系统的系统分为四个模块：人人对战、人机对战、图形界面、琐碎功能模块。各个模块相互关联、相互协调，共同进行信息管理。\n功能设计1.3.1 菜单页面菜单页面分为两个层次，第一个开始界面，第二个为游戏进行中的菜单界面。\n五子棋的规则约束主要由笔者进行编写，其中包括记录整个棋盘，检查是否胜利，检查此处是否可以落子等功能。\n1.3.3 图形界面渲染该部分主要保存于render.py文件中，包括张贴背景图片，张贴棋盘图片，张贴棋子，播放背景音乐等功能，主要是对该程序的图形界面进行渲染。\n1.3.4 存盘复盘存盘中先显示出6个存档位置，点击后就会将棋局现状图片和棋局状态存入savedata文件夹中进行保存。复盘时则会弹出六个存档的现状（有存档的位置粘贴棋局图片，无存档的位置粘贴背景图片），在点击后，即会进入相应的存档，并将棋局状态读取出来，继续下棋。\n1.3.5 悔棋及显示上一步落子悔棋和显示上一步落子则是开创了一个二维的列表保存最近走过的四步，并不断更新，并将上两步标记出来。当进行悔棋时，则将棋盘中最近下的三四步的状态设置为空，将三四步移至列表位置的一二步。\n1.3.6 人机对战人机对战主要采用对加分制，对各个棋局状态进行加减分，最后得到整个棋局的分数，选择最佳的下棋点。\n程序流程模块组成2.1 程序流程图五子棋的程序流程如图2.1：\n\n图2.1 程序流程图\n程序开始运行后，赋值n0 &#x3D;True进入选择的循环，当选择相应模块后将n0设置为False，退出循环进而实现界面选择的功能。\n进入棋局界面后，接收用户点击的位置并进行判断：若为悔棋，则将棋盘中最近下的三四步的状态设置为空，将三四步移至列表位置的一二步；若为菜单，则弹出菜单界面，并等待界面；若为下棋，则将相应的位置设置为指定的棋子状态；若为无效按键，则直接进行下一操作；若为键盘按键ESC，则弹出菜单。\n3 文件IO模式3.1 文件写入代码在笔者的存档、复档中，笔者通过主要通过file.write()、file.read()函数完成文件的读写。笔者的一段代码如下：\ndef Save_Data(self, num, map, chess_state, enable_ai, isAI):    if self.Data_Have[num-1]:        os.remove(SAVE_PATH + str(num) + &#x27;.jpg&#x27;)    fl = open(SAVE_PATH+ str(num)+ &quot;.txt&quot;, &quot;w+&quot;)    for i in map:        for j in i:            fl.write(str(j))            fl.write(&#x27; &#x27;)        fl.write(&#x27;\\n&#x27;)    if chess_state == ChessboardState.WHITE :        state = 2    else :        state = 1    fl.write(str(state) + &#x27;\\n&#x27;)     # 下一步为黑棋还是白棋    if enable_ai :        fl.write(str(1) + &#x27;\\n&#x27;)     # 本局是否为人机对战    else:        fl.write(str(0) + &#x27;\\n&#x27;)    if isAI :        fl.write(str(1) + &#x27;\\n&#x27;)     # 若为人机对战下一步是否为人    else:        fl.write(str(0) + &#x27;\\n&#x27;)    fl.close()\n\n其中map为棋局状态，enable_ai为是否使用AI，state是当前下棋方，1代表黑棋方，2代表白棋方。\n读档则是与之相对应进行读取、判断，最后获得曾将存档的状态，具体代码如下：\ndef Read_Data(self, num):    fl = open(SAVE_PATH + str(num) + &quot;.txt&quot;, &quot;r&quot;)    i=0    map = []    lines = fl.readlines()    for msg in lines:        i+=1        if i &lt;= 15 :            msg = msg.strip(&#x27;\\n&#x27;)            adm = msg.split(&#x27; &#x27;)            map.append(adm)        if i == 16 :            chess_state = int(msg)        if i == 17 :            msg = int(msg)            self.enable_ai = bool(msg)        if i == 18:            msg = int(msg)            self.isAI = bool(msg)    for j in range(15):        for i in range (15):            if int(map[j][i]) == 0:                self.board[j][i] = ChessboardState.EMPTY            if int(map[j][i]) == 1:                self.board[j][i] = ChessboardState.BLACK            if int(map[j][i]) == 2:                self.board[j][i] = ChessboardState.WHITE    fl.close()    if chess_state == 1:        self.chess_state = ChessboardState.BLACK    elif chess_state == 2 :        self.chess_state = ChessboardState.WHITE\n\n4 关键代码&amp;算法分析4.1 人机对战时AI的分析人机对战的部分代码如下：\n# M:代表我的棋子，P:代表对方的棋子或超出范围，X:表示此处为空if m_range == 5:    count[FIVE] += 1# 活四:XMMMMX# 冲四:XMMMMP, PMMMMXif m_range == 4:    left_empty = right_empty = False    if line[left_idx - 1] == empty:        left_empty = True    if line[right_idx + 1] == empty:        right_empty = True    if left_empty and right_empty:        count[FOUR] += 1    elif left_empty or right_empty:        count[SFOUR] += 1# 冲四: MXMMM, MMMXM 两种可同时存在# 活三: XMMMXX, XXMMMX# 眠三: PMMMX, XMMMP, PXMMMXPif m_range == 3:    left_empty = right_empty = False    left_four = right_four = False    if line[left_idx - 1] == empty:        if line[left_idx - 2] == mine:  # MXMMM            setRecord(self, x, y, left_idx - 2, left_idx - 1, dir_index, dir)            count[SFOUR] += 1            left_four = True        left_empty = True\n\n计算分数的方式是考虑棋盘上所有的情况，例如所有的死四、活三、跳三等，并对不同场面进行赋分，敌方场面进行减分，最后得出最优状况并进行下棋。\n5 曾经遇到的困难和解决方法5.1 AI导入的问题笔者最开始尝试将AI导入时，曾想投机取巧，直接从网络中进行搬运，而后面在进行棋局匹配时发现根本无法对应上，最终又重新填写造成较多不必要的麻烦。\n后面笔者在参考了网上的多个案例后，独立编写AI的基本框架，并借鉴了部分网上的计分代码。\n在经历了对python的系统学习后，笔者成功地实现了五子棋的基本功能，虽然有着较多的困难，但都在网络和队友的帮助下一一化解，最终完成这个项目。\n笔者回顾了之前的错误，发现还是python基础知识掌握不够牢固，这是基本功问题，与高深的算法无关，因此很多编写程序中的问题最终都归于一点：革命尚未成功，笔者仍需努力。\n5.2 逻辑错误相较于语法错误，逻辑错误显得更为可怕，通常会遇见半小时写函数三小时调试的问题。在编写系统前必须拥有较为清晰的逻辑架构，在此架构的基础上再选择去敲代码，这样能避免较多的问题。不过幸运的是python是单句进行执行，所以遇到问题可以较为明确的看出来，提高自己的编写效率。\n6 对程序设计的理解程序设计需要清晰的思路，只有思路正确才不会走较多的弯路，并凝练出较为简洁的算法。\n算法是一个程序的核心，算法的高级与否直接会影响到编写程序的难易。\n而算法依赖数学知识，现在所学的高数和线型代数都是在为编程打基础，笔者刚接触矩阵时曾怀疑其实用价值，但当了解到人工智能依靠矩阵进行计算时，笔者更切实地感受到基础学科知识对编程的重要性。\n现阶段笔者仅仅接触过C语言和python，但在使用过这两个语言后，笔者较为明确了面对过程编程和面对对象编程的区别。\n不管算法也好，编程思想也罢，一切都建立在语法的基础上，若连语法都不懂又怎可能使系统运行呢？而此系统则只运用了一些低级算法和低级语法，笔者也将在日后的学习中对该系统不断进行完善。\n效果演示开始界面\n开始界面\n游戏界面\n游戏界面\n游戏复盘\n游戏复盘\n结 论笔者曾经认为程序设计是及其风光的一件事，一个人，一台电脑，一顿乱打，一个惊喜，而在我真正设计时才真正了解到真实情况：一个人，一台电脑，一个月，一个系统，一具尸体。\n其实写代码也并非那么煎熬，每当你调试成功时，总会有满满的成就感用处，也正是在这一步一步的喜悦下笔者将这个系统坚持做了下来。\n虽然在学校没有学习python课程，但还是要进行自学的，而这次自学经历也让笔者充分的探索了自学的方法，受益匪浅\n在科中的日子算不上多苦多累，这中间也有着较多的欢乐，突如其来的寒假作业虽然算不上多累，但不得不说也占用了我较多的娱乐时间，不过感觉做出来后成就感还是满满的。\n最后祝愿电气创新实践基地能够越办越好。\n参考文献[1] 菜鸟教程\n[2] 一枚新手程序媛:《Python写五子棋游戏》\n[3] xerwin：《[深度学习]实现一个博弈型的AI，从五子棋开始》\n[4] marble_xu：《python 五子棋AI实现（2）：棋型评估函数实现》\n[5] 在校学渣一枚：《python写五子棋小游戏（pygame模块）》\n致 谢能完成我的五子棋，我需要对以下的人进行感谢。\n首先感谢电气创新实践基地能够给我提供这样的机会让我能够比较系统地学习python。\n然后我要感谢软件组的学长学姐的辛苦付出和指导教诲，你们让我体验到了科中精神：积极进取、求真务实、传承奉献。\n我要特别感谢我的队友，假期中真是与他们的不断交流才让我有了不断学习的动力，在我遇到问题无法解决之际，正是他们的指导让我走出迷茫，继续前行。\n最后也必须要感谢下我自己，坚持了下来，没有让自己后悔。\nPS\n项目已发布至GitHub\n\n","categories":["技术","项目"],"tags":["python"]},{"title":"Python程序设计：滑雪大冒险","url":"/2021-07-14/150bb368cd1a/","content":"\n作 者 姓 名： 田冰航、吴华骅、李浩浩、杨林川\n指 导 教 师： 张颖杰\n项 目 完 成 日 期：2021年5 月1 日\n项 目 整 理 日 期：2021年7 月14日\n所 属 学 校：大连理工大学\n\n安装说明安装时需将压缩包解压，点击“滑雪大冒险”文件中的“滑雪大冒险.exe”即可运行游戏。\n使用说明使用该游戏时，切勿删除或更改其中的文件。\n游戏操作说明菜单系统主菜单界面可以选择开始游戏、进入勋章墙、退出游戏这三个模块，点击开始游戏后会进行人物选择 （冰墩墩、雪容融），选择完人物后即可开始游戏。 进入勋章墙后，会显示自己所获得的所有勋章，可以点击下一页进行翻页，按下 ESC 即可退出返回主 菜单。 在游戏进行过程中，按下 ESC 即可弹出游戏暂停菜单，可以选择返回游戏或返回主菜单。\n剧情系统我们在游戏本身添加了剧情，点击“剧情引导视频.mp4”即可观看，其中包含了冬奥会的相关科普，以 及游戏的相关操作说明。\n操作系统游戏过程中人物自动前进，可以使用←→键来控制人物前进的方向来躲避障碍物，当人物速度行进较 快时也可以使用↑键进行减速。\n得分系统\n道具加分：在拾取到小红旗时可以获得加。\n高速状态加分：当人物前进的速度大于某值时，每前进一定的里程会额外加分\ncombo加分：为了增加游戏挑战性，人物在前进过程中多次进行方向调整可以获得额外加分 障碍物惩罚：① 惩罚类障碍物：立牌，发生碰撞会进行扣分 ② 中立型障碍物：冰面，踩到冰面会发生打滑，人物将失控一段时间，同时前进方向随机 发生变化\n\n成就系统为贴合奥运会主题，本游戏的成就采取发放奥运奖牌的形式体现：\n金牌（以下条件同时满足）：\n\n获得旗子数目大于30 或 最大速度达到15及以上\n得分大于1500\ncombo数目大于30\n碰撞数小于5\n\n银牌（以下条件同时满足）：\n\n获得旗子数目大于15 或 最大速度达到10及以上\n得分大于1000\ncombo数目大于20\n碰撞数小于10\n\n铜牌（以下条件同时满足）：\n\n获得旗子数目大于10 或 最大速度达到5及以上\n得分大于500\ncombo数目大于10\n碰撞数小于20\n\n效果演示开始菜单\n开始游戏\n角色选择\n角色选择\n游戏开始状态\n游戏开始状态\n游戏结束\n游戏结束\n\n项目已发布至GitHub：滑雪大冒险\nPS：由于GitHub大小限制，没有将杨林川同学的先导视频放入其中，在此致歉\n\n","categories":["技术","项目"],"tags":["python"]},{"title":"七牛云1024比赛-web短视频","url":"/2023-11-15/121c09e8413c/","content":"项目简介比赛题目网页短视频应用\n使用七牛云存储、七牛视频相关产品（如视频截帧等）开发一款Web端短视频应用\n基础功能（必须实现）\n\n视频播放：播放、暂停、进度条拖拽\n内容分类：视频内容分类页，如热门视频、体育频道\n视频切换：可通过上下键翻看视频\n\n高级功能（可选实现）\n\n账户系统：用户可登录，收藏视频\n可参考常见短视频应用自由增加功能，提升完善度，如点赞、分享、关注、搜索等\n\n最终实现Github地址：\n\n项目：VideoUtopia\n后端地址：VideoUtopia&#x2F;utopia-back\n前端地址：VideoUtopia&#x2F;utopia-front\n\n项目功能：\n\n存储模块\n使用七牛云kodo进行存储，存储 头像、封面、视频\n支持视频预处理，自动截取封面，异步回调替换\n\n\n用户模块\n登录、注册、查看个人主页\n\n\n视频模块\n热门视频：根据三小时内点赞量动态替换\n推荐视频：推送所关注用户发布的视频\n上传视频\n视频内容分类\n\n\n交互模块\n点赞、关注、收藏\n查看自己曾收藏过的视频\n查看自己关注的用户\n\n\n\n详细介绍项目大体来说中规中矩，这里介绍几个稍微有意思的点\n存储模块这里先吐槽一句，七牛云的文档写的有些粗糙\n通过kodo存储对象，服务端下发 带回调、带数据处理、带自定义参数 的凭证，客户端根据凭证上传视频，上传成功后七牛云回调服务端，服务端处理数据。时序图如下：\n\n为保证访问密钥的安全性，采用服务端下发凭证的形式\n上传文件主要集中于以下几个场景\n\n上传&#x2F;更换头像\n上传视频\n上传封面&#x2F;七牛云自动截取封面\n\n设计callback接口时，考虑到以下两方面\n\n文件上传调用次数相对其它接口较少，且回调方处理数据任务量不大\ncallback由七牛云调用，处理数据前会检测是否为七牛云发起\n处理回调时，不同类型控制层代码相近\n\n所以选择将三种类型全部集中于一个回调接口\n在处理数据时，如上传视频时，需要知道上传用户、标题、视频类型等信息，需要客户端上传时，携带自定义参数，callbackBody定义如下：\n&#123;  &quot;key&quot;: &quot;$(key)&quot;,  &quot;file_type&quot;: &quot;$(x:file_type)&quot;,  &quot;uid&quot;: &quot;$(x:uid)&quot;,  &quot;cover_url&quot;: &quot;$(x:cover_url)&quot;,  &quot;describe&quot;: &quot;$(x:describe)&quot;,  &quot;title&quot;: &quot;$(x:title)&quot;,  &quot;video_type_id&quot;: &quot;$(x:video_type_id)&quot;&#125;\n\n\n\n服务端根据file_type判断上传类型(视频-携带封面&#x2F;视频-不携带封面&#x2F;封面&#x2F;头像)，不同文件类型对应不同的参数校验，并单独处理\n\n封面：不做处理\n视频-携带封面：插入视频\n头像：修改user表\n\n对于视频-不携带封面：\n\n以用户头像做临时封面，插入视频\n将视频key做键，值为视频id，存入redis，半小时过期时间\n七牛云截取封面成功后，异步回调接口，根据视频key找到视频id，替换视频封面\n\n服务端在注册上传凭证时，携带了预转持久化参数：vframe/jpg/offset/1|saveas/bucket:$&#123;etag&#125;.jpg，七牛云会截取视频第一帧并持久化存储，在存储完成后，调用callback接口\ncallback在检测到请求中含有inputKey字段时，根据视频key从redis取出视频id，并替换视频封面\n热门视频需解决的问题热门视频的选择体现在用户的点赞上，若只按照点赞数量排序，会出现以下问题：\n\n点赞量高的视频堆积，更换频率较低，用户经常刷到重复视频\n新发出的有潜力的视频得不到推荐，无人问津\n\n因此，热门视频可采用 三小时内的点赞量 进行动态更换\n另外当 突然更换热门视频榜单 时，用户当前观看热门视频位置无法记录，会推送曾经的视频，影响用户体验，这里下文会详细举例\n设计思路\n开启协程，每隔三个小时异步拉取DB，获得三个小时内点赞量最多的100个视频，将视频id存入redis的zset中\n用户获取视频时，把三小时内点赞数从高到低返回给用户，一次返回20个，同时给出当前最小score，做下一次的分页依据\n\nscore设计直接将三小时内的点赞数作为score：无法根据score进行区分点赞数相同的视频，只能考虑 重复推送 或 忽略此类其他视频 两种方案，显然均不合理\n所以需要在score侧将视频区分开，因此最终选用 float(三小时内点赞数.视频id) 做score，确保热门视频不重复、不丢失\n版本控制对于更换热门视频导致用户体验下降的问题，我们采用版本控制的形式来解决\n我们先看一个案例：\n\nredis异步拉取DB，获取前100个热门视频id，存入zset，我们记为版本A\n两小时五十五分钟后，用户A分页刷取热门视频，获得版本A的前20个视频，并观看\n五分钟后，redis异步拉取DB，更新zset\n用户A获取下一分页视频\n\n此时虽然用户能正常获取视频，但因zset的改变，用户A可能会刷取到一些重复的视频，导致体验下降\n为解决该问题，我们进行了热门视频缓存版本控制，总共有A、B两个版本，每隔三小时轮换更新一个版本，服务器中记录当前最新版本，当用户新发起查询热门视频请求时，返回当前最新版本，用户查询时携带了版本信息，就使用该版本\n下面我们来看些例子\n\nredis异步拉取DB，获取前100个热门视频id，存入zset，我们记为版本A，当前版本是A\n用户A刷取热门视频，获得20个视频、nextScore、版本号A\n三小时后，redis异步拉取DB，更换版本B中的热门视频，当前版本是B\n用户A刷取热门视频，请求参数中携带版本号A -&gt; 从版本A的zset中取出数据返回，用户体验无影响\n用户B刷取热门视频，未携带版本号 -&gt; 给出当前版本号B返回值，并从版本B中取数据\n三小时后，redis异步拉取DB，更换版本A中的热门视频，当前版本是A\n\n我们可以直观看出，从用户A获取版本A中的视频，到版本A中的热门视频变更，中间至少要间隔3个小时，这个时间差对业务而言完全可以接受\n代码实现异步更新，从DB中读取写入redis\n// 热门视频缓存 每隔三小时更新一次版本// 存入zset，通过score判断此时取到的位置func (v *videoJob) updatePopularVideos() &#123;\tvar nums int64\tticker := time.NewTicker(3 * time.Hour)\tfor &#123;\t\tnums = (nums + 1) % 2 // nums控制当前版本\t\tcommon.PopularVideoVersion.Store(nums + 1)        // 刷DB，获取当前热门视频id\t\tvideoIds, err := v.videoServer.VideoDal.GetPopularVideos(popularVideosNum)\t\tif err != nil &#123;\t\t\tlogger.Logger.Error(fmt.Sprintf(&quot;updatePopularVideos v.videoServer.VideoDal.GetPopularVideos err:%+v&quot;, videoIds))\t\t\t// 一分钟后重试\t\t\t&lt;-time.After(5 * time.Minute)\t\t\tcontinue\t\t&#125;\t\tpopularItem := make([]*cache.VideoPopularItem, len(videoIds))\t\tfor i := range videoIds &#123;\t\t\tsScore := fmt.Sprintf(&quot;%d.%d&quot;, videoIds[i].Count, videoIds[i].VideoID)\t\t\tpopularItem[i] = &amp;cache.VideoPopularItem&#123;Vid: videoIds[i].VideoID&#125;\t\t\tpopularItem[i].Score, _ = strconv.ParseFloat(sScore, 64)\t\t&#125;        // 将热门视频id写入当前版本\t\tkey := cache.PopularVideoKey(common.GetPopularVideoVersion())\t\tcache.BuildPopularVideo(key, popularItem)\t\t&lt;-ticker.C\t&#125;&#125;\n\n从redis中分页获取当前热门视频\n// GetPopularVideo 获取当前热门视频func GetPopularVideo(version int, score float64, count int64) (videoIds []uint, nextScore float64, nextVersion int, ok bool) &#123;\tvar (\t\tkey      string\t\tmaxScore string\t)    \tif version == 0 &#123; // 未携带版本，赋为当前版本\t\tversion = common.GetPopularVideoVersion()\t&#125;\tnextVersion = version\tkey = PopularVideoKey(version)\tif score == 0 &#123; // 首次请求，未携带score\t\tmaxScore = &quot;+inf&quot;\t&#125; else &#123; // 小于传入score\t\tmaxScore = fmt.Sprintf(&quot;(%f&quot;, score)\t&#125;\t// 从 ZSET 中按分数从大到小获取前 count 个成员\tresult, err := RDB.ZRevRangeByScoreWithScores(Ctx, key, &amp;redis.ZRangeBy&#123;\t\tMax:    maxScore,\t\tOffset: 0,\t\tCount:  count - 1,\t&#125;).Result()\tif err != nil || len(result) == 0 &#123;\t\t// 错误处理，缓存侧错误不传递到上级，告知结果是否回源即可\t\tlogger.Logger.Error(fmt.Sprintf(&quot;GetPopularVideo RDB.ZRevRangeByScoreWithScores err:%+v&quot;, err))\t\treturn nil, -1, nextVersion, err == nil\t&#125;\tfor _, z := range result &#123;\t\tvid, _ := strconv.Atoi(z.Member.(string))\t\tvideoIds = append(videoIds, uint(vid))\t&#125;\tnextScore = result[len(result)-1].Score\treturn videoIds, nextScore, nextVersion, true&#125;\n\n判断用户是否点赞判断用户是否为该视频点过赞，查询量较大，有以下三种应对方式\n\n不做缓存 -&gt; DB压力较大\n全量缓存 -&gt; 随时间推移，缓存侧存储压力较大\n部分缓存 -&gt; 如何判断是否回源？\n\n前两个基本是不能接受的，不予考虑。先说下结论，最终我们选择了下文的方案二\n方案一：缓存过期不回源对于部分缓存，判断何时回源是很重要的，若缓存过期时间很短，未查到缓存则接回源，那DB侧压力仍然很大\n另一种方法是提高缓存时间，均不回源：\n简单计算一下，如果设置30天过期时间，每天300万用户，每人点赞20个视频，假设一个是0.5kb 30*300按10000，10k*20*0.5kb，大约是100Mb\n\n查询缓存成功：表示点过赞，返回true\n查询缓存不成功：30天以前点过赞&#x2F;没点过赞，不回源，直接返回false\n\nDB存储点赞数据时，我们可以在uid与vid间添加唯一索引，插入数据使用insert on duplicate key update保证幂等\n这个存储量，如果我们把时间过期时间拉到一年，其实也是可以接受的。但问题在于业务是否可以接受一年前点过赞的视频，再次打开时不显示点过赞。\n并且因为要为不同的key设置不同过期时间，可以选用string和zset两种形式\n\nstring形式：key分布较为分散，无法进行统一管理，较为不便\nzset形式：要过期的时间记为score，异步清除 - 实现较为麻烦\n\n方案二：用户维度存储点赞视频，冷热数据分离冷数据回源该方案参考了 得物 的点赞设计，设计较为巧妙，缓存结构如下：\nlike:15中15为用户uid，3454、723、645均为用户点过赞的视频vid，minVid是冷热数据的分界线，低于该值记为冷数据，ttl为过期时间\n&#123;  &quot;like:15&quot;:&#123;    &quot;ttl&quot;:1653532653,    // 缓存新建或更新时时间戳    &quot;3454&quot;:1,            // 用户近一段时间点赞过的视频id    &quot;723&quot;:1,            // 用户近一段时间点赞过的视频id    &quot;645&quot;:1,            // 用户近一段时间点赞过的视频id    &quot;minVid&quot;:645        // 缓存中最小的视频id，用以区分冷热  &#125;&#125;\n\n设计思路如下：\n\n用户维度：判断是否点赞业务场景一般是：一个用户对应一堆视频，以用户维度创建缓存，可以大幅减少命令执行次数\n冷热数据分离：视频id是自增的，id从大到小对应这上传时间从新到旧，用户刷到旧视频的频率相对较低，可根据视频id进行冷热数据分离\n冷数据回源：冷数据回源查DB，并写入缓存，这样就可以保证缓存高效利用而且压力不过太大\n冷热阈值：限制hash中的字段数，批量查询时，若发现字段数超过1500则查询结束后重构缓存，取前750个视频id，修改minVid\nttl字段：以前每次查看是否要更新缓存时，都要调用TTL命令，执行命令次数翻倍，将TTL写入字段一同查询，可减少命令数\n续期：当TTL临近过期(达到2&#x2F;3时)进行续期\n\n业务逻辑批量获取用户是否点赞：\n\nHMGET获取vid1、vid2、vid3、ttl、minVid\n获取失败：不存在该key，重新构建\n获取成功但vid未找到\nvid &gt;&#x3D; minVid &#x3D;&#x3D;》未点赞\nvid &lt;  minVid &#x3D;&#x3D;》冷数据，回源查DB，并写入缓存\n\n\n检查TTL快过期则续期\n检测字段值是否超过阈值，超过则重建\n\n\n返回结果\n\n用户点赞：更新DB，HSET添加该字段，不存在则构建\n用户删除：更新DB，HDEL删除该字段，不做其他处理\n优点：\n\n可高效利用缓存且缓存存储量不大\nDB回源的数据量可以接受\n\n缺点：实现起来较为复杂\n代码实现这种缓存模式下需要关注：点赞、取消点赞、批量判断用户是否点赞\n我们先实现基本的方法：\n\n构建用户点赞视频缓存 - 相对简单，根据视频id和阈值HMSet即可，代码见utopia-back\\cache\\like.go:190\n判断数量是否超过阈值 - 查询字段数，和阈值去做判断\n超出阈值重建缓存\n\n超出阈值重建缓存时，其中一半的字段是可以保留的，删除不需要的即可\n\n先取出所有字段，排序后将minVid设置为第750位的vid\n调用 构建用户点赞视频缓存 函数，不需要传视频id，通过该函数刷新ttl与minVid即可\n调用HMDel删除剩余字段\n\n实现代码见utopia-back\\cache\\like.go:271\n在utopia-back\\cache\\like.go:271将 用户点赞视频批量写入缓存 进行封装，用户点赞时进行调用。\n判断用户是否批量为视频点赞时，检查ttl与字段数量，需要则调用方法进行重建：\n// utopia-back\\cache\\like.go:138// IsUserLikedVideos 用户是否为某些视频点赞(批量)//// result key为vid  &lt;-&gt;  0未点赞；1为点赞；2 冷数据,需回源//// state 0 成功；1 不存在该key,需要新建；2 查询失败,需回源func IsUserLikedVideos(uid uint, videoIds []uint) (result map[uint]int, state int) &#123;\tkey := UserLikedVideoKeyV3(uid)\tfields := make([]string, len(videoIds)+2)\tfields[0], fields[1] = sMinVid, sTTL\t// 将整数切片转换为字符串切片\tfor i, num := range videoIds &#123;\t\tfields[i+2] = strconv.FormatInt(int64(num), 10)\t&#125;\t// 查询是否存在\tresHMGet := RDB.HMGet(Ctx, key, fields...)\tif resHMGet.Err() != nil &#123;\t\tlogger.Logger.Error(fmt.Sprintf(&quot;IsUserLikedVideos cmd:%v&quot;, resHMGet.String()))\t\tstate = 2\t\treturn\t&#125; else &#123;\t\tlogger.Logger.Info(fmt.Sprintf(&quot;IsUserLikedVideos cmd:%v&quot;, resHMGet.String()))\t&#125;\tsMinVidVal, ok1 := resHMGet.Val()[0].(string)\tsTtlVal, ok2 := resHMGet.Val()[1].(string)\tif !ok1 || !ok2 &#123; // 不存在该key，需重新构建\t\tstate = 1\t\treturn\t&#125;\tminVid, _ := strconv.Atoi(sMinVidVal)\tttl, _ := strconv.Atoi(sTtlVal)\tstate = 0 // 查询成功，state标为0\tvidRes := resHMGet.Val()[2:]\tresult = make(map[uint]int, len(videoIds))\tfor i, vid := range videoIds &#123;\t\tif _, ok := vidRes[i].(string); ok &#123; // 查询到点赞\t\t\tresult[vid] = 1\t\t&#125; else if vid &gt;= uint(minVid) &#123; // 热数据，用户没点赞\t\t\tresult[vid] = 0\t\t&#125; else &#123; // 冷数据，需要回源\t\t\tresult[vid] = 2\t\t&#125;\t&#125;\t// 判断是否超过域值，是否需要续期\tjudgeRebuildVideoLikedVideos(key, ttl)\treturn&#125;\n\n接口及IP限流采用 令牌桶 对可针对不同接口配置不同的限流策略，同时支持对用户IP限流，防止用户恶意攻击\n通过github.com/juju/ratelimit实现令牌桶，将接口做map的key，对应不同的*BucketConf，BucketConf包含一个Bucket，用于对接口进行限流，接口限流支持阻塞等待，配置maxWait\n每隔BucketConf配置一个map[string]*ratelimit.Bucket，用于对IP进行限流，IP限流不支持阻塞等待，达到阈值时直接阻止该请求。\nvar BucketMap = make(map[string]*BucketConf)var defaultIpRateConf = &amp;IpRateConf&#123;\tFillInterval: 100 * time.Millisecond,\tCapacity:     5,&#125;type BucketConf struct &#123;\tBucket  *ratelimit.Bucket\tMaxWait time.Duration\tIpRateConf   *IpRateConf\tIpRateBucket map[string]*ratelimit.Bucket&#125;type IpRateConf struct &#123;\tFillInterval time.Duration\tCapacity     int64&#125;\n\n限流中间件初始化，对不同接口和对不同接口下的IP配置不同的限流策略\n// InitRateLimit 注册限流func InitRateLimit() &#123;\t// 需要限流的接口在此注册\t// 参考文章：https://blog.csdn.net/m0_52528053/article/details/127294249\tmiddleware.BucketMap[&quot;/api/v1/upload/token&quot;] = &amp;middleware.BucketConf&#123;\t\t// 每10ms产生5个token，最多存储10个token\t\tBucket: ratelimit.NewBucketWithQuantum(10*time.Millisecond, 10, 5),\t\t// 最大等待时间\t\tMaxWait: 20 * time.Millisecond,\t\tIpRateConf: &amp;middleware.IpRateConf&#123;\t\t\tFillInterval: time.Second,\t\t\tCapacity:     5,\t\t&#125;,\t&#125;\tmiddleware.BucketMap[&quot;/api/v1/upload/callback&quot;] = &amp;middleware.BucketConf&#123;\t\tBucket:  ratelimit.NewBucketWithQuantum(10*time.Millisecond, 10, 5),\t\tMaxWait: 20 * time.Millisecond,\t&#125;\tmiddleware.BucketMap[&quot;default&quot;] = &amp;middleware.BucketConf&#123;\t\tBucket:  ratelimit.NewBucketWithQuantum(10*time.Millisecond, 100, 20),\t\tMaxWait: 10 * time.Millisecond,\t&#125;\tmiddleware.FillDefault()&#125;\n\n将代码注册到路由中间件，当请求失败时报错请求频繁。\n// 代码注册到路由中间件func RateLimit(c *gin.Context) &#123;\tbucketConf, ok := BucketMap[c.Request.URL.Path]\tif !ok &#123;\t\tbucketConf = BucketMap[&quot;default&quot;]\t&#125;\tif bucketConf.Bucket.WaitMaxDuration(1, bucketConf.MaxWait) &#123;\t\tipRateValidate(c.ClientIP(), bucketConf.IpRateConf, bucketConf.IpRateBucket)\t\tc.Next()\t\treturn\t&#125;\tc.JSON(http.StatusOK, gin.H&#123;\t\t&quot;code&quot;: 501,\t\t&quot;msg&quot;:  &quot;请求频繁，请稍后重试&quot;,\t&#125;)\tc.Abort()\treturn&#125;\n\n待改进\n七牛云存储 kodo 自定义变量直接使用用户id\n\n七牛云回调不支持自定义header，所以直接在自定义变量中传递的用户id来判断身份，这块肯定是不安全的，用户找到对应接口后，完全可以自己尝试去替换别人的头像或给别人上传视频。自定义变量应改为用户自身token，服务端单独鉴权\n\n用户 点赞&#x2F;取消点赞 时，直接写入like_counts表\n\n此处具有较大的优化空间，倘若每次点赞都回写一次，点赞这种高并发场景会将DB压垮。\n改进方案：\n\n接入消息队列，收到点赞消息后异步处理like_counts表\n使用消息队列解耦后，以视频id进行聚合，之后批量写入DB，例如vid&#x3D;13的视频，点赞量达到20后，对应字段直接加20，减少对DB的请求\n\n","categories":["技术","项目"],"tags":["后端"]},{"title":"字节后端青训营抖音项目文档","url":"/2022-07-18/8f324487ccc8/","content":"项目说明实现功能实现了接口文档中给出的所有接口\n\n用户模块：注册、登录、获取用户信息\n视频流模块：发布视频、获取Feed流、查看个人已发布视频\n关注模块：关注操作、获取关注列表、获取粉丝列表\n评论模块：评论操作、获取评论列表\n点赞模块：点赞操作、获取点赞列表\n\n环境配置\nGo版本&gt;&#x3D;1.17.3\n数据库：MySQL8.0\nRedis：3.2.100\n\n项目使用\n已将数据库部署于服务器上，也可根据表设计模块中给出的建表语句在本地创建数据库\n启动Redis（非必须）\n在ByteDance/pkg/common/config.go中填写相应配置项（也可使用当前默认配置）\n安装依赖。在ByteDance目录下运行go mod tidy\n运行。运行go build &amp;&amp; ByteDance.exe，端口开放于8000\n\n项目说明\n视频模块中采用阿里云OSS对象存储\n数据库部署在服务器中，但服务器性能较差\n采用ffmpeg获取视频封面，ffmpeg.exe已同步上传项目，但对于windows以外的电脑需要提前安装ffmpeg\nRedis并不是启动项目所必须的，但缺省时会缺少限制频率的功能\n\n项目结构ByteDance│  .gitignore│  ffmpeg.exe\t// 截取视频第一帧│  go.mod│  Readme.md│  router.go\t// 创建路由│  server.go\t// 项目启动入口│├─cmd│  ├─user│  │  │  user_common_model.go\t// user模块中共用的结构体│  │  ├─controller\t\t// 控制层，接受参数，编写流程逻辑，返回信息│  │  │      query_user_info.go│  │  ├─repository\t\t// 负责与数据库的交互│  │  │      user.go│  │  └─service\t\t\t// 处理流程中的主要函数│  │          query_user_info.go│  ├─comment\t\t// 其他模块与user模块结构相同│  ├─favorite│  ├─follow│  └─video├─dal\t\t// MySQL、Redis初始化│  │  dal.go│  ├─method│  │      dal_common_method.go\t// 共用的查询方法│  │      method.go\t\t// 自定义查询方法，用Gen生成│  ├─model\t\t// Gen生成的数据模型│  └─query\t\t// Gen生成的数据库操作方法├─logs\t\t// 日志存放位置├─pkg│  ├─common│  │      common.go\t\t// 模块公用部分│  │      config.go\t\t    // 配置项│  ││  ├─middleware\t\t // 中间件│  │      middleware.go│  ││  └─msg\t// 定义返回消息│          msg.go│└─utils\t\t // 工具类    │  jwt.go\t\t\t\t// 生成Token令牌    │  log.go\t\t\t\t// 日志生成    │  password.go\t\t\t// MD5加密，检测密码强度    │  SensitiveWords.txt\t     // 项目     │  sensitive_word.go    │  snowflake.go\t\t\t// 雪花算法    │  upload_file.go\t\t  // OSS中上传文件    └─generate            generate.go\t\t      // Gen生成模块与方法\n\n\n\n成员分工\n\n\n成员\n分工\n\n\n\n田冰航\n数据库设计，项目结构设计，用户注册功能，获取视频流功能，上传视频功能，查看已发布视频功能\n\n\n向政昌\nValidate数据验证，敏感词过滤，redis中间件限制频率，评论功能，点赞功能，相关功能文档撰写\n\n\n徐洪湘\nJWT令牌功能实现，数据库设计，项目结构设计，关注功能，相关功能文档攥写\n\n\n王智轶\n获取用户信息，相关功能文档撰写\n\n\n张建行\n用户登录功能，相关功能文档撰写\n\n\n后记技术相关及功能实现请移步汇报文档：极简版抖音项目汇报文档（打工魂小组）\n","categories":["技术","项目"],"tags":["后端"]},{"title":"字节后端青训营抖音项目汇报文档（打工魂小组）","url":"/2022-07-18/32cadae00b68/","content":"\n基本信息：本文档主要介绍2022字节跳动后端青训营抖音项目\n时间：2022.05-2022.06\n成员：田冰航、徐洪湘、向政昌\n\n图片有点多，飞书这里不能直接引用，重新下载有点不方便，所以图片有所删减，建议移步：极简版抖音项目汇报文档（打工魂小组）\n一、项目概要1.1 项目仓库和成果展示\n项目仓库地址：GitHub项目地址\n视频演示：抖音演示视频.mp4\n\n1.2 项目环境配置说明1.2.1 项目使用\n已将数据库部署于服务器上，也可根据表设计模块中给出的建表语句在本地创建数据库\n启动Redis（非必须）\n在ByteDance/pkg/common/config.go中填写相应配置项（也可使用当前默认配置）\n安装依赖。在ByteDance目录下运行go mod tidy\n运行。运行go build &amp;&amp; ByteDance.exe，端口开放于8000\n\n1.2.2 项目说明\n视频模块中采用阿里云OSS对象存储\n数据库部署在服务器中，但服务器性能较差\n采用ffmpeg获取视频封面，ffmpeg.exe已同步上传项目，但对于windows以外的电脑需要提前安装ffmpeg\nRedis并不是启动项目所必须的，但缺省时会缺少限制频率的功能\n\n1.3 成员分工\n\n\n成员\n分工\n\n\n\n田冰航\n数据库设计，项目结构设计，用户注册功能，获取视频流功能，上传视频功能，查看已发布视频功能\n\n\n向政昌\nValidate数据验证，敏感词过滤，Redis中间件限制频率，评论功能， 点赞功能，相关功能文档撰写\n\n\n徐洪湘\nJWT令牌功能实现，数据库设计，项目结构设计，关注功能，相关功能文档攥写\n\n\n1.4 技术使用\nGin\nGen\nMySQL\nOSS\nGit\nRedis\nJWT\n\n二、功能实现2.1 用户模块\n注册操作\n\n使用使用Validate验证器对参数进行验证\n\n检测用户名是否已存在\n\n校验密码强度，要求用户名必须小于32位字符，密码大于8位小于32位字符，至少包含一位数字，字母和特殊字符\n\n对密码加盐后使用md5加密，写入数据库中\n\n将用户ID封装后返回\n\n\n\n登录操作\n\n使用使用Validate验证器对参数进行验证\n\n对密码进行同样的加密，检测数据库中是否存在该记录且deleted为0\n\n更新登录时间\n\n将user_id作为payload通过JWT生成Token\n\n将Token和user_id进行封装并返回\n\n\n\n获取用户信息\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n\n验证成功：将user_id存入上下文中\n\n\n\n查询用户信息封装后返回\n\n\n\n\n2.2 视频模块\n获取视频流\n\n使用JWT中间件对Token进行验证\n\n验证失败：不进行操作，继续进行\n验证成功：将user_id存入上下文中\n\n\n内联查询最新发布的十个视频及作者信息\n\n上下文中含有user_id：并发查询十个视频是否被该用户点赞，作者是否被该用户关注\n\n上下文中不含user_id：默认为视频未点赞，作者未被关注\n\n\n\n封装数据返回信息\n\n\n\n发布视频\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n从参数中获取视频及视频信息，从上下文中获取user_id\n\n采用雪花算法生成视频及封面名称作为标识\n\n使用ffmpeg截取视频第一帧作为封面\n\n将封面、视频上传至阿里云OSS中，截取并上传封面与上传视频二者并发进行\n\n将视频名称、封面名称及视频和作者的相关信息存入数据库中\n\n封装发布完成情况并返回\n\n\n\n查看已发布视频\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n从上下文中获取user_id\n\n内联查询已发布的所有视频及本人信息\n\n封装数据返回信息\n\n\n\n\n2.3 关注模块\n关注操作\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据所传入信息对数据库进行更新（已经关注过），如果数据库没有改条数据，则创建该数据（没有关注过）\n\n根据查询信息进行数据封装后返回\n\n\n\n获取关注列表\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n\n验证成功：将user_id存入上下文中\n\n\n\n使用使用Validate验证器对参数进行验证\n\n根据登录用户id使用联合索引获取关注用户id列表，并发查询关注用户名和关注总数和粉丝总数\n\n根据查询信息进行数据封装后返回\n\n\n\n获取粉丝列表\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据登录用户id使用联合索引获取粉丝用户id列表，并发查询粉丝用户名和关注总数和粉丝总数\n\n根据查询信息进行数据封装后返回\n\n\n\n\n2.4 评论模块\n评论操作\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据所传入信息，若action_type为1且评论内容存在，数据库中创建该数据，若action_type为2且视频id存在对数据库进行更新（软删除）。\n\n根据查询信息进行数据封装后返回\n\n\n\n获取评论列表\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据视频id使用联合查询获取评论信息列表（包含评论用户信息）\n\n根据查询信息进行数据封装后返回\n\n\n\n\n2.5 点赞模块\n点赞操作\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据所传入信息对数据库进行更新（已经点赞过，取消点赞），如果数据库没有该条数据，则创建该数据（没有点赞过，进行点赞）\n\n根据查询信息进行数据封装后返回\n\n\n\n获取点赞列表\n\n使用JWT中间件对Token进行验证\n\n验证失败：返回失败原因，阻止向下运行\n验证成功：将user_id存入上下文中\n\n\n使用使用Validate验证器对参数进行验证\n\n根据登录用户id使用联合查询获取点赞视频信息列表（包含视频作者部分信息），然后并发查询视频作者关注总数、粉丝总数和是否已关注\n\n根据查询信息进行数据封装后返回\n\n\n\n\n三、代码质量3.1 MVC\nRequest\n创建数据传输对象封装传入数据\n\n\n\ntype RegUserData struct &#123;\tID    int    `json:&quot;user_id&quot;`\tToken string `json:&quot;token&quot;`&#125;type LoginData struct &#123;\tID    int    `json:&quot;user_id&quot;`\tToken string `json:&quot;token&quot;`&#125;type GetUserInfoData struct &#123;\tID            int32  `json:&quot;id&quot;`\tUseName       string `json:&quot;name&quot;`\tFollowCount   int64  `json:&quot;follow_count&quot;`\tFollowerCount int64  `json:&quot;follower_count&quot;`\tIsFollow      bool   `json:&quot;is_follow&quot;`&#125;\n\n\nResponse\n\nsevice层封装返回数据的对象\n\ncontroller层进一步封装数据对象，如添加返回响应信息，响应码等\n\n\n\n\n// 用户登录返回值type loginResponse struct &#123;\tcommon.Response\tuser.LoginData&#125;// 用户注册返回值type regUserResponse struct &#123;\tcommon.Response\tuser.RegUserData&#125;// 获取用户信息type getUserInfoResponse struct &#123;\tcommon.Response\tUser user.GetUserInfoData `json:&quot;user&quot;`&#125;// RegisterLoginRequest 注册 登录请求type RegisterLoginRequest struct &#123;\tUsername string `form:&quot;username&quot;  validate:&quot;required&quot;`\tPassword string `form:&quot;password&quot;  validate:&quot;required&quot;`&#125;\n\n\ncontroller\n\ncontroller层只负责token验证，数据有效性验证，和数据请求的预处理和返回数据的封装，达到进一步解耦，职责明确\n\nservice\n\nservice层只负责接受来自controller层的数据，所有的业务逻辑都在这里处理，并调用repository层中设计数据库的操作，最后封装来自数据库的数据，返回给controller层\n\nrepository\n\nrepository层只负责对数据库的操作，比如DDL，DQL等，如果数据库出现问题，则可以直在repository层查找错误，利于后期维护\n3.2 命名规范\n模块命名\n\n以user模块举例：\n\ncontoller：query_xxx_info.go\nservice命名query_xxx_info.go\nrepository层则是模块名xxx.go\n\n\n函数命名：采用驼峰命名法\n\n变量命名：根据英文释义采用驼峰命名法，可直观看出变量作用\n\n\n3.3 常量与配置管理\n常量管理\n\n将所有消息规整在一个文件中，便于根据报错信息查找引用及时进行定位\n// 用户注册const (\tAlreadyRegisteredStatusMsg = &quot;该用户名已被注册&quot;\tRegisterSuccessStatusMsg   = &quot;注册成功&quot;\tMatchFailedStatusMsg       = &quot;账号密码需要小于32字符，密码包含至少一位数字，字母和特殊字符&quot;)// 用户登录const (\tWrongUsernameOrPasswordMsg = &quot;用户名或密码错误&quot;\tLoginSuccessStatusMsg      = &quot;登陆成功&quot;\tAccountBlocked             = &quot;账号已被冻结&quot;)// 获取用户信息const (\tUserIDNotExistMsg     = &quot;用户ID不存在&quot;\tGetUserInfoSuccessMsg = &quot;获取用户信息成功&quot;)// 等……\n\n\n配置管理\n\n将数据库、OSS和JWT相关配置项进行抽离，便于对项目进行配置\nconst MySqlDSN = &quot;&quot;// Redis 配置const (   RedisLocalhost = &quot;localhost:6379&quot;   RedisPassword  = &quot;&quot;   RedisDB        = 0)// MD5Salt MD5加密时的盐const MD5Salt = &quot;UII34HJ6OIO&quot;// JWTconst (   Issuer              = &quot;xhx&quot; // 签发人   MySecret            = &quot;F3Jfa5AD&quot;   TokenExpirationTime = 14 * 24 * time.Hour * time.Duration(1) // Token过期时间)// OSSPreURL OSS前缀const OSSPreURL = &quot;&quot;// SensitiveWordsPath 敏感词路径const SensitiveWordsPath = &quot;./utils/SensitiveWords.txt&quot;\n\n3.4 日志记录使用go.uber.org/zap进行日志管理，文件配置项如下：\n//文件writeSyncerfileWriteSyncer := zapcore.AddSync(&amp;lumberjack.Logger&#123;   Filename:   &quot;./logs/ByteDance.log&quot;, //日志文件存放目录   MaxSize:    1,                      //文件大小限制,单位MB   MaxBackups: 5,                      //最大保留日志文件数量   MaxAge:     30,                     //日志文件保留天数   Compress:   false,                  //是否压缩处理&#125;)\n\n全局配置Log变量，记录四种类型的日志：Info、Warn、Error、Fatal\n\nInfo类型\n\nMySQL、Redis、OSS初始化成功时输出\ndb, err = gorm.Open(mysql.Open(common.MySqlDSN))if err != nil &#123;   utils.Log.Fatal(&quot;数据库连接错误&quot; + err.Error())&#125; else &#123;   utils.Log.Info(&quot;MySQL连接成功&quot;)&#125;\n\n\nWarn类型\n\nRedis未连接时输出（未连接Redis会确实限制频率功能，当项目可以正常运行）\n// 通过 *redis.Client.Ping() 来检查是否成功连接到了redis服务器_, err := RedisDb.Ping().Result()if err != nil &#123;   utils.Log.Warn(&quot;Redis连接失败&quot;)   return false&#125; else &#123;   utils.Log.Info(&quot;Redis连接成功&quot;)   return true&#125;\n\n\nError类型：程序正常运行时，不该出现的错误\n\n数据库查询错误、类型转化错误等\n// 文件上传日志记录if fileType == &quot;video&quot; &#123;   fileSuffix = &quot;.mp4&quot;&#125; else if fileType == &quot;picture&quot; &#123;   fileSuffix = &quot;.jpg&quot;&#125; else &#123;   Log.Error(&quot;无法上传&quot; + fileType + &quot;类型文件&quot;)   return false&#125;\n\n\nFatal类型：错误出现后，系统无法正常启动\n\nMySQL连接失败\ndb, err = gorm.Open(mysql.Open(common.MySqlDSN))if err != nil &#123;   utils.Log.Fatal(&quot;数据库连接错误&quot; + err.Error())&#125; else &#123;   utils.Log.Info(&quot;MySQL连接成功&quot;)&#125;\n\n四、项目设计4.1 数据库设计4.1.1 数据库ER图\n4.1.2 数据库表\nuser表\nusername,deleted联合索引\n\n\n\ncreate table user(    id          int auto_increment comment &#x27;PK，直接自增&#x27;        primary key,    username    varchar(32)                        not null comment &#x27;UK，账号&#x27;,    password    varchar(32)                        not null comment &#x27;密码（MD5）&#x27;,    enable      tinyint  default 1                 null comment &#x27;账号是否可用&#x27;,    deleted     tinyint  default 0                 null comment &#x27;删除标识位&#x27;,    login_time  datetime default CURRENT_TIMESTAMP null,    create_time datetime default CURRENT_TIMESTAMP null comment &#x27;注册时间&#x27;)    comment &#x27;用户表，储存用户信息&#x27;;create index user_username_deleted_index    on user (username, deleted);\n\n\nvideo表\nauthor_id,removed,deleted联合索引\ntime,removed,deleted联合索引\n\n\n\ncreate table video(    id        int auto_increment        primary key,    author_id int               not null,    play_url  varchar(32)       not null,    cover_url varchar(32)       not null,    time      int               not null,    title     varchar(128)      not null,    removed   tinyint default 0 not null,    deleted   tinyint default 0 not null,    constraint video_user_id_fk        foreign key (author_id) references user (id))    comment &#x27;存储视频信息&#x27;;create index video_author_id_removed_deleted_index    on video (author_id, removed, deleted);create index video_time_removed_deleted_index    on video (time, removed, deleted);\n\n\nfollow表\nuser_id,removed,deleted联合索引\nfun_id,removed,deleted联合索引\n\n\n\ncreate table follow(    id      int auto_increment        primary key,    user_id int               null,    fun_id  int               not null,    removed tinyint default 0 not null,    deleted tinyint default 0 not null,    constraint follow_user_id2fun_fk_2        foreign key (fun_id) references user (id),    constraint follow_user_id2user_fk        foreign key (user_id) references user (id))    comment &#x27;关注表&#x27;;create index follow_fun_id_removed_deleted_index    on follow (fun_id, removed, deleted);create index follow_user_id_removed_deleted_index    on follow (user_id, removed, deleted);\n\n\nfavorite表\nvideo_id,removed,deleted联合索引\nuser_id,removed,deleted联合索引\n\n\n\ncreate table favorite(    id       int auto_increment        primary key,    video_id int                not null,    user_id  int                not null,    removed  tinyint default -1 not null,    deleted  tinyint default 0  not null,    constraint favorite_user_id_fk        foreign key (user_id) references user (id),    constraint favorite_video_id_fk        foreign key (video_id) references video (id))    comment &#x27;用户视频点赞表&#x27;;create index favorite_user_id_video_id_removed_deleted_index    on favorite (user_id, video_id, removed, deleted);create index favorite_video_id_removed_deleted_user_id_index    on favorite (video_id, removed, deleted, user_id);\n\n\ncomment表\nuser_id\nvideo_id,removed,deleted联合索引\ncreate_time,removed,deleted联合索引\n\n\n\ncreate table comment(    id          int auto_increment        primary key,    user_id     int                                not null,    video_id    int                                not null,    create_time datetime default CURRENT_TIMESTAMP not null,    removed     tinyint  default 0                 not null,    deleted     tinyint  default 0                 not null,    content     text                               not null,    constraint comment_user_id_fk        foreign key (user_id) references user (id),    constraint comment_video_id_fk        foreign key (video_id) references video (id))    comment &#x27;评论表&#x27;;create index comment_create_time_removed_deleted_index    on comment (create_time, removed, deleted);create index comment_video_id_removed_deleted_index    on comment (video_id, removed, deleted);\n\n\n4.2 项目结构设计ByteDance│  .gitignore│  ffmpeg.exe  // 截取视频第一帧│  go.mod│  Readme.md│  router.go   // 创建路由│  server.go   // 项目启动入口│├─cmd│  ├─user│  │  │  user_common_model.go  // user模块中共用的结构体│  │  ││  │  ├─controller    // 控制层，接受参数，编写流程逻辑，返回信息│  │  │      query_user_info.go│  │  ││  │  ├─repository    // 负责与数据库的交互│  │  │      user.go│  │  ││  │  └─service          // 处理流程中的主要函数│  │          query_user_info.go│  ││  ├─comment      // 其他模块与user模块结构相同│  ├─favorite│  ├─follow│  └─video│├─dal     // MySQL、Redis初始化│  │  dal.go│  ├─method│  │      dal_common_method.go // 共用的查询方法│  │      method.go            // 自定义查询方法，用Gen生成│  ││  ├─model    // Gen生成的数据模型│  └─query    // Gen生成的数据库操作方法│├─logs    // 日志存放位置├─pkg│  ├─common│  │      common.go       // 模块公用部分│  │      config.go           // 配置项│  ││  ├─middleware        // 中间件│  │      middleware.go│  ││  └─msg   // 定义返回消息│          msg.go│└─utils        // 工具类    │  jwt.go           // 生成Token令牌    │  log.go           // 日志生成    │  password.go       // MD5加密，检测密码强度    │  SensitiveWords.txt       // 项目     │  sensitive_word.go    │  snowflake.go          // 雪花算法    │  upload_file.go       // OSS中上传文件    └─generate            generate.go             // Gen生成模块与方法\n\n五、项目亮点5.1 代码管理使用Git进行分工合作，对版本进行控制 （1）版本迭代更加清晰 （2）提升开发效率 （3）利于代码review的实现，规范团队项目开发\n5.2高性能5.2.1 OSS对象存储采用阿里云oss存储上传视频 （1）节省服务器空间，单独的文件管理界面，管理网站文件和本地电脑一样方便\n5.2.2 雪花算法采用雪花算法生成给上传的视频设置随机id （1）高性能：ID在内存生成，不依赖数据库 （2）高可用：ID在内存生成，不依赖数据库 （3）容量大：每秒能生成百万量级的ID\n5.2.3 GEN自定义模型首先进行表设计，将数据库部署在服务器上，通过Gen生成模型和查询方式，对常用查询方法采用自定义方法的方式 （1）简化代码且减少编码时间\n5.2.4 MySQL索引数据库表统一采用InnoDB存储引擎，索引结构默认B+树，通过主键索引，二级索引中遵循最左前缀法则对数据进行搜索 （1）主键索引也为聚集索引，聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据 （2）二级索引也为非聚集索引，更新代价比聚集索引要小。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的，只存放主键信息或指针\n5.2.5 单例模式用init函数对每个模块的dao对象，数据库连接等进行初始化，放在内存当中，当要使用的时候，即可以从内存中直接取出，不用新建对象 （1）提供了对唯一实例的受控访问 （2）由于在系统内存中只存在一个对象，因此可以 节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能 （3）避免对共享资源的多重占用 （4）通过饿汉模式，在所有程序执行开始前被调用直接创建并初始化单例对象，所以并不存在线程安全的问题\n5.2.6 并发编程通过go语言的协程，优雅地进行并发编程，以此并发对数据库进行操作，大大提升其响应速度，因为MySQL的InnoDB引擎支持事务，所以不用担心起并发安全问题 （1）Goroutine所需要的内存通常只有2kb，而线程则需要1Mb,内存消耗更少 （2）由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低\n5.3 安全问题5.3.1 Token验证采用JWT进行Token验证，中间件中对Token进行解析和判断，阻止Token不合法或已过期的请求，将token中携带的user_id信息写入 *gin.Context 声明的参数中供后续使用，考虑到前端未采用refresh_token进行刷新，将Token过期时间设置为14天 （1）解决了用户鉴权问题 （2）防止 CSRF攻击\n5.3.2 防止SQL注入根据所选框架为Gen，Gen 提供了自动同步数据表结构体到 GORM 模型，使用非常简单，即使数据库字段信息改变，可以一键同步，数据库查询相关代码可以一键生成，CRUD 只需要调用对应的方法，开发体验飞起 （1）GEN 采用了类型安全限制，所有参数都做了安全限制，完全不用担心存在注入 （2）自定义 SQL 只需要通过模板注释到 interface 的方法上，自动生成安全的代码SQL ，也不会出现SQL 注入问题\n5.3.3 参数校验采用Validate对请求参数进行合法性校验，阻止不符合参数要求的请求，二次避免SQL、XSS注入，防止通过发送请求对程序进破坏。\n// FavoriteListResponse 点赞列表返回值type FavoriteListResponse struct &#123;\tcommon.Response\tVideoList []video.TheVideoInfo `json:&quot;video_list&quot;`&#125;// FavoriteActionRequest 点赞与取消请求type FavoriteActionRequest struct &#123;\tToken      string `form:&quot;token&quot;        validate:&quot;required,jwt&quot;`\tVideoId    int64  `form:&quot;video_id&quot;     validate:&quot;required,numeric,min=1&quot;`\tActionType int32  `form:&quot;action_type&quot;  validate:&quot;required,numeric,oneof=1 2&quot;`&#125;\n\n5.3.4 密码安全对参数进行校验，要求用户名必须小于32位字符，密码大于8位小于32位字符，至少包含一位数字，字母和特殊字符。 将用户密码加盐使用md5加密再存入数据库中确保用户密码的安全性\n5.3.5 敏感词检测采用go-wordsfilter对评论和发布视频请求中的文本信息进行敏感词检测，敏感词类型涉及黄赌毒、党政、欺骗消费者等方面。检测到敏感词后，阻止本次请求，并写入日志。\n5.4 高可用5.4.1 恶意请求限流采用Redis记录请求ip，设置过期时间为5秒，同一ip5秒内访问超过100次的其余请求在中间件中被阻止，避免网站负载升高或者造成网站带宽阻塞而拒绝或无法响应正常用户的请求，防止通过发送请求对程序进破坏。\n5.4.2 性能测试测试工具:Apifox v2.1.16，Jmeter 采用Apifox进行测试集接口自动化，根据不同测试环境和测试数据，生成压力测试报告进行局部调优 假设实际运行开发中 以最大流量的视频流为例 40线程数 RT平均耗时为1.2s 吞吐量为37.3&#x2F;min\n\n\n","categories":["技术","项目"],"tags":["后端","字节"]},{"title":"2024-07月记","url":"/2024-07-28/806f146494d1/","content":"今天是7月28日，日子正好挺特殊，入职刚好满一个月，正好记录一下这一个月的打工生活。主观感想方便比较多\n近期状况先简单列一下想聊的几个方面：公司、同事、工作、自身状态、北京、生活(衣食住行之类)\n自身状态首先是自身状态吧，入职前其实挺焦虑的，分三个方面：\n\n自己的眼睛太差了，不知道能不能接受互联网公司的强度\n自己是从go转java的，java的基础比较差，相关的代码写的也不多，不知道能不能干好\n不知道自己能不能和同事打好交道，希望自己不要表现的太内向\n\n这一个月待下来，感觉还是可以接受的，或者说比我想象中预期好太多了。\n\n首先是眼睛这块，字体调大些，平常眼睛累了就擦擦眼镜休息下，或者上个厕所，还算可以接受吧\n之后是转语言这里，没自己想象中那么困难，代码看多了慢慢就会了，并且刚接触的需求都是较为基础的，不需要太多的知识量，这段时间按照自己的节奏慢慢来就行，没啥好担心的\n最后是人际关系这里(其实一开始最担心的是这个，其次是眼睛)，比起之前实习的时候，这次不怎么紧张了，或者说更加自然了吧，不想太多正常交流就行\n\n有时认为很麻烦或者很难处理的事，其实到了面前会觉得也就那样\n之前焦虑的事，现在发现都没什么，有点松了口气，逐渐适应这个生活节奏了\n公司上班时间比我想象中久了些，但算是完全可以接受吧，或者说有种回到高中的感觉(作息听起来很累，但当时没觉得什么)？或许等我老了后会感慨“哇，我以前精力这么旺盛的吗”哈哈。\n公司带食堂确实太方便了，并且饭菜也较为可口，样式也挺丰富，还是挺喜欢的。\n连接AB座的玻璃桥，每次经过的时候总会往下望，很有意思\n电梯也还可以，不算太挤吧，可以接受，相比之下之前实习的公司等电梯太折磨了\n通勤也比较方便，公交车或者共享单车，现在买了个山地车，更没啥问题了，就是之后停车场要维护一段时间，雨天停车估计会麻烦些\n总体来说可以接受吧\n生活该怎么形容呢，逐渐走向正轨？比起在上海的那段时间，现在过的更加舒适吧，做对比的话就是一下几个方面：\n\n通勤\n上海租的那间，通勤较为麻烦，只能共享单车或者打车，并且早上共享单车经常没有，并且进入大夏天后再也不想骑车，就变成了天天打车的情况，开销很大\n北京租的这间，门口有公交站，旁边有一堆共享单车，并且自己还买了山地车，通勤很方便，并且距离比之前近了一公里\n\n\n屋子\n上海租的那间，六平米的小窝，住的比较憋屈吧，完全没有多余的活动空间\n北京租的这间，带独卫，早上没有人抢占卫生间，并且用洗衣机、淋浴都很方便(体验过之后已经不有些离不开独卫了，哈哈)。并且屋子比较大，买了个折叠柜，收拾完之后有很充足的空间，甚至现在有养猫的打算(房东已经同意了，就看自己啥时候下决心了)\n\n\n\n租的房子好坏与否 还是很重要的，很直观的决定了一个人的生活幸福指数\n贴一下屋子吧\n\n\n\n吃饭方面的话，稍微有些不方便，租的地方旁边没有饭店，只有个大马路，得骑车子去别的地方吃，或者直接点外卖，当然也可以直接去公司吃\n总结比较满意现在的生活吧，公司可以、同事很棒、租的房很合适、通勤方便，不过没啥时间打罪恶装备了，毕竟是格斗游戏，打起来手刚热就该睡觉了(挨了半天的揍，手感来了，要睡了orz)，还是发展些别的兴趣爱好吧\n展望希望能顺利通过试用期吧，踏踏实实的干，生活稳定之后养个猫猫🐱\n","categories":["生活","月记"],"tags":["月记"]},{"title":"2024-08月记","url":"/2024-09-08/55ae2675b830/","content":"拖了十天，终于来补了\n这个月发生的最大的事为养了个小祖宗，名曰“薄荷”\n\n这个月也在赚钱攒猫粮，请小祖宗放心😤\n6月22出生的（又多了个要记的纪念日），8月29日领回来的，目前养了十天，但是感悟还是挺多的\n现在回想起来，养猫这个决定做的有些随意，因为它会对自己的生活带来较大的变化，并且会持续十几年，可能当时应该再慎重考虑下（不过以我对猫猫的执念最终可能变成慎重考虑后养猫吧，哈哈）\n自己的生活中突然多了个要照顾的猫猫，做事前需要同时考虑它的情况，最近也正好在看漫画《真的要结婚吗》，总感觉处境有些相像，家庭成员变多的同时意味着自己需要一同成长，大多美好的事物后面都伴随着要承担的责任\n但是话说回来，一味地害怕未知的麻烦也是不行的，一直待在自己的舒适区当然可以，我以前也是这样干的，但当回忆往事时，总觉得自己的生活应该更加丰富一些\n以前（或者说包括现在），对于不太想做的事（或是出于麻烦，或是出于害怕），当出现一个说的过去的借口时，便会直接把它当成挡箭牌，并在心中觉得，毕竟xxx了，没办法，于是放弃了这个念头。\n就像博客主页的那句话：“丰富多彩的生活需要强大的执行力”，时间过的很快，我不希望自己回忆往事时会再次后悔，所以想趁着年轻，趁着现在肩上没有太大的担子，趁着自己还有一些学生的稚嫩，让自己的生活中出现一些波澜~\n\n工作方面的话正式走向正规，已经能慢慢处理了，下周会进行转正答辩，祝自己顺利\n\n下一步的计划，目前发现自己空闲时无所事事、浑浑噩噩占比较大，对打游戏有些提不起兴趣了，也没有什么其它爱好，于是决定买些推理小说看看，单是下了，但自己会不会好好看，喜不喜欢看 都还是未知数，等下个月回顾吧\n\n再晒几张\n\n\n\n","categories":["生活","月记"]},{"title":"2024-09月记","url":"/2024-10-12/eab561283843/","content":"这一个月最大的两件事：试用期转正答辩、出国旅游，旅游打算单独拆一篇出来，这里就简单写下答辩的事\n试用期转正答辩其实还挺怵的，实习时的转正答辩答的太差了\n之后总结反思了下那场答辩：\n\n准备不充分：明明自己知道HR会在场，却对HR常问问题一点准备没有，提问环节被问到了很多类似的问题，自己的临场发挥又很糟糕\n思考的角度不对：\n表达的不应该是自己做了什么，而是对方想听什么，准备时应该按照STAR原则来说，才能让HR更简介的了解自己的成绩\nSTAR原则：Situation（情景）、Task（任务）、Action（行动）和Result（结果）\n\n\n\n这次转正答辩时，提前准备了很多可能会问的问题，准备的比较充分（虽然一个都没被问到，但起码有个壮士气的作用，哈哈），这次问的问题偏向于具体业务，具体实现，自己临场答的也还可以吧\n最后同事提了个点，自己在紧张时会有很多口癖，不管是这次转正答辩还是上次知识分享。说真的，我一直没意识到这点，当时都不知道他指的是什么，直到回去看了这两场的录像，发现自己紧张时，或者不知道下面接什么时，口癖多的离谱，很影响体验\n（挑的是Prometheus的知识分享会，没有具体的业务内容，不会涉及到公司机密之类的）\n刚开始讲的时候口癖特别严重，可能是第一次在组内进行发言有些紧张，后续进状态后慢慢就少了\nexample1：嘛\n这个就是暴漏的指标嘛，格式的话比较同样，上面都要两行注释嘛….下面如果有多个标签，就是有多条数据嘛\nexample2：那个\n\nexample3：这个\n\nexample4：的话\n\n重新看一遍录播，找自己在答辩&#x2F;分享会上出现的问题还挺重要的，以后多总结多注意这方面吧，下次自己发言时刻意注意下这块\n总结下：\n\n会前要做好准备\n从听众的角度思考，考虑使用STAR原则\n日常生活中多注意，刻意减少口癖\n发言可以看录播复盘，兴许会发现些自己没注意到的问题\n\n","categories":["生活","月记"]},{"title":"20240817-外出(看电影)小记","url":"/2024-08-17/4b02c15f4a6d/","content":"电影评价周六日有些不知道做什么，游戏也不想打，身边的人也有事约不出来，听学弟说《异形-夺命舰》还可以，就去看了看\n毕竟是科幻恐怖类的，特地挑的晚上九点半看的，正常看下来还算可以，很常规的剧情但又有些小爽，并且还适当关联了下前几部，另外就是最后，以为还是第四部那种母子的桥段，结果并不是\n异形设计的怎么看都觉得有些小帅\n\n总结一下，我对它的评价是，剧情没什么亮点，很中规中矩但是比较爽的电影\n路途小记然后吐槽下去电影院过程中发生的一些事\n首先是出发的时，其实发现天气预报有说过段时间会下雨了，但是自己出发时间有些晚，还想在开播前买杯奶茶，怕赶不上，最后还是骑着山地车出发了，停车时找了个有棚子的地方\n看完电影后，好多人聚在狭小且昏暗的走廊，外面瓢泼大雨，时不时飘来几道闪电，还是在看完一部科幻恐怖片之后，这种感觉还是挺奇妙的，有些有趣\n\n\n打车回来倒也没问题，但是山地车是最近新买的，有些担心，所以就等了段时间，并且毕竟回去了也有些无聊，在这里吹吹风也不错\n过了段时间雨没那么大了就骑着回去了，但回去的路上没那么平淡，中间要过一个地下桥，地下桥被水淹了，好多汽车都停在外面不敢过去，我这个小小山地车就更加不知所措了\n\n问了下旁边的大哥，大哥说可以绕路，从旁边的桥上上去，推着车子慢慢走，再下来，但是上面车比较多，走的时候小心点。\n听完之后便打开高德开始看怎么上桥，定睛一看，好家伙，京沪高速！我说咋一堆大货车在上面飞速疾驰，合着是高速啊，果断放弃了这个方案。\n之后问了下路过的小哥，小哥说从右边那个小区进去，怎么怎么绕，之后抬上去，应该能过\n那个小区里面也是较为昏暗，里面七拐八拐的，道路也很狭小(可能其实是街道吧，也没太注意)，跟上面一样，感觉特别有氛围，可惜的是在那个小区绕了半天，也没能找到。\n便利店老板倒是告知了个路线，说是比较远但能过，便决定往那块走了。\n结果刚一出小区，发现工人拿着抽水泵已经把地下桥中的水抽干净了😂，最后还是走的桥下，走的时候发现桥旁边有个拦路的车杆，后面有个小道(在绿化带后面)，里面可以过桥，估计就是小哥说的那个地方，也确实算是在小区里面\n整个过程还是很有趣的，多出去逛逛挺不错的，算是不虚此行吧\n","categories":["生活","随笔"]},{"title":"与外界沟通","url":"/2024-06-24/026cc86f1a34/","content":"下面这篇文章写的十分主观，也是第一次写这种性质的随笔，算是对以前的自己做个小吐槽\n—————————分界线—————————\n我一直以来都过分在乎别人是怎么看我的，好多事做的都很小心，说话发消息前也会确认好多遍用词确保不会让对方反感。\n渐渐地养成了稍微内向些的性格，特别是和不熟悉的人接触时，做的任何事都会特别小心。\n当和别人混熟后，各种行为都会变得大胆起来，或者说放得开了吧。但这种性格肯定不合适，这个世界上大多数人只会见到几面，畏手畏脚下去 只会给别人一个内向的印象 然后被对方忘掉。\n曾经在B站实习时，杰哥说我性格太内向了，最好做做改变。\n我听到的第一反应其实是不甘心，想让大家知道其实我是一个十分闹腾的人，然而我在那里就算待了八个月，还是小心翼翼的，不敢放开。\n回到学校之后，我开始关注我和熟悉的人到底是怎么沟通的，吃饭时在聊什么，走路时在聊什么，但反而发现根本没什么规律，形容起来有些天马行空吧，想到什么话题就抛什么，就算抛出来大家没啥想法也会直接过去，比较重要的是，我们并非一直有话题，此时大家只是一起吃着饭一起散着步。\n再对比我在B站的情况，和同事吃饭时，总觉得应该说些什么，显得自己不那么内向，然后绞尽脑汁想着话题，说话也小心翼翼的，抛出话题没人回应后还多少有些苦恼。\n其实说错话也没什么的吧，大家根本不会在乎的，就像让我想“有谁哪个时间说错了什么话让我十分反感”，我这种十分敏感的人也只会想到一两次。随心所欲一些自己会轻松不少，没必要过分在乎别人对自己的看法，自己在别人那算不上什么的，我这种属于与空气斗智斗勇了，哈哈。\n在上海的那段时间没人陪着说话还是挺无聊的，有些憋坏了吧，之后向陌生人搭话越来越熟练了，像是出租车司机、便利店老板、群里的水友等等。\n最近几天和别人搭话，这些无心之举却给我生活添了不少帮助，像是\n\n和快递站的阿姨唠嗑，了解到这个小区的具体情况，以及生活上的小知识\n和宠物店老板询问门口猫猫的情况，了解到这个猫猫的故事\n群里帮群友答疑，被另一位学长发现，互加好友后畅谈一番，聊了之后的人生规划\n…等等\n\n这些看似无意义的简单的沟通，却多少对生活有些帮助，并且对比在上海的无聊自闭生活，这些对话也是给生活添了不少的色彩吧，至少我很喜欢这种无意义的沟通，和别人交流雀食是一件很有趣的事。\n28号入职，会遇到新的同事，遇到新的朋友，希望自己之后的生活能更加多彩吧。\n","categories":["生活","随笔"]},{"title":"做菜笔记","url":"/2024-06-24/d32a6df577a8/","content":"在外租房，不咋做饭，但想着还是记录下，尽量学一道记一道吧\n同租的室友做饭好香啊啊啊，不想天天吃外卖了\n基础\n炒鸡蛋🥚：多放油，要不会粘锅，多油+大火\n番茄炒蛋：先放蛋！油可以少些，放了蛋液后开搅，然后放🍅，做卤子就加点水滚滚\n\n菜类肉类\n炖鸡块：拿水焯一遍，油锅中放 姜 花椒 八角 ，放鸡块，放葱蒜，加水没过去，加生抽 老抽 料酒 盐 香叶，全放高压锅里，压一压\n\n","categories":["生活","随笔"]},{"title":"国庆日本独行旅游小记","url":"/2024-10-20/22a0b6fbf912/","content":"Why之前看邻居朋友圈，有点被他丰富的生活震撼到了，各种出国旅游 日本、新西兰、马来西亚…各种经历潜水、蹬雪山、跳伞…\n看完后觉得自己的生活是不是有些太单调了，是不是该趁着自己年轻多去体验下外面的世界\n吃饭时和同事聊天，同事问我国庆什么安排，我随口答到没啥安排，国内旅游哪都是人，看人也没啥意思，还不如去国外串串。之后一想，已经工作俩月了，也有些积蓄，干脆出国旅游见见世面吧\n8月27号和同事聊天产生的想法，29号去办理护照，以前总感觉出国是件遥不可及的事，没想到自己这么短时间就下了决定\n计划去日本旅游，因为自己平常会看些日本的动漫、漫画之类的，所以对那里有些感兴趣，接着就开始了自己的准备工作\n准备和朋友聊这件事情时，朋友表示巧了，他也打算去日本旅游，不过他是中秋去，时间不太一致。之后做旅游攻略时，也受到了朋友和邻居的一些帮助\n第一次出国 + 自己一个人 + 不会日语，还是有些担心的吧，所以在做攻略时比较慎重\n时间：10.1出发，无锡转机，10.2下午五点到大阪 —– 10.10凌晨两点东京出发，凌晨六点到北京，收拾下东西，上班去(没错，很特种兵)\n提前做的准备：\n\n办理护照、签证，注册日本入境QR码\n日本流量卡\n学习ICOCA交通卡办理攻略\n开通手机卡国际漫游\n兑换日元\n提前订旅馆\n新旧手机(想着带俩手机，和别人沟通使用翻译软件时会不会更方便些，其实没必要)\n充电转接头(其实没必要)\n硬币收纳套(挺有用的)\n充电宝(很必要)\n手机下载各种软件：订旅馆、地图、翻译、打滴\n目前只记得这些吧，之后想到了再补充…\n\n行程安排落地在大阪，返程在东京，计划两边都简单转转，但其实正常旅游攻略是关西转6-7天，关东转6-7天，我打算8天把两边都逛逛，注定是一场特种兵旅行\n特殊背景：\n\n10.2-10.6 大阪的旅馆(6号早上十点前需要退房)\n10.6-10.10 东京的旅馆(10号早上十点前需要退房)\n10.5 晚上 东京有场大烟花\n如果去看 需要5号早晨乘坐新干线出发\n在关西的时间只有2号一晚上，3 4号两天，可能关西逛不全\n大阪的旅馆亏一天，到了东京没地方住\n\n\n10.6 晚上 东京有场小烟花\n6号早上乘坐新干线来东京\n海灯祭看不到了\n关西能多逛一天\n\n\n10.5-10.6 晚上 台场公园举办海灯祭(在东京)\n\n初版旅游攻略：\n\n10.2 下午五点 到大阪，旅馆办入住，收拾行李，晚上简单逛逛心斋桥、道顿堀\n10.3 去京都，伏见稻荷大社 - 清水寺 - 二条城，回大阪简单逛逛\n10.4 去奈良，奈良公园 - 春日大社 - 若草山，回大阪简单转转\n10.5 弹性时间，方案多选一\n环球影城\n大阪城+温泉\n京都没转够的话再去京都看看\n去东京看花火大会\n\n\n10.5 IF\n没去东京看烟花：10.6 去东京，行李寄存地铁站，看花火大会，取行李回秋叶原，宾馆办理入住\n去了东京看烟花：10.6 早上逛东京，下午去台场公园逛，晚上看海灯祭\n\n\n10.7-10.9 秋叶原 下北泽 涉谷 新宿 歌舞伎町 东京塔 银座 台场公园\n\n到10.4时，觉得比起固定的景点，反而是体验日本的活动更加吸引我一些，于是5号出发去了东京\n实际旅游行程：\n\n10.2 下午五点 到大阪，旅馆办入住，收拾行李，晚上简单逛逛心斋桥、道顿堀\n10.3 去京都，清水寺 - 二条城，回大阪简单逛逛\n10.4 去奈良，伏见稻荷大社 - 奈良公园 - 若草山，回大阪简单转转\n10.5 乘坐新干线，去东京，看花火大会\n10.6 早上逛秋叶原，下午去台场公园，晚上看海灯祭\n10.7-10.9 秋叶原 下北泽 涉谷 新宿 歌舞伎町 东京塔 银座 台场公园\n\n具体行程明天补充吧\n关西Day1 大阪Day2 京都Day3 京都 + 奈良关东Day4 去东京 + 花火大会Day5 秋叶原 + 台场公园 + 海灯祭Day6 涉谷 + 下北泽Day7 新宿 + 东京铁塔Day8 收拾行李 + 逛秋叶原","categories":["生活","随笔"]},{"title":"Goland常用快捷键","url":"/2023-09-30/8ec2dc5165dc/","content":"Goland常用快捷键Mac、Win两套的快捷键不同还是有些难搞的，先重点记录下windows的\n参考文章\nGoland快捷键讲解\n\n编辑代码上下左右、前后end、翻页有可以用自带的，没有可以做以下映射：\n\nFn + H&#x2F;J&#x2F;K&#x2F;L  -&gt;  左&#x2F;下&#x2F;上&#x2F;右\nFn + I&#x2F;O      -&gt;  Home&#x2F;End \nFn + ;        -&gt;  page up&#x2F; page down\n\n简单移动\nCtrl+M 光标所在位置居中 \nCtrl+左&#x2F;右 移动到上&#x2F;下一个单词 \nCtrl+Home&#x2F;End 移动到文件首&#x2F;尾处 \nCtrl+上&#x2F;下 屏幕滑动但光标不动，配合Ctrl+m一起用\n\n跳转\nCtrl+Alt+右 前进【很常用】\nCtrl+Alt+左 后退【很常用】\nCtrl+B 前往声明或用法【常用】\nCtrl+Alt+B 转到实现 【常用】\nCtrl+[ 跳转到函数大括号开始 \nCtrl+] 跳转到函数大括号结束\nAlt+下&#x2F;上 下&#x2F;上一个方法\nCtrl+G 跳转到 [行:列]\nCtrl+E 跳转到最近使用的文件，也选到侧框，需要再确定，支持直接搜索\nCtrl+Tab 跳转到最近的文件，直接跳，与ctrl+e很像，但不用二次确定\nF2跳转到warning，F3跳转到error，但F3和我的Snipaste快捷键有些冲突\nF4跳转到源代码【很常用】\n\n还没弄明白这个插件是干啥的，之后再看看：\nacejump-lite:当我们要在屏幕上跳转时，如光标在屏幕低，要跳转到屏幕顶某处，就可以使用这个插件，我自定义为 Fn+m, 然后输入跳转的目标字符\nenter下一行&#x2F;上一行\nEnter 新建下一行并移动到下一行, 改变此行【常用】\nShift+Enter 新建下一行并移动到下一行（不改变此行)【常用】\nCtrl+Enter 拆分此行，鼠标不动，在行尾使用，可新建下一行并鼠标不动\nCtrl+Alt+Enter 新建上一行并到上一行\n\n代码更改【常用】\nShift+F6 重命名\nCtrl+R 替换\nCtrl+Shift+F 全局搜索\nCtrl+Shift+R 全局替换\nCtrl+D 重复当前行或选中文本\n\n文件代码\nCtrl+Alt+L 格式化代码【常用】\nCtrl+Alt+O 优化导入的类和包\nCtrl+S save\n\n选中\nCtrl+W 扩选代码【常用】 \nCtrl+Shift+W 撤销扩选\nCtrl+Shift+Space 智能提示【常用】\nAlt+J 选中相同变量，持续按，逐步选多个【没用过，但貌似有用】&#96;\nCtrl+Shift+C 复制当前的文件的路径【有用】\n\n打开&#x2F;执行对应操作Alt+F1：选择要打开的界面【常用】，重点记一下Ctrl+K git提交界面\nCtrl+Shift+Space 智能提示\nCtrl+Shift+A 打开操作搜索界面，快速执行对应的action\n\n要打开设置，就可以使用键后，输入 settings 即可 \n要打开插件，输入 plugins, \n要把主菜单关掉，可以输入 main ,第一个就是\n要删除文件，可以对着文件输入 delete \n要新建文件，可以输入 go\n要新建项目，可以输入 project\n要 运行代码，可以输入 run \n等等\n\n总之这个键可以代替大多数需要移动鼠标才能做的，要达到无鼠标编程，这个键需要熟练使用\n按两次shift后会出现：所有、类型、文件、符号、操作、Git，可以Alt+左&#x2F;右切换\n\n双Shift 所有【常用】\nCtrl+N 类型\nCtrl+Shift+N 文件【常用】\nCtrl+Shift+Alt+N 符号(函数)\nCtrl+Shift+A 操作【常用】\n\n实际上记住 双shift &#x3D;&#x3D;&gt; Alt+方向 切换即可\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go单飞详解(singleflight)","url":"/2023-08-11/db9d47ddaded/","content":"应用场景singleflight 包提供了一种阻止重复函数调用的机制，主要用在缓存击穿的情况下\n某些热点数据的缓存过期或突然失效时，如果有大量的请求访问该数据，在数据写回到缓存前，这些请求都会统一打到DB上，可能会把DB压垮。\n一般的方案有：\n\n确保热点key不过期\n热点数据读DB写入到缓存时，加个分布式锁\n\n当然还有一种方式，与2类似，就是sync下的singleflight，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果。\n使用singleflight.Group类型提供了三个方法：\nfunc (g *Group) Do(key string, fn func() (interface&#123;&#125;, error)) (v interface&#123;&#125;, err error, shared bool)func (g *Group) DoChan(key string, fn func() (interface&#123;&#125;, error)) &lt;-chan Resultfunc (g *Group) Forget(key string)\n\n\nDo方法\n接受一个字符串Key和一个待调用的函数，会返回调用函数的结果和错误。\n使用Do方法的时候，它会根据提供的Key判断是否去真正调用fn函数。\n同一个 key，在同一时间只有第一次调用Do方法时才会去执行fn函数，其他并发的请求会等待调用的执行结果。\n\n\nDoChan方法：\n类似Do方法，只不过是一个异步调用。\n它会返回一个通道，等fn函数执行完，产生了结果以后，就能从这个 chan 中接收这个结果。\n\n\nForget方法：\n在SingleFlight中删除一个Key。\n这样一来，之后这个Key的Do方法调用会执行fn函数，而不是等待前一个未完成的fn 函数的结果。\n\n\n\n下面看个简单示例：\npackage mainimport (    &quot;fmt&quot;    &quot;golang.org/x/sync/singleflight&quot;    &quot;log&quot;    &quot;sync&quot;)var gsf singleflight.Groupfunc main() &#123;    var wg sync.WaitGroup    wg.Add(10)    for i := 0; i &lt; 10; i++ &#123;        go func() &#123;            defer wg.Done()            // v 获取到的值，err 返回的error，shared 结果是否被共享            v, err, shared := gsf.Do(&quot;key&quot;, getNum)            if err != nil &#123;                log.Print(err)                return            &#125;            fmt.Printf(&quot;获得结果：%v，是否被共享：%v\\n&quot;, v, shared)        &#125;()    &#125;    wg.Wait()&#125;func getNum() (interface&#123;&#125;, error) &#123;    fmt.Println(&quot;我被执行了，获取结果10&quot;)    return 10, nil&#125;/*output:\t我被执行了，获取结果10\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true\t获得结果：10，是否被共享：true*/\n\n可以发现getNum只被执行了一次，其他请求则是复用第一次请求的结果。\n重点注意：单飞的fn函数执行完之后，就会把该key删除，之后再有相同的key时会再调一遍，可以参考下面的代码：\nfunc main() &#123;    var wg sync.WaitGroup    wg.Add(10)    for i := 0; i &lt; 10; i++ &#123;        if i == 3 &#123;            time.Sleep(time.Second * 3)        &#125;        go func() &#123;            defer wg.Done()            // v 获取到的值，err 返回的error，shared 结果是否被共享            v, err, shared := gsf.Do(&quot;key&quot;, getNum)            if err != nil &#123;                log.Print(err)                return            &#125;            fmt.Printf(&quot;获得结果：%v，是否被共享：%v\\n&quot;, v, shared)        &#125;()    &#125;    wg.Wait()&#125;func getNum() (interface&#123;&#125;, error) &#123;    fmt.Println(&quot;我被执行了，获取结果10&quot;)    time.Sleep(time.Second * 2)    return 10, nil&#125;/*    我被执行了，获取结果10    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    我被执行了，获取结果10    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true    获得结果：10，是否被共享：true*/\n\n可以看到，getNum被调用了两次\n源码type Group struct &#123;    mu sync.Mutex    m  map[string]*call&#125;type call struct &#123;    wg sync.WaitGroup    // 这些字段在WaitGroup完成之前被写入一次，并且仅在WaitGroup完成之后被读取    val interface&#123;&#125;    err error        // 以前有个forgotten bool，但0.3.0版本是没有了的        // 只用在Shared = c.dups &gt; 0，判断是否共享    dups  int    chans []chan&lt;- Result&#125;type Result struct &#123;    Val    interface&#123;&#125;    Err    error    Shared bool&#125;\n\nsingleflight.Group由一个互斥锁sync.Mutex和一个映射表组成，每一个singleflight.call结构体都保存了当前调用对应的信息\nfunc (g *Group) Do(key string, fn func() (interface&#123;&#125;, error)) (v interface&#123;&#125;, err error, shared bool) &#123;    g.mu.Lock()    if g.m == nil &#123;        g.m = make(map[string]*call)    &#125;    if c, ok := g.m[key]; ok &#123;        c.dups++        g.mu.Unlock()        // 等待fn运行完        c.wg.Wait()        // 检测是fn造成panic，还是内部runtime.Goexit        if e, ok := c.err.(*panicError); ok &#123;            panic(e)        &#125; else if c.err == errGoexit &#123;            runtime.Goexit()        &#125;        return c.val, c.err, true    &#125;    c := new(call)    c.wg.Add(1)    g.m[key] = c    g.mu.Unlock()    g.doCall(c, key, fn)    return c.val, c.err, c.dups &gt; 0&#125;func (g *Group) Forget(key string) &#123;    g.mu.Lock()    delete(g.m, key)    g.mu.Unlock()&#125;\n\n先加锁，判断g.m[key]是否存在，不存在则c.wg.Add并执行fn，存在则c.wg.Wait完成后处理结果。\n其中Forget方法只是删除了g.m中的key，所以在此之前：正在调用fn的请求还是会执行，c.wg.Wait的请求也会获得fn的结果\n// doCall handles the single call for a key.func (g *Group) doCall(c *call, key string, fn func() (interface&#123;&#125;, error)) &#123;    // 判断是否正常退出fn函数    normalReturn := false    // 判断函数中是否panic    recovered := false    // use double-defer to distinguish panic from runtime.Goexit,    // more details see https://golang.org/cl/134395    // 两个defer去判断是fn内部panic还是runtime.Goexit    defer func() &#123;        // the given function invoked runtime.Goexit        // fn没有正常退出，且recovered仍为false        // 说明没走到最下面的 if !normalReturn 判断，认为发生了runtime.Goexit        if !normalReturn &amp;&amp; !recovered &#123;            c.err = errGoexit        &#125;        g.mu.Lock()        defer g.mu.Unlock()        c.wg.Done()        // 删除该key，下次执行时遇到该key重新调fn去        if g.m[key] == c &#123;            delete(g.m, key)        &#125;        if e, ok := c.err.(*panicError); ok &#123;            // In order to prevent the waiting channels from being blocked forever,            // needs to ensure that this panic cannot be recovered.            if len(c.chans) &gt; 0 &#123;                go panic(e)                select &#123;&#125; // Keep this goroutine around so that it will appear in the crash dump.            &#125; else &#123;                panic(e)            &#125;        &#125; else if c.err == errGoexit &#123;            // Already in the process of goexit, no need to call again        &#125; else &#123;            // Normal return            // 写到ch中，DoChan方法调用的话会用到            for _, ch := range c.chans &#123;                ch &lt;- Result&#123;c.val, c.err, c.dups &gt; 0&#125;            &#125;        &#125;    &#125;()    func() &#123;        defer func() &#123;            if !normalReturn &#123;                // Ideally, we would wait to take a stack trace until we&#x27;ve determined                // whether this is a panic or a runtime.Goexit.                //                // Unfortunately, the only way we can distinguish the two is to see                // whether the recover stopped the goroutine from terminating, and by                // the time we know that, the part of the stack trace relevant to the                // panic has been discarded.                if r := recover(); r != nil &#123;                    c.err = newPanicError(r)                &#125;            &#125;        &#125;()        c.val, c.err = fn()        normalReturn = true    &#125;()    if !normalReturn &#123;        recovered = true    &#125;&#125;// 与Do类似，不再赘述func (g *Group) DoChan(key string, fn func() (interface&#123;&#125;, error)) &lt;-chan Result &#123;    ch := make(chan Result, 1)    g.mu.Lock()    if g.m == nil &#123;        g.m = make(map[string]*call)    &#125;    if c, ok := g.m[key]; ok &#123;        c.dups++        c.chans = append(c.chans, ch)        g.mu.Unlock()        return ch    &#125;    c := &amp;call&#123;chans: []chan&lt;- Result&#123;ch&#125;&#125;    c.wg.Add(1)    g.m[key] = c    g.mu.Unlock()        go g.doCall(c, key, fn)    return ch&#125;\n\nsingleflight存在的问题\n一人超时，全员超时\n一人错，全员错\nsingleflight是一把大锁，在高并发时锁冲突严重，故需要针对性的做些优化\nsingleflight不携带context，缺少一些控制机制\n\n参考文章\ngolang防缓存击穿神器【singleflight】\nGo缓存击穿方案-singleflight源码解读\ngo-pkg\n\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go错误处理规范化","url":"/2023-05-28/5404a6638fea/","content":"参考kuriball大佬公司内的文档\n处理方式目前在进行一个业务的错误处理优化，方便后续快速定位问题。\n错误处理不当主要体现在以下方面：\n\n没有打印堆栈信息，定位问题困难\n重复携带堆栈信息，冗余\n一个error打印多次（例如每一层都打印）\n\n首先看几个和 日志 &#x2F; error 相关的库\n\nerrors标准库\ngithub.com&#x2F;pkg&#x2F;errors （下文直接称为pkg-errors）\n公司内部 ecode（error code）\n公司内部 log\n\n堆栈信息是排查问题的一个重要手段，例如：\npackage mainimport (\t&quot;fmt&quot;\t&quot;github.com/pkg/errors&quot;)func main() &#123;\terr := errors.New(&quot;whoops&quot;)\tfmt.Printf(&quot;%+v&quot;, err)\t// Example output:\t// whoops\t// github.com/pkg/errors_test.ExampleNew_printf\t//         /home/dfc/src/github.com/pkg/errors/example_test.go:17\t// testing.runExample\t//         /home/dfc/go/src/testing/example.go:114\t// testing.RunExamples\t//         /home/dfc/go/src/testing/example.go:38\t// testing.(*M).Run\t//         /home/dfc/go/src/testing/testing.go:744\t// main.main\t//         /github.com/pkg/errors/_test/_testmain.go:106\t// runtime.main\t//         /home/dfc/go/src/runtime/proc.go:183\t// runtime.goexit\t//         /home/dfc/go/src/runtime/asm_amd64.s:2059&#125;\n\n需要注意格式化输出error时，%v只会输出错误文本，stack\n根据堆栈信息我们可以快速定位到日志位置和调用链路\n不携带堆栈信息方法：\n\nerrors标准库 - errors.New\npkg-errors - errors.WithMessage\n公司内部的 ecode 创建error\n\n携带堆栈信息的方法：\n\npkg-errors 的 errors.New\npkg-errors &#x2F; errors - errors.Wrap\npkg-errors - errors.WithStack\n\n直接看源码即可，注释也很详细\n公司内部在web框架中加入了中间件，会统一打印日志，推荐先把中间件的代码过一下，会更清楚整个流程\n错误打印原则：\n\n最底层(比如公共库)返回原始错误, 无需wrap\n应用下层流转错误, 使用wrap带上堆栈\n应用内方法互相调用, 避免重复wrap导致重复堆栈, WithMessage携带信息即可\n\n公共库返回的error是否携带堆栈信息？可以看下源码，例如json.Marshal\nfunc Marshal(v any) ([]byte, error) &#123;\te := newEncodeState()\tdefer encodeStatePool.Put(e)\terr := e.marshal(v, encOpts&#123;escapeHTML: true&#125;)\tif err != nil &#123;\t\treturn nil, err\t&#125;\tbuf := append([]byte(nil), e.Bytes()...)\treturn buf, nil&#125;......// jsonError is an error wrapper type for internal use only.// Panics with errors are wrapped in jsonError so that the top-level recover// can distinguish intentional panics from this package.type jsonError struct&#123; error &#125;func (e *encodeState) marshal(v any, opts encOpts) (err error) &#123;\tdefer func() &#123;\t\tif r := recover(); r != nil &#123;\t\t\tif je, ok := r.(jsonError); ok &#123;\t\t\t\terr = je.error\t\t\t&#125; else &#123;\t\t\t\tpanic(r)\t\t\t&#125;\t\t&#125;\t&#125;()\te.reflectValue(reflect.ValueOf(v), opts)\treturn nil&#125;\n\n先不去处理错误，发生panic后recover，从里面提取原因并转换为jsonError，一般发生panic后会程序崩溃会输出堆栈信息，但recover中只能获得报错信息，想要获取堆栈信息可以通过debug.Stack()，例如下面的代码：\npackage mainimport (\t&quot;fmt&quot;\t&quot;runtime/debug&quot;)func main() &#123;\tdefer func() &#123;\t\tif r := recover(); r != nil &#123;\t\t\tfmt.Printf(&quot;panic: %s\\nstack trace:\\n%s&quot;, r, debug.Stack())\t\t&#125;\t&#125;()\tfoo()&#125;func foo() &#123;\tpanic(&quot;oh foo&quot;)&#125;/* output:panic: oh foostack trace:goroutine 1 [running]:runtime/debug.Stack()\t/usr/local/go-faketime/src/runtime/debug/stack.go:24 +0x65main.main.func1()\t/tmp/sandbox1024588529/prog.go:11 +0x39panic(&#123;0x48a440, 0x4b83c8&#125;)\t/usr/local/go-faketime/src/runtime/panic.go:884 +0x213main.foo(...)\t/tmp/sandbox1024588529/prog.go:18main.main()\t/tmp/sandbox1024588529/prog.go:14 +0x4a*/\n\n所以json.Marshal函数是不会输出堆栈信息，如果出现error了需要Wrap或者WithStack一下\nwrap 或 WithMessage 后会不会影响到ecode对于前端的提示？前端能够正确展示对应的提示是基于返回的ecode中的code和message, 前端展示message信息。\n\nwrap之前: 应用返回原始error(即为根因error), 如果该error为ecode, 拥有对应的code和message, 则前端能正常展示, 否则则不能\nwrap之后: 应用层通用返回原始error(即为根因error), wrap加上堆栈, 出口处框架会自动cause寻找根因, 之后和wrap之前逻辑一致也就是说, 重点在于返回的原始error是否为ecode才是重点, 与是否wrap没有关系\n\n例如：\n// 方式一if err != nil &#123;\tlog.Errorc(c, &quot;AddQASnapshot addQASnapshotDB error(%v) oid(%s)&quot;, err, req.Oid)\terr = qaEcode.QASnapshotAddErr&#125;// 方式二if err != nil &#123;\terr = errors.WithMessagef(qaEcode.QASnapshotAddErr, &quot;AddQASnapshot addQASnapshotDB oid(%s), error:%v&quot;, err, req.Oid)&#125;\n\n两种方法都可以，方式一中，先将系统内的错误打印出来方便程序员问题定位，然后通过ecode替换为对应error，为用户展示错误信息。方式二是将qaEcode.QASnapshotAddErr作为原始error，将错误信息加到msg中，最后通过中间件统一打印。\n举个例子更加直观一些：\npackage mainimport (\t&quot;fmt&quot;\t&quot;github.com/pkg/errors&quot;)func main() &#123;\terr := errors.New(&quot;这是个err&quot;)\terr2 := errors.New(&quot;这是个err2&quot;)\terr3 := errors.WithMessagef(err, &quot;err2:%+v&quot;, err2)\tfmt.Printf(&quot;%+v\\n&quot;, err3)\tfmt.Println(&quot;errors.Cause:&quot;, errors.Cause(err3))&#125;/* output:这是个errmain.main\t/tmp/sandbox4241311282/prog.go:9runtime.main\t/usr/local/go-faketime/src/runtime/proc.go:250runtime.goexit\t/usr/local/go-faketime/src/runtime/asm_amd64.s:1598err2:这是个err2main.main\t/tmp/sandbox4241311282/prog.go:10runtime.main\t/usr/local/go-faketime/src/runtime/proc.go:250runtime.goexit\t/usr/local/go-faketime/src/runtime/asm_amd64.s:1598errors.Cause: 这是个err*/","categories":["技术","语言","golang"],"tags":["后端","业务"]},{"title":"Go项目-持续部署-阿里云服务器","url":"/2023-11-15/66090ced97fe/","content":"CI&#x2F;CD 这块自己一直都是一知半解的，最近有个七牛云的比赛，持续部署做的比较敷衍，webhooks + hookdoo，目前赛后复盘，把这块恶补一下\n基本概念参考文章：持续集成、持续交付、持续部署 基本概念\n\nCI 持续集成（Continuous Integration）\nCD 持续交付（Continuous Delivery）\nCD 持续部署（Continuous Deployment）\n\n持续集成\n\n持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。\n持续集成 (CI) 是一种需要频繁提交代码到共享仓库的软件实践。 频繁提交代码能较早检测到错误，减少在查找错误来源时开发者需要调试的代码量。 频繁的代码更新也更便于从软件开发团队的不同成员合并更改。 这对开发者非常有益，他们可以将更多时间用于编写代码，而减少在调试错误或解决合并冲突上所花的时间。\n提交代码到仓库时，可以持续创建并测试代码，以确保提交未引入错误。 您的测试可以包括代码语法检查（检查样式格式）、安全性检查、代码覆盖率、功能测试及其他自定义检查。\n持续交付\n\n持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。\n持续部署\n\n持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。\n总结一下：持续集成是构建测试代码并检测与源代码是否存在冲突，持续交付是交付给QA，持续部署是尽快部署生产\n持续部署-实战练习用最近做的七牛云1024比赛项目来练习吧，一个 Golang 后端项目，持续交付不需要做，持续集成参考 GitHub Action 的文档即可，在此简单看下持续部署\n我们想把代码部署到阿里云服务器上，步骤如下：\n\nGitHub Action构建项目\n将构建好的二进制文件传到阿里云服务器\n服务器直接运行二进制文件\n\n首先，在 GitHub secrets 中配置阿里云服务器登录信息\n\n然后开始编写 workflow 配置文件，我们可以直接选用 GitHub Actions 中的模板\n\n基础的语法参考 GitHub Actions 的文档，我们想要部署到自己的服务器，需要用到 easingthemes&#x2F;ssh-deploy 和  appleboy&#x2F;ssh-action，前者是将文件通过 scp 命令传入，后者是直接执行命令\n# This workflow will build a golang project# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-goname: Goon:  push:    branches: [ &quot;master&quot; ]# 持续部署时只跑主分支上的master，PR不用管#  pull_request:#    branches: [ &quot;master&quot; ]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v3      - name: Set up Go        uses: actions/setup-go@v4        with:          go-version: &#x27;1.21&#x27;      - name: Build        run: CGO_ENABLED=0 go build -o server      - name: Sent to ALIYUN        uses: easingthemes/ssh-deploy@main        env:          #私钥          SSH_PRIVATE_KEY: $&#123;&#123; secrets.ALIYUN_SERVER_PRIVATE_KEY &#125;&#125;          #scp参数          ARGS: &quot;-rltgoDzvO --delete&quot;          #源目录          SOURCE: &quot;./server ./cmd/run.sh&quot;          #服务器IP          REMOTE_HOST:  $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125;          #用户          REMOTE_USER: $&#123;&#123; secrets.ALIYUN_SERVER_REMOTE_USER &#125;&#125;          #目标地址          TARGET: &quot;/root/utopia-back&quot;      - name: Deploy on ALIYUN        uses: appleboy/ssh-action@master        with:          host:  $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125;          username: $&#123;&#123; secrets.ALIYUN_SERVER_REMOTE_USER &#125;&#125;          password: $&#123;&#123; secrets.ALIYUN_SERVER_PWD &#125;&#125;          debug: true          script: |            cd /root/utopia-back            chmod +x ./run.sh            ./run.sh\n\n编译时尽量使用静态编译（CGO_ENABLED=0），保证服务器不用配置额外环境，可直接运行\nscp 命令用到的参数如下：\n\n-r: 递归复制整个目录结构，包括子目录和文件\n-l: 保持源文件和目标文件的链接关系\n-t: 在远程服务器上创建与源目录相同的目录结构\n-g: 保持文件的原始属性，包括所有者、组和权限\n-o: 保持源文件的时间戳\n-D: 启用调试模式，在传输过程中显示调试信息\n-z: 在传输过程中启用压缩，以减少数据传输的大小\n-v: 显示详细的传输信息，包括每个文件的名称和传输进度\n-O: 保持源文件的所有者和组\n--delete: 删除远程目标目录中存在但源目录中不存在的文件\n\n./cmd/run.sh内容如下：\n#!/bin/bash# 检查8080端口的占用情况port=8080pid=$(lsof -t -i:$port)if [ -z &quot;$pid&quot; ]; then  echo &quot;端口 $port 没有被占用。&quot;else  echo &quot;端口 $port 被进程 $pid 占用。&quot;  # 终止占用8080端口的进程  echo &quot;终止进程 $pid ...&quot;  kill $pidfiecho &quot;开始启动Go程序...&quot;nohup ./server &gt; output.log 2&gt;&amp;1 &amp;sleep 2 # 等待一段时间以确保程序已经启动pid=$!if [ -n &quot;$(ps -p $pid -o pid=)&quot; ]; then  echo &quot;Go程序已成功启动。&quot;  exit 0else  echo &quot;Go程序启动失败，请检查错误信息。&quot;  exit 1fi\n\n另外关于端口，可以在appleboy/ssh-action里指定，通过参数的形式写进run.sh\n现在当我们提交后，观察Github Actions，发现流程正常通过，且程序正常部署\n\n\n当然，上面实现的是比较繁琐的，直接用docker会好很多，以后有时间了补一下\n\nWebhooks 实现\n当然，我们也可以通过 Webhooks 来实现部署，简单来说当我们进行相应操作后，Github 会向我们配置的 url 发起 POST 请求，服务器上编写相应的接口，收到请求后进行相应处理即可。例如，先通过 Github Actions 将构建好的文件 scp 到自己的服务器上，收到 POST 请求后再进行对应的处理。\n如果比较懒的话，可以去看下 hookdoo(Hooks to automate webhooks)，这个使用较为简单，在此不多赘述\n当然，也可以通过 Github Actions 触发 Webhooks，这样就不用去想二者先后顺序之类的了\n可参考文章：GitHub Actions 和 Webhooks 的触发\n","categories":["技术","语言","golang"],"tags":["后端","go"]},{"title":"go mod踩坑记录","url":"/2023-03-23/a37d39c5ded9/","content":"公司的go语言版本较低，我自己使用的是go1.20，刚入职后 go mod tidy 了一下，按理说不会有什么问题，本地运行也可以，但后来发现构建平台构建失败，提示请使用高版本的Go。\n另外公司采用的是大仓模式，所有B端的代码统一放在一个仓库中，微服务架构，就导致别的部门构建镜像时使用的版本较低，就会构建失败。\n那么为什么go.mod中标明了版本，使用高版本go mod tidy后会出问题呢？\n按理说如果在go.mod中标明版本为1.13，go mod tidy后只会选择 Go 1.13 版本兼容的依赖项，一般是不会出问题的。但是下面的库比较特殊：golang.org/x/net v0.6.0\ngo 1.13确实可以使用这个库，但如果用到了里面的http2部分就不太行了，因为http2依赖了io&#x2F;fs，所以必须1.16及以上才能用，但是go mod把它直接按1.13可以使用处理了。\n综上，go mod有时候确实不太灵光，如果不想背锅的话，可以直接go mod download\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go 切片踩坑整合","url":"/2022-12-14/f91851a4bd1d/","content":"又踩个坑，正好把之前那个整理到一块\n2022&#x2F;12&#x2F;15\n刷这道题的时候113. 路径总和 II，大体来说就是先定义了一个二维切片，dfs闭包遍历，切片path代表当前的路径，如果路径符合，`result &#x3D; append(result,path)`，但是后来发现因为path的值会改变，导致result的值会跟着改变，毕竟result的底层数组装的是[]int结构体。\n有什么解决办法呢？\n// 原来的result = append(result, append(path))// 正确的（好家伙，一直没想到）result = append(result, append([]int(nil), path...))\n\n2022&#x2F;07&#x2F;09\n今日刷力扣，写一个二叉树的前序遍历代码如下：\npackage BiTreetype TreeNode struct &#123;    Val   int    Left  *TreeNode    Right *TreeNode&#125;func preorderTraversal(root *TreeNode) []int &#123;    var result []int    traversal(root, result)    return result&#125;func traversal(node *TreeNode, result []int) &#123;    if node == nil &#123;        return    &#125;    result = append(result, node.Val)    traversal(node.Left, result)    traversal(node.Right, result)&#125;\n\ngo的传递方式只有值传递一种，但切片是引用类型，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n但是本题力扣上运行时输出结果却为[]（正确输出：1 2 3），便引起了笔者的思考\n首先打印result前后的地址\nfunc preorderTraversal(root *TreeNode) []int &#123;    var result []int    fmt.Printf(&quot;初始地址：%p\\n&quot;, result)    traversal(root, result)    fmt.Printf(&quot;返回的地址：%p\\n&quot;, result)    return result&#125;func traversal(node *TreeNode, result []int) &#123;    fmt.Printf(&quot;传入函数的地址为：%p\\n&quot;, result)    if node == nil &#123;        return    &#125;    result = append(result, node.Val)    fmt.Println(result)    fmt.Printf(&quot;append后的地址为：%p\\n&quot;, result)    traversal(node.Left, result)    traversal(node.Right, result)&#125;\n\n初始地址：0x0传入函数的地址为：0x0[1]append后的地址为：0xc0000140a0传入函数的地址为：0xc0000140a0传入函数的地址为：0xc0000140a0[1 2]append后的地址为：0xc0000140b0传入函数的地址为：0xc0000140b0[1 2 3]append后的地址为：0xc000074020传入函数的地址为：0xc000074020传入函数的地址为：0xc000074020传入函数的地址为：0xc0000140b0返回的地址：0x0\n\n从第二行可以看出传递的确实是指针，在递归的时候result的值确实再改变，而值得我们注意的是append前后地址的变化。\n当切片需要扩容时会创建新的数组，这会导致和原有切片的分离，也就是说现在改变的切片已经不再是原来的地址了，但是append时我们将它重新赋给了result，所以traversal函数内的result始终指向正确的地址，而preorderTraversal中的result仍时原来的地址，所以最终的结果为[]，关于切片的底层实现详见链接。\n解决方法：\n第一种是traversal中返回result\nfunc preorderTraversal(root *TreeNode) []int &#123;    var result []int    result = traversal(root, result)    return result&#125;func traversal(node *TreeNode,result []int) []int &#123;    if node == nil &#123;        return result    &#125;    result = append(result, node.Val)    result = traversal(node.Left, result)    result = traversal(node.Right, result)    return result&#125;\n\n第二种为力扣给出的题解\nfunc preorderTraversal(root *TreeNode) (vals []int) &#123;    var preorder func(*TreeNode)    preorder = func(node *TreeNode) &#123;        if node == nil &#123;            return        &#125;        vals = append(vals, node.Val)        preorder(node.Left)        preorder(node.Right)    &#125;    preorder(root)    return&#125;","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go 学习笔记 [结构与变量]","url":"/2022-04-30/fecff6ee57be/","content":"Go 学习笔记 [结构与变量]语言结构Go Hello World 实例Go 语言的基础组成有以下几个部分：\n\n包声明\n引入包\n函数\n变量\n语句 &amp; 表达式\n注释\n\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 这是我的第一个简单的程序 */   fmt.Println(&quot;Hello, World!&quot;)&#125;\n\n\n包名必须在源文件中非注释的第一行指明这个文件属于哪个包，（如：package main）。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n引入包import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入&#x2F;输出）的函数。\n函数func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。\n\n当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的。\n语言变量声明变量的一般形式是使用 var 关键字：\nvar identifier type\n变量声明\n指定变量类型，声明后若不赋值，使用默认值。\n\nvar v_name v_typev_name = value\n\n\n根据值自行判定变量类型。\n\nvar v_name = value\n\n省略var，注意 :&#x3D;左侧的变量不应该是已经声明过的，否则会导致编译错误。\n\n使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。\nv_name := value// 例如var a int = 10var b = 10c := 10\n\n实例如下：\npackage mainvar a = &quot;w3cschoolW3Cschool教程&quot;var b string = &quot;w3cschool.cn&quot;var c boolfunc main()&#123;    println(a, b, c)&#125;\n\n多变量声明// 类型相同多个变量，非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3//和python很像,不需要显示声明类型，自动推断var vname1, vname2, vname3 = v1, v2, v3// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误vname1, vname2, vname3 := v1, v2, v3// 类型不同多个变量，全局变量,注：局部变量不能使用这种方式var (    vname1 v_type1    vname2 v_type2)\n\n值类型和引用类型所有像 int、float、bool 和 string 这些基本类型都属于值类型\nj &#x3D; i，实际上是在内存中将 i 的值进行了拷贝\n注意事项\n如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，但是 a &#x3D; 20 是可以的，因为这是给相同的变量赋予一个新的值。\n如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。\n如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误a declared but not used\n但是全局变量是允许声明但不使用\n\ntips如果想要交换两个变量的值，则可以简单地使用 a, b &#x3D; b, a。\n空白标识符 _ 也被用于抛弃值，如值 5 在：_, b &#x3D; 5, 7 中被抛弃。\n_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。\n并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err &#x3D; Func1(var1)。\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"go-设计模式-精简版-创建型模式","url":"/2023-01-31/ec8431a169b7/","content":"前言整理自刘丹冰老师的《Easy 搞定 Golang设计模式》\n说是整理，到最后发现基本都是文章中的内容:p\nGo中的组合与继承参考文章：go继承\ngo中没有继承，只能通过组合来实现继承\n继承就是子类继承了父类的特征和行为，使得子类实例具有父类的行为和方法组合就是通过对现有对象的拼装从而获得实现更为复杂的行为的方法\n\n一个struct嵌套了另外一个匿名的struct从而实现了继承，嵌套多个匿名struct实现多重继承。\n一个struct嵌套了另外一个struct的实例实现了组合。\n\n示例出处：go结构体的“继承”\n//Animal 动物type Animal struct &#123;    name string&#125;func (a *Animal) move() &#123;    fmt.Printf(&quot;%s会动！\\n&quot;, a.name)&#125;//Dog 狗type Dog struct &#123;    Feet    int8    *Animal //通过嵌套匿名结构体实现继承&#125;func (d *Dog) wang() &#123;    fmt.Printf(&quot;%s会汪汪汪~\\n&quot;, d.name)&#125;func main() &#123;    d1 := &amp;Dog&#123;        Feet: 4,        Animal: &amp;Animal&#123; //注意嵌套的是结构体指针            name: &quot;乐乐&quot;,        &#125;,    &#125;    d1.wang() //乐乐会汪汪汪~    d1.move() //乐乐会动！&#125;\n\n\ngo继承是通过嵌套匿名struct实现继承。\ngo继承在本质上还是组合。\n子类要调用父类的实现可以通过调用组合中的父类对象的方法。\n多重继承中不允许多个父类出现相同的方法。(编译不通过)\n\n设计模式概述设计模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。\nGoF给软件设计模式提供了定义，如下：“软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。”一句大白话可以总结：“在一定环境下，用固定套路解决问题。”\nGoF提出的设计模式有23个，包括：\n\n创建型(Creational)模式：如何创建对象；\n结构型(Structural )模式：如何实现类或对象的组合；\n行为型(Behavioral)模式：类或对象怎样交互以及怎样分配职责。\n\n有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式书籍都会对它进行专门的介绍。设计模式目前种类： GoF的23种   + “简单工厂模式” &#x3D; 24种。\n学习设计模式的作用：\n\n如何将代码分散在几个不同的类中？\n为什么要有“接口”？\n何谓针对抽象编程？\n何时不应该使用继承？\n如果不修改源代码增加新功能？\n更好地阅读和理解现有类库与其他系统中的源代码。\n\n设计模式的基础是：多态。\nhttps://www.yuque.com/aceld/lfhu8y/pebesh?inner=qSWMX\n\n\n\n\n面向对象设计原则对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。\n面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。\n原则的目的： 高内聚，低耦合\n\n\n\n名称\n定义\n\n\n\n单一职责原则 (Single Responsibility Principle, SRP) ★★★★☆\n类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。\n\n\n开闭原则 (Open-Closed Principle, OCP) ★★★★★\n类的改动是通过增加代码进行的，而不是修改源代码。（对扩展开放，对修改封闭）\n\n\n里氏代换原则 (Liskov Substitution Principle, LSP ★★★★★\n任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。\n\n\n依赖倒转原则 (Dependence  Inversion Principle, DIP) ★★★★★\n依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。\n\n\n接口隔离原则 (Interface Segregation Principle, ISP ★★☆☆☆\n不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。\n\n\n合成复用原则 (Composite Reuse Principle, CRP) ★★★★☆\n如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。\n\n\n迪米特法则 (Law of Demeter, LoD ★★★☆☆\n一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）\n\n\n单一职责原则类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。\npackage mainimport &quot;fmt&quot;type ClothesShop struct &#123;&#125;func (cs *ClothesShop) OnShop() &#123;\tfmt.Println(&quot;休闲的装扮&quot;)&#125;type ClothesWork struct &#123;&#125;func (cw *ClothesWork) OnWork() &#123;\tfmt.Println(&quot;工作的装扮&quot;)&#125;func main() &#123;\t//工作的时候\tcw := new(ClothesWork)\tcw.OnWork()\t//shopping的时候\tcs := new(ClothesShop)\tcs.OnShop()&#125;\n\n在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就只限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂。\n开闭原则对扩展开放，对修改封闭\n\n对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对已有代码进行任何修改\n\npackage mainimport &quot;fmt&quot;//抽象的银行业务员type AbstractBanker interface&#123;\tDoBusi()\t//抽象的处理业务接口&#125;//存款的业务员type SaveBanker struct &#123;\t//AbstractBanker&#125;func (sb *SaveBanker) DoBusi() &#123;\tfmt.Println(&quot;进行了存款&quot;)&#125;//转账的业务员type TransferBanker struct &#123;\t//AbstractBanker&#125;func (tb *TransferBanker) DoBusi() &#123;\tfmt.Println(&quot;进行了转账&quot;)&#125;//支付的业务员type PayBanker struct &#123;\t//AbstractBanker&#125;func (pb *PayBanker) DoBusi() &#123;\tfmt.Println(&quot;进行了支付&quot;)&#125;//实现架构层(基于抽象层进行业务封装-针对interface接口进行封装)func BankerBusiness(banker AbstractBanker) &#123;\t//通过接口来向下调用，(多态现象)\tbanker.DoBusi()&#125;func main() &#123;\tBankerBusiness(&amp;SaveBanker&#123;&#125;)\tBankerBusiness(&amp;TransferBanker&#123;&#125;)\tBankerBusiness(&amp;PayBanker&#123;&#125;)&#125;\n\n依赖倒转原则依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程\n耦合度极高的模块关系设计\npackage mainimport &quot;fmt&quot;// === &gt; 奔驰汽车 &lt;===type Benz struct &#123;&#125;func (this *Benz) Run() &#123;\tfmt.Println(&quot;Benz is running...&quot;)&#125;// === &gt; 宝马汽车  &lt;===type BMW struct &#123;&#125;func (this *BMW) Run() &#123;\tfmt.Println(&quot;BMW is running ...&quot;)&#125;//===&gt; 司机张三  &lt;===type Zhang3 struct &#123;\t//...&#125;func (zhang3 *Zhang3) DriveBenZ(benz *Benz) &#123;\tfmt.Println(&quot;zhang3 Drive Benz&quot;)\tbenz.Run()&#125;func (zhang3 *Zhang3) DriveBMW(bmw *BMW) &#123;\tfmt.Println(&quot;zhang3 drive BMW&quot;)\tbmw.Run()&#125;//===&gt; 司机李四 &lt;===type Li4 struct &#123;\t//...&#125;func (li4 *Li4) DriveBenZ(benz *Benz) &#123;\tfmt.Println(&quot;li4 Drive Benz&quot;)\tbenz.Run()&#125;func (li4 *Li4) DriveBMW(bmw *BMW) &#123;\tfmt.Println(&quot;li4 drive BMW&quot;)\tbmw.Run()&#125;func main() &#123;\t//业务1 张3开奔驰\tbenz := &amp;Benz&#123;&#125;\tzhang3 := &amp;Zhang3&#123;&#125;\tzhang3.DriveBenZ(benz)\t//业务2 李四开宝马\tbmw := &amp;BMW&#123;&#125;\tli4 := &amp;Li4&#123;&#125;\tli4.DriveBMW(bmw)&#125;\n\n假设现在要增加一个 丰田汽车 或者 司机王五， 那么模块和模块的依赖关系将成指数级递增，想蜘蛛网一样越来越难维护和捋顺\n面向抽象层依赖倒转在设计一个系统的时候，将模块分为3个层次，抽象层、实现层、业务逻辑层。那么，我们首先将抽象层的模块和接口定义出来，这里就需要了interface接口的设计，然后我们依照抽象层，依次实现每个实现层的模块，在我们写实现层代码的时候，实际上我们只需要参考对应的抽象层实现就好了，实现每个模块，也和其他的实现的模块没有关系，这样也符合了上面介绍的开闭原则。这样实现起来每个模块只依赖对象的接口，而和其他模块没关系，依赖关系单一。系统容易扩展和维护。\n在指定业务逻辑也是一样，只需要参考抽象层的接口来业务就好了，抽象层暴露出来的接口就是我们业务层可以使用的方法，然后可以通过多态的线下，接口指针指向哪个实现模块，调用了就是具体的实现方法，这样我们业务逻辑层也是依赖抽象成编程。\n我们就将这种的设计原则叫做 依赖倒转原则\npackage mainimport &quot;fmt&quot;// ===== &gt;   抽象层  &lt; ========type Car interface &#123;\tRun()&#125;type Driver interface &#123;\tDrive(car Car)&#125;// ===== &gt;   实现层  &lt; ========type BenZ struct &#123;\t//...&#125;func (benz * BenZ) Run() &#123;\tfmt.Println(&quot;Benz is running...&quot;)&#125;type Bmw struct &#123;\t//...&#125;func (bmw * Bmw) Run() &#123;\tfmt.Println(&quot;Bmw is running...&quot;)&#125;type Zhang_3 struct &#123;\t//...&#125;func (zhang3 *Zhang_3) Drive(car Car) &#123;\tfmt.Println(&quot;Zhang3 drive car&quot;)\tcar.Run()&#125;type Li_4 struct &#123;\t//...&#125;func (li4 *Li_4) Drive(car Car) &#123;\tfmt.Println(&quot;li4 drive car&quot;)\tcar.Run()&#125;// ===== &gt;   业务逻辑层  &lt; ========func main() &#123;\t//张3 开 宝马\tvar bmw Car\tbmw = &amp;Bmw&#123;&#125;\tvar zhang3 Driver\tzhang3 = &amp;Zhang_3&#123;&#125;\tzhang3.Drive(bmw)\t//李4 开 奔驰\tvar benz Car\tbenz = &amp;BenZ&#123;&#125;\tvar li4 Driver\tli4 = &amp;Li_4&#123;&#125;\tli4.Drive(benz)&#125;\n\n合成复用原则如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。\n迪米特法则一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。\n例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）\n创建型模式简单工厂模式为什么需要工厂没有工厂模式，在开发者创建一个类的对象时，如果有很多不同种类的对象将会如何实现，代码如下：\npackage mainimport &quot;fmt&quot;//水果类type Fruit struct &#123;\t//...\t//...\t//...&#125;func (f *Fruit) Show(name string) &#123;\tif name == &quot;apple&quot; &#123;\t\tfmt.Println(&quot;我是苹果&quot;)\t&#125; else if name == &quot;banana&quot; &#123;\t\tfmt.Println(&quot;我是香蕉&quot;)\t&#125; else if name == &quot;pear&quot; &#123;\t\tfmt.Println(&quot;我是梨&quot;)\t&#125;&#125;//创建一个Fruit对象func NewFruit(name string) *Fruit &#123;\tfruit := new(Fruit)\tif name == &quot;apple&quot; &#123;\t\t//创建apple逻辑\t&#125; else if name == &quot;banana&quot; &#123;\t\t//创建banana逻辑\t&#125; else if name == &quot;pear&quot; &#123;\t\t//创建pear逻辑\t&#125;\treturn fruit&#125;func main() &#123;\tapple := NewFruit(&quot;apple&quot;)\tapple.Show(&quot;apple&quot;)\tbanana := NewFruit(&quot;banana&quot;)\tbanana.Show(&quot;banana&quot;)\tpear := NewFruit(&quot;pear&quot;)\tpear.Show(&quot;pear&quot;)&#125;\n\n业务逻辑层 —&gt; 基础类模块\n\n在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断\nFruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护\n当需要增加新类型的水果时，必须修改Fruit类的构造函数NewFruit()和其他相关方法源代码，违反了“开闭原则”\n\n在中间加一层工厂模块层，来降低业务逻辑层对基础模块层的直接依赖和耦合关联。\n业务逻辑层 —&gt; 工厂模块 —&gt; 基础类模块\n简单工厂模式角色和职责简单工厂模式并不属于GoF的23种设计模式。他是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：\n\n工厂：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。\n抽象产品：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n具体产品：简单工厂模式所创建的具体实例对象。\n\n\npackage mainimport &quot;fmt&quot;// ======= 抽象层 =========//水果类(抽象接口)type Fruit interface &#123;\tShow()\t //接口的某方法&#125;// ======= 基础类模块 =========type Apple struct &#123;\tFruit  //为了易于理解显示继承(此行可以省略)&#125;func (apple *Apple) Show() &#123;\tfmt.Println(&quot;我是苹果&quot;)&#125;type Banana struct &#123;\tFruit&#125;func (banana *Banana) Show() &#123;\tfmt.Println(&quot;我是香蕉&quot;)&#125;type Pear struct &#123;\tFruit&#125;func (pear *Pear) Show() &#123;\tfmt.Println(&quot;我是梨&quot;)&#125;// ========= 工厂模块  =========//一个工厂， 有一个生产水果的机器，返回一个抽象水果的指针type Factory struct &#123;&#125;func (fac *Factory) CreateFruit(kind string) Fruit &#123;\tvar fruit Fruit\tif kind == &quot;apple&quot; &#123;\t\tfruit = new(Apple)\t&#125; else if kind == &quot;banana&quot; &#123;\t\tfruit = new(Banana)\t&#125; else if kind == &quot;pear&quot; &#123;\t\tfruit = new(Pear)\t&#125;\treturn fruit&#125;// ==========业务逻辑层==============func main() &#123;\tfactory := new(Factory)\tapple := factory.CreateFruit(&quot;apple&quot;)\tapple.Show()\tbanana := factory.CreateFruit(&quot;banana&quot;)\tbanana.Show()\tpear := factory.CreateFruit(&quot;pear&quot;)\tpear.Show()&#125;\n\n优缺点优点： \n\n实现了对象创建和使用的分离\n不需要记住具体类名，记住参数即可，减少使用者记忆量。\n\n缺点：\n\n对工厂类职责过重，一旦不能工作，系统受到影响\n增加系统中类的个数，复杂度和理解度增加\n违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂\n\n适用场景\n工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂\n客户端只知道传入工厂类的参数，对于如何创建对象并不关心\n\n工厂方法模式角色和职责\n抽象工厂：工厂方法模式的核心，任何工厂类都必须实现这个接口。\n工厂：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。\n抽象产品：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\t\n具体产品：工厂方法模式所创建的具体实例对象。\n\n简单工厂模式  + “开闭原则” &#x3D;    工厂方法模式\n\npackage mainimport &quot;fmt&quot;// ======= 抽象层 =========//水果类(抽象接口)type Fruit interface &#123;\tShow()\t //接口的某方法&#125;//工厂类(抽象接口)type AbstractFactory interface &#123;\tCreateFruit() Fruit //生产水果类(抽象)的生产器方法&#125;// ======= 基础类模块 =========type Apple struct &#123;\tFruit  //为了易于理解显示继承(此行可以省略)&#125;func (apple *Apple) Show() &#123;\tfmt.Println(&quot;我是苹果&quot;)&#125;type Banana struct &#123;\tFruit&#125;func (banana *Banana) Show() &#123;\tfmt.Println(&quot;我是香蕉&quot;)&#125;type Pear struct &#123;\tFruit&#125;func (pear *Pear) Show() &#123;\tfmt.Println(&quot;我是梨&quot;)&#125;//(+) 新增一个&quot;日本苹果&quot;type JapanApple struct &#123;\tFruit&#125;func (jp *JapanApple) Show() &#123;\tfmt.Println(&quot;我是日本苹果&quot;)&#125;// ========= 工厂模块  =========//具体的苹果工厂type AppleFactory struct &#123;\tAbstractFactory&#125;func (fac *AppleFactory) CreateFruit() Fruit &#123;\tvar fruit Fruit\t//生产一个具体的苹果\tfruit = new(Apple)\treturn fruit&#125;//具体的香蕉工厂type BananaFactory struct &#123;\tAbstractFactory&#125;func (fac *BananaFactory) CreateFruit() Fruit &#123;\tvar fruit Fruit\t//生产一个具体的香蕉\tfruit = new(Banana)\treturn fruit&#125;//具体的梨工厂type PearFactory struct &#123;\tAbstractFactory&#125;func (fac *PearFactory) CreateFruit() Fruit &#123;\tvar fruit Fruit\t//生产一个具体的梨\tfruit = new(Pear)\treturn fruit&#125;//具体的日本工厂type JapanAppleFactory struct &#123;\tAbstractFactory&#125;func (fac *JapanAppleFactory) CreateFruit() Fruit &#123;\tvar fruit Fruit\t//生产一个具体的日本苹果\tfruit = new(JapanApple)\treturn fruit&#125;// ========= 业务逻辑层  =========func main() &#123;\t/*\t\t本案例为了突出根据依赖倒转原则与面向接口编程特性。\t    一些变量的定义将使用显示类型声明方式\t*/\t//需求1：需要一个具体的苹果对象\t//1-先要一个具体的苹果工厂\tvar appleFac AbstractFactory\tappleFac = new(AppleFactory)\t//2-生产相对应的具体水果\tvar apple Fruit\tapple = appleFac.CreateFruit()\tapple.Show()\t//需求2：需要一个具体的香蕉对象\t//1-先要一个具体的香蕉工厂\tvar bananaFac AbstractFactory\tbananaFac = new(BananaFactory)\t//2-生产相对应的具体水果\tvar banana Fruit\tbanana = bananaFac.CreateFruit()\tbanana.Show()\t//需求3：需要一个具体的梨对象\t//1-先要一个具体的梨工厂\tvar pearFac AbstractFactory\tpearFac = new(PearFactory)\t//2-生产相对应的具体水果\tvar pear Fruit\tpear = pearFac.CreateFruit()\tpear.Show()\t//需求4：需要一个日本的苹果？\t//1-先要一个具体的日本评估工厂\tvar japanAppleFac AbstractFactory\tjapanAppleFac = new(JapanAppleFactory)\t//2-生产相对应的具体水果\tvar japanApple Fruit\tjapanApple = japanAppleFac.CreateFruit()\tjapanApple.Show()&#125;\n\n优缺点优点： \n\n不需要记住具体类名，甚至连具体参数都不用记忆\n实现了对象创建和使用的分离\n系统的可扩展性也就变得非常好，无需修改接口和原类\n对于新产品的创建，符合开闭原则\n\n缺点：\n\n增加系统中类的个数，复杂度和理解度增加\n增加了系统的抽象性和理解难度\n\n适用场景\n客户端不知道它所需要的对象的类\n抽象工厂类通过其子类来指定创建哪个对象\n\n抽象工厂方法模式工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。\n因此，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是本文将要学习的抽象工厂模式的基本思想。\n“抽象工厂方法模式”引出了“产品族”和“产品等级结构”概念，其目的是为了更加高效的生产同一个产品组产品\npackage mainimport &quot;fmt&quot;// ======= 抽象层 =========type AbstractApple interface &#123;\tShowApple()&#125;type AbstractBanana interface &#123;\tShowBanana()&#125;type AbstractPear interface &#123;\tShowPear()&#125;//抽象工厂type AbstractFactory interface &#123;\tCreateApple() AbstractApple\tCreateBanana() AbstractBanana\tCreatePear() AbstractPear&#125;// ======== 实现层 =========/*  中国产品族 */type ChinaApple struct &#123;&#125;func (ca *ChinaApple) ShowApple() &#123;\tfmt.Println(&quot;中国苹果&quot;)&#125;type ChinaBanana struct &#123;&#125;func (cb *ChinaBanana) ShowBanana() &#123;\tfmt.Println(&quot;中国香蕉&quot;)&#125;type ChinaPear struct &#123;&#125;func (cp *ChinaPear) ShowPear() &#123;\tfmt.Println(&quot;中国梨&quot;)&#125;type ChinaFactory struct &#123;&#125;func (cf *ChinaFactory) CreateApple() AbstractApple &#123;\tvar apple AbstractApple\tapple = new(ChinaApple)\treturn apple&#125;func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;\tvar banana AbstractBanana\tbanana = new(ChinaBanana)\treturn banana&#125;func (cf *ChinaFactory) CreatePear() AbstractPear &#123;\tvar pear AbstractPear\tpear = new(ChinaPear)\treturn pear&#125;/*  日本产品族 */type JapanApple struct &#123;&#125;func (ja *JapanApple) ShowApple() &#123;\tfmt.Println(&quot;日本苹果&quot;)&#125;type JapanBanana struct &#123;&#125;func (jb *JapanBanana) ShowBanana() &#123;\tfmt.Println(&quot;日本香蕉&quot;)&#125;type JapanPear struct &#123;&#125;func (cp *JapanPear) ShowPear() &#123;\tfmt.Println(&quot;日本梨&quot;)&#125;type JapanFactory struct &#123;&#125;func (jf *JapanFactory) CreateApple() AbstractApple &#123;\tvar apple AbstractApple\tapple = new(JapanApple)\treturn apple&#125;func (jf *JapanFactory) CreateBanana() AbstractBanana &#123;\tvar banana AbstractBanana\tbanana = new(JapanBanana)\treturn banana&#125;func (cf *JapanFactory) CreatePear() AbstractPear &#123;\tvar pear AbstractPear\tpear = new(JapanPear)\treturn pear&#125;/*  美国产品族 */type AmericanApple struct &#123;&#125;func (aa *AmericanApple) ShowApple() &#123;\tfmt.Println(&quot;美国苹果&quot;)&#125;type AmericanBanana struct &#123;&#125;func (ab *AmericanBanana) ShowBanana() &#123;\tfmt.Println(&quot;美国香蕉&quot;)&#125;type AmericanPear struct &#123;&#125;func (ap *AmericanPear) ShowPear() &#123;\tfmt.Println(&quot;美国梨&quot;)&#125;type AmericanFactory struct &#123;&#125;func (af *AmericanFactory) CreateApple() AbstractApple &#123;\tvar apple AbstractApple\tapple = new(AmericanApple)\treturn apple&#125;func (af *AmericanFactory) CreateBanana() AbstractBanana &#123;\tvar banana AbstractBanana\tbanana = new(AmericanBanana)\treturn banana&#125;func (af *AmericanFactory) CreatePear() AbstractPear &#123;\tvar pear AbstractPear\tpear = new(AmericanPear)\treturn pear&#125;// ======== 业务逻辑层 =======func main() &#123;\t//需求1: 需要美国的苹果、香蕉、梨 等对象\t//1-创建一个美国工厂\tvar aFac AbstractFactory\taFac = new(AmericanFactory)\t//2-生产美国苹果\tvar aApple AbstractApple\taApple = aFac.CreateApple()\taApple.ShowApple()\t//3-生产美国香蕉\tvar aBanana AbstractBanana\taBanana = aFac.CreateBanana()\taBanana.ShowBanana()\t//4-生产美国梨\tvar aPear AbstractPear\taPear = aFac.CreatePear()\taPear.ShowPear()\t//需求2: 需要中国的苹果、香蕉\t//1-创建一个中国工厂\tcFac := new(ChinaFactory)\t//2-生产中国苹果\tcApple := cFac.CreateApple()\tcApple.ShowApple()\t//3-生产中国香蕉\tcBanana := cFac.CreateBanana()\tcBanana.ShowBanana()&#125;\n\n优缺点优点：\n\n拥有工厂方法模式的优点\n当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象\n增加新的产品族很方便，无须修改已有系统，符合“开闭原则”\n\n缺点：\n\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”\n\n使用场景\n系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族\n产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构\n\n类似的实现有：\n\n设计一个电脑主板架构，电脑包括（显卡，内存，CPU）3个固定的插口，显卡具有显示功能（display，功能实现只要打印出意义即可），内存具有存储功能（storage），cpu具有计算功能（calculate）。    现有Intel厂商，nvidia厂商，Kingston厂商，均会生产以上三种硬件。    要求组装两台电脑，                1台（Intel的CPU，Intel的显卡，Intel的内存）                1台（Intel的CPU， nvidia的显卡，Kingston的内存）    用抽象工厂模式实现。\n\n单例模式保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。\n分为恶汉式、懒汉式\n恶汉式\npackage mainimport &quot;fmt&quot;/*三个要点：\t\t一是某个类只能有一个实例；\t\t二是它必须自行创建这个实例；\t\t三是它必须自行向整个系统提供这个实例。*//*\t保证一个类永远只能有一个对象*///1、保证这个类非公有化，外界不能通过这个类直接创建一个对象//   那么这个类就应该变得非公有访问 类名称首字母要小写type singelton struct &#123;&#125;//2、但是还要有一个指针可以指向这个唯一对象，但是这个指针永远不能改变方向//   Golang中没有常指针概念，所以只能通过将这个指针私有化不让外部模块访问var instance *singelton = new(singelton)//3、如果全部为私有化，那么外部模块将永远无法访问到这个类和对象，//   所以需要对外提供一个方法来获取这个唯一实例对象//   注意：这个方法是否可以定义为singelton的一个成员方法呢？//       答案是不能，因为如果为成员方法就必须要先访问对象、再访问函数//        但是类和对象目前都已经私有化，外界无法访问，所以这个方法一定是一个全局普通函数func GetInstance() *singelton &#123;\treturn instance&#125;func (s *singelton) SomeThing() &#123;\tfmt.Println(&quot;单例对象的某方法&quot;)&#125;func main() &#123;    // 以本包下的main访问举例，实际上别的包也可以调用\ts := GetInstance()\ts.SomeThing()&#125;\n\nsync.once实现懒汉式的代码\npackage mainimport (\t&quot;fmt&quot;\t&quot;sync&quot;)var once sync.Oncetype singelton struct &#123;&#125;var instance *singeltonfunc GetInstance() *singelton &#123;\tonce.Do(func()&#123;\t\tinstance = new(singelton)\t&#125;)\treturn instance&#125;func (s *singelton) SomeThing() &#123;\tfmt.Println(&quot;单例对象的某方法&quot;)&#125;func main() &#123;\ts := GetInstance()\ts.SomeThing()&#125;\n\n优缺点优点：\n\n单例模式提供了对唯一实例的受控访问\n节约系统资源（在系统内存中只存在一个对象）\n\n缺点：\n\n扩展略难（单例模式中没有抽象层）\n单例类的职责过重\n\n适用场景\n系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象\n客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例\n\n","categories":["技术","语言","golang"],"tags":["go","设计模式"]},{"title":"Golang channel深入挖掘","url":"/2022-11-08/1b653cc435bf/","content":"《Go 程序员面试笔试宝典》学习整理\n什么是CSP虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\ngolang主张通过通信来实现内存共享而非通过共享内存来实现通信。这就是 Go 的并发哲学，它依赖 CSP 模型（Communicating Sequential Processes），基于 channel 实现。\nCSP 全称是 “Communicating Sequential Processes”(通信顺序进程)，是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。\nGo 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。\n大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。\nChannel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。\nGo 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。\nchannel底层数据结构// go 1.9.2type hchan struct &#123;    // chan 里元素数量    qcount   uint    // chan 底层循环数组的长度    dataqsiz uint    // 指向底层循环数组的指针    // 只针对有缓冲的 channel    buf      unsafe.Pointer    // chan 中元素大小    elemsize uint16    // chan 是否被关闭的标志    closed   uint32    // chan 中元素类型    elemtype *_type // element type    // 已发送元素在循环数组中的索引    sendx    uint   // send index    // 已接收元素在循环数组中的索引    recvx    uint   // receive index    // 等待接收的 goroutine 队列    recvq    waitq  // list of recv waiters    // 等待发送的 goroutine 队列    sendq    waitq  // list of send waiters    // 保护 hchan 中所有字段    lock mutex&#125;\n\n\nbuf 指向底层循环数组，只有缓冲型的 channel 才有。\nsendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。\nsendq，recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。\nwaitq 是 sudog 的一个双向链表，而 sudog 实际上是对 goroutine 的一个封装：\n\ntype waitq struct &#123;    first *sudog    last  *sudog&#125;\n\n\nlock 用来保证每个读 channel 或写 channel 的操作都是原子的。\n\n创建channel// var 变量 chan 元素类型var ch1 chan int   // 声明一个传递整型的通道var ch2 chan bool  // 声明一个传递布尔型的通道var ch3 chan []int // 声明一个传递int切片的通道\n\n通道是引用类型，通道类型的空值是nil，声明的通道后需要使用make函数初始化之后才能使用。\n// make(chan 元素类型, [缓冲大小])// 无缓冲通道ch4 := make(chan int)ch5 := make(chan bool)ch6 := make(chan []int)// 有缓冲通道ch7 := make(chan int,7)\n\n最终创建 chan 的函数是 makechan：\nfunc makechan(t *chantype, size int64) *hchan\n\n从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。\nconst hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + uintptr(-int(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign-1))func makechan(t *chantype, size int64) *hchan &#123;    elem := t.elem    // 省略了检查 channel size，align 的代码    // ……    var c *hchan    // 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）    // 只进行一次内存分配    if elem.kind&amp;kindNoPointers != 0  size == 0 &#123;        // 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素        // 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))        // 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）        if size &gt; 0 &amp;&amp; elem.size != 0 &#123;            c.buf = add(unsafe.Pointer(c), hchanSize)        &#125; else &#123;            // race detector uses this location for synchronization            // Also prevents us from pointing beyond the allocation (see issue 9401).            // 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处            // 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响            // 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）            c.buf = unsafe.Pointer(c)        &#125;    &#125; else &#123;        // 进行两次内存分配操作        c = new(hchan)        c.buf = newarray(elem, int(size))    &#125;    c.elemsize = uint16(elem.size)    c.elemtype = elem    // 循环数组长度    c.dataqsiz = uint(size)    // 返回 hchan 指针    return c&#125;\n\nchannel操作简单使用通道有发送（send）、接收(receive）和关闭（close）三种操作。\n发送和接收都使用&lt;-符号。\n// PS: 下面就是个写法示例，不是用来跑的// 创建ch := make(chan int)// 发送ch &lt;- 10 // 把10发送到ch中// 接收x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch       // 从ch中接收值，忽略结果// 关闭close(ch)\n\n常见操作情况总结：\n\n\n\nchannel\nnil\n空\n满\nclosed\n\n\n\n接收\n阻塞\n阻塞\n正常接收\n有值就接着正常读取，没有值返回零值和false\n\n\n发送\n阻塞\n正常发送\n阻塞\npanic\n\n\n关闭\npanic\n关闭成功\n关闭成功\npanic\n\n\n无缓冲通道无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。\nfunc main() &#123;    c := make(chan int)    go func() &#123;        for i := 0; i &lt; 5; i++ &#123;            c &lt;- i        &#125;        close(c)    &#125;()    for &#123;        if data, ok := &lt;-c; ok &#123;            fmt.Println(data)        &#125; else &#123;            break        &#125;    &#125;    fmt.Println(&quot;main结束&quot;)&#125;\n\n有缓冲通道使用make函数初始化通道的时候为其指定通道的容量\nfunc main() &#123;    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道    ch &lt;- 10    fmt.Println(&quot;发送成功&quot;)&#125;\n\n只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量，当然如果容量等于零仍然会阻塞。\n可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，不过一般不会这样去做。\n单向通道限制通道在函数中只能发送或只能接收\n// chan&lt;- int是一个只能发送的通道，可以发送但是不能接收func counter(out chan&lt;- int) &#123;    for i := 0; i &lt; 100; i++ &#123;        out &lt;- i    &#125;    close(out&#125;func squarer(out chan&lt;- int, in &lt;-chan int) &#123;    for i := range in &#123;        out &lt;- i * i    &#125;    close(out)&#125;// &lt;-chan int是一个只能接收的通道，可以接收但是不能发送func printer(in &lt;-chan int) &#123;    for i := range in &#123;        fmt.Println(i)    &#125;&#125;func main() &#123;    ch1 := make(chan int)    ch2 := make(chan int)    go counter(ch1)    go squarer(ch2, ch1)    printer(ch2)&#125;\n\n优雅地关闭channel\n对一个关闭的通道再发送值就会导致panic。\n对一个关闭的通道进行接收会一直获取值直到通道为空。\n对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。\n关闭一个已经关闭的通道会导致panic。\n\n有一条广泛流传的关闭 channel 的原则：\n\ndon’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.（很经典也很重要）\n\n不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时关闭 channel。\n比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。\n但是上面所说的并不是最本质的，最本质的原则就只有一条：\n\ndon’t close (or send values to) closed channels.\n\n有两个不那么优雅地关闭 channel 的方法：\n\n使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。\n使用 sync.Once 来保证只关闭一次。\n\n根据 sender 和 receiver 的个数，分下面几种情况：\n\n一个 sender，一个 receiver\n一个 sender， M 个 receiver\nN 个 sender，一个 reciver\nN 个 sender， M 个 receiver\n\n对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。\nfunc main() &#123;    rand.Seed(time.Now().UnixNano())    const Max = 100000  // 生成的随机数的最大值    const NumSenders = 1000 // 开启的sender数    dataCh := make(chan int, 100)    stopCh := make(chan struct&#123;&#125;)   // 作为信号channel    // senders    for i := 0; i &lt; NumSenders; i++ &#123;        go func() &#123;            for &#123;                select &#123;                case &lt;- stopCh:                    // 正常情况下会阻塞，所以不会执行                    // 关闭情况下会读取0值，执行return                    return                case dataCh &lt;- rand.Intn(Max):                    // 发送数据                &#125;            &#125;        &#125;()    &#125;    // the receiver    go func() &#123;        for value := range dataCh &#123;            // 收到了Max-1就不再接收数据了            if value == Max-1 &#123;                fmt.Println(&quot;send stop signal to senders.&quot;)                close(stopCh)                return            &#125;            fmt.Println(value)        &#125;    &#125;()    select &#123;    case &lt;- time.After(time.Hour):    &#125;&#125;\n\n上面的代码并没有明确关闭 dataCh，在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭channel，让 gc 代劳。\n第四种情况，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求（这里发送请求后关闭的同样是stopCh，多个sender的情况下是不会由sender主动关闭dataCh的）\nfunc main() &#123;    rand.Seed(time.Now().UnixNano())    const Max = 100000  // 生成的随机数的最大值    const NumReceivers = 10 // 开启的receiver数    const NumSenders = 1000 // 开启的sender数    dataCh := make(chan int, 100)    stopCh := make(chan struct&#123;&#125;)    // 必须是一个缓冲通道，toStop 就是中间人的角色    // 接收 senders 和 receivers 发送过来的关闭 dataCh 请求。    toStop := make(chan string, 1)    var stoppedBy string    // 中间人，收到toStop后执行一次close(stopCh)就退出    go func() &#123;        stoppedBy = &lt;-toStop        close(stopCh)    &#125;()    // senders    for i := 0; i &lt; NumSenders; i++ &#123;        go func(id string) &#123;            for &#123;                value := rand.Intn(Max)                if value == 0 &#123;                    select &#123;                    case toStop &lt;- &quot;sender#&quot; + id:                    default:                    &#125;                    return                &#125;                select &#123;                case &lt;- stopCh:                    return                case dataCh &lt;- value:                &#125;            &#125;        &#125;(strconv.Itoa(i))    &#125;    // receivers    for i := 0; i &lt; NumReceivers; i++ &#123;        go func(id string) &#123;            for &#123;                select &#123;                case &lt;- stopCh:                    return                case value := &lt;-dataCh:                    if value == Max-1 &#123;                        select &#123;                        case toStop &lt;- &quot;receiver#&quot; + id:                        default:                        &#125;                        return                    &#125;                    fmt.Println(value)                &#125;            &#125;        &#125;(strconv.Itoa(i))    &#125;    select &#123;    case &lt;- time.After(time.Hour):    &#125;&#125;\n\n这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。\n如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：\n// toStop部分toStop := make(chan string, NumReceivers + NumSenders)// sender部分value := rand.Intn(Max)if value == 0 &#123;    toStop &lt;- &quot;sender#&quot; + id    return&#125;// receiver部分if value == Max-1 &#123;    toStop &lt;- &quot;receiver#&quot; + id    return&#125;\n\n直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。\nChannel引发的泄漏Channel 可能会引发 goroutine 泄漏。\n泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中。\n另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏。\n情境一：select-case 误用导致的内存泄露// out:    // NumGoroutine: 2    // 超时    // NumGoroutine: 3func TestLeakOfMemory(t *testing.T) &#123;   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())   chanLeakOfMemory()   time.Sleep(time.Second * 3)   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())&#125;func chanLeakOfMemory() &#123;   errCh := make(chan error) // (1)   go func() &#123; // (5)      time.Sleep(2 * time.Second)      errCh &lt;- errors.New(&quot;chan error&quot;) // (2)      fmt.Println(&quot;finish sending&quot;)   &#125;()   var err error   select &#123;   case &lt;-time.After(time.Second): // (3) 大家也经常在这里使用 &lt;-ctx.Done()      fmt.Println(&quot;超时&quot;)   case err = &lt;-errCh: // (4)      if err != nil &#123;         fmt.Println(err)      &#125; else &#123;         fmt.Println(nil)      &#125;   &#125;&#125;\n\n根据输出结果（开始有两个 goroutine，结束时有三个 goroutine），我们可以知道，直到测试函数结束前，仍有一个 goroutine 没有退出。原因是由于 (1) 处创建的 errCh 是不含缓存队列的 channel，由于没有发送方往 errCh 发送数据，所以 (4) 处代码一直阻塞。直到 (3) 处超时后，打印“超时”，函数退出，(4) 处代码都未接收成功。而 (2) 处的所在的 goroutine 在“超时”被打印后，才开始发送。由于外部的 goroutine 已经退出了，errCh 没有接收者，导致 (2) 处一直阻塞。因此 (2) 处代码所在的协程一直未退出，造成了内存泄漏。如果代码中有许多类似的代码，或在 for 循环中使用了上述形式的代码，随着时间的增长会造成多个未退出的 gorouting，最终导致程序 OOM。\n解决办法：为 channel 增加一个缓存队列，即把 (1) 处代码改为 errCh := make(chan error, 1)\n情景二：for-range 误用导致的内存泄露上述示例中只有一个发送者，且只发送一次，所以增加一个缓存队列即可。但在其他情况下，可能不止有一个发送者（或者不只发送一次），所以这个方案要求，缓存队列的容量需要和发送次数一致。一旦缓存队列容量被用完后，再有发送者发送就会阻塞发送者 goroutine。如果恰好此时接收者退出了，那么仍然至少会有一个 goroutine 无法退出，从而造成内存泄漏。就比如下面的代码。不知道经过上面的讲解，读者是否能够发现其中的问题。\nfunc TestLeakOfMemory2(t *testing.T) &#123;   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())   chanLeakOfMemory2()   time.Sleep(time.Second * 3) // 等待 goroutine 执行，防止过早输出结果   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())&#125;func chanLeakOfMemory2() &#123;   ich := make(chan int, 100) // (3)   // sender   go func() &#123;      defer close(ich)      for i := 0; i &lt; 10000; i++ &#123;         ich &lt;- i         time.Sleep(time.Millisecond) // 控制一下，别发太快      &#125;   &#125;()   // receiver   go func() &#123;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)      defer cancel()      for i := range ich &#123; // (2)         if ctx.Err() != nil &#123; // (1)            fmt.Println(ctx.Err())            return         &#125;         fmt.Println(i)      &#125;   &#125;()&#125;// Output:    // NumGoroutine: 2    // 0    // 1    // ...(省略)...    // 789    // context deadline exceeded    // NumGoroutine: 3\n\n我们聪明地使用了 channel 的缓存队列。我们以为我们循环发送，发完之后就会把 channel 关闭。而且我们使用 for range 获取 channel 的值，会一直获取，直到 channel 关闭。但在代码 (1) 处，接收者的 goroutine 中，我们加了一个判断语句。这会让代码 (2) 处的 channel 还没被接收完就退出了接收者 goroutine。尽管代码 (3) 处有缓存，但是因为发送 channel 在 for 循环中，缓存队列很快就会被占满，阻塞在第 101 的位置。所以这种情况我们要使用一个额外的 stop channel 来终结发送者所在的 goroutine。方式如下：\nfunc TestLeakOfMemory2(t *testing.T) &#123;   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())   chanLeakOfMemory2()   time.Sleep(time.Second * 3) // 等待 goroutine 执行，防止过早输出结果   fmt.Println(&quot;NumGoroutine:&quot;, runtime.NumGoroutine())&#125;func chanLeakOfMemory2() &#123;   ich := make(chan int, 100)   stopCh := make(chan struct&#123;&#125;)   // sender   go func() &#123;      defer close(ich)      for i := 0; i &lt; 10000; i++ &#123;         select &#123;         case &lt;-stopCh:             return         case ich &lt;- i:         &#125;         time.Sleep(time.Millisecond) // 控制一下，别发太快      &#125;   &#125;()   // receiver   go func() &#123;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)      defer cancel()      for i := range ich &#123;         if ctx.Err() != nil &#123;            fmt.Println(ctx.Err())            close(stopCh)            return         &#125;         fmt.Println(i)      &#125;   &#125;()&#125;// Output:// NumGoroutine: 2// 0// 1// ...(省略)...// 789// context deadline exceeded// NumGoroutine: 2\n\n总之，通常情况下，我们只会遇到这两种 go channel 造成内存泄漏的情况（一个发送者导致的内存泄漏和多个发送者导致的内存泄漏）\n不论发送者发送一次还是多次，如果接收者所在 goroutine 能够在接收完 channel 中的数据之后结束，那么就不会造成内存泄漏；或者说接收者能够在发送者停止发送后再结束，就不会造成内存泄露。\n如果接收者需要在 channel 关闭之前提前退出，为防止内存泄漏，在发送者与接收者发送次数是一对一时，应设置 channel 缓冲队列为 1；在发送者与接收者的发送次数是多对多时，应使用专门的 stop channel 通知发送者关闭相应 channel\n其实归根到底是一方不再对channel操作时没有向另一方发送信号，导致另一方阻塞，也就是说关闭channel的方式不对（并不特指close，包括不再操作由gc处理的情况），所以优雅关闭channel还是很重要的\nChannel应用\n停止信号（见优雅关闭channel）\n定时任务（与timer结合）\n实现超时控制\n定期执行某个任务\n解耦生产方和消费方\n控制并发数\n\n定时任务\nselect &#123;    case &lt;-time.After(100 * time.Millisecond):    case &lt;-s.stopc:        return false&#125;\n\n等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。\nfunc worker() &#123;    ticker := time.Tick(1 * time.Second)    for &#123;        select &#123;        case &lt;- ticker:            // 执行定时任务            fmt.Println(&quot;执行 1s 定时任务&quot;)        &#125;    &#125;&#125;\n\n每隔 1 秒种，执行一次定时任务。\n解耦生产方和消费方\n服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for &#123;&#125; 无限循环里，从某个 channel 消费工作任务并执行：\nfunc main() &#123;    taskCh := make(chan int, 100)    go worker(taskCh)    // 塞任务    for i := 0; i &lt; 10; i++ &#123;        taskCh &lt;- i    &#125;    // 等待 1 小时     select &#123;    case &lt;-time.After(time.Hour):    &#125;&#125;func worker(taskCh &lt;-chan int) &#123;    const N = 5    // 启动 5 个工作协程    for i := 0; i &lt; N; i++ &#123;        go func(id int) &#123;            for &#123;                task := &lt;- taskCh                fmt.Printf(&quot;finish task: %d by worker %d\\n&quot;, task, id)                time.Sleep(time.Second)            &#125;        &#125;(i)    &#125;&#125;\n\n5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。\n控制并发数\n有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。\nvar limit = make(chan int, 3)func main() &#123;    // …………    for _, w := range work &#123;        go func() &#123;            limit &lt;- 1            w()            &lt;-limit        &#125;()    &#125;    // …………&#125;\n\n参考文章\n详解 Go channel 内存泄漏问题\nGo 程序员面试笔试宝典\ngo语言中文文档\n\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Golang defer与闭包","url":"/2022-08-15/ccdc4ab1e023/","content":"引入先来看俩程序\npackage mainimport &quot;fmt&quot;func main() &#123;    var whatever [5]struct&#123;&#125;    for i := range whatever &#123;        defer fmt.Println(i)    &#125;&#125;// 结果：4 3 2 1 0\n\n// 闭包状态下package mainimport &quot;fmt&quot;func main() &#123;    var whatever [5]struct&#123;&#125;    for i := range whatever &#123;        defer func() &#123; fmt.Println(i) &#125;()    &#125;&#125;// 结果：4 4 4 4 4\n\n这俩个程序区别在于一个直接调用输出，一个闭包输出，但结果却天差地别，下面深入了解下defer与闭包的关系\n（PS：答案写在后记里了 :）\ndefer介绍defer特性\n\n关键字 defer 用于注册延迟调用。\n这些调用直到 return 前才被执。因此，可以用来做资源清理。\n多个defer语句，按先进后出的方式执行。\ndefer语句中的变量，在defer声明时就决定了。\n\ndefer用途\n\n关闭文件句柄\n锁资源释放\n数据库连接释放\n\ndefer执行顺序定义defer的时，会先将defer后面的调用的函数的参数入栈，在return右侧的参数或函数值计算完成后调用defer，此时defer的函数参数出栈执行，defer执行完成后执行return\n例子出处\n例题一\npackage mainfunc add(x, y int) (z int) &#123;    defer func() &#123;        println(z+9) // 输出: 212    &#125;()    z = x + y    return z + 200 // 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)&#125;func main() &#123;    println(add1(1, 2)) // 输出: 203&#125;// 结果：212 203\n\npackage mainfunc add2(x, y int) (z int) &#123;    defer println(z + 9) // 输出: 9    z = x + y    return z + 200 // 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)&#125;func main() &#123;    println(add2(1, 2)) // 输出: 203&#125;// 结果：9 203\n\n例题二\npackage mainimport (    &quot;fmt&quot;)func main() &#123;    fmt.Println(a())&#125;func a() int &#123;    var i int    defer add(i) //延迟调用add()，在程序计数器走到defer时，会把defer右边最外层函数的参数计算完毕，也就是此时的i是多少就是多少    i += 100    return i&#125;func add(i int) &#123;    i += 1    fmt.Println(i)&#125; // 结果：1 100\n\npackage mainimport (    &quot;fmt&quot;)func main() &#123;    fmt.Println(b())&#125;func b() int &#123;    var i int    defer func() &#123;        add(i) //可以理解为传的是i的指针，&#123;&#125;里面的函数体入栈，i此时不计算，最后是什么就是什么    &#125;()    i += 100    return i //return 之前运行defer，此时的defer里面的i是100，调用add变为101&#125;func add(i int) &#123;    i += 1    fmt.Println(i)&#125; \n\n在定义defer的时候，就要将defer后面的函数参数等入栈，等到return之前的时候出栈执行，a方法中是将i的拷贝直接入栈，b方法中通过一个闭包调用，实际上将i的指针传递给闭包，闭包读取值拷贝给add。\n后记回到一开始给出的两个程序，首先我们应该清楚for-range循环中i的地址是保持不变的，在非闭包的情况下，将值压入栈中进行保存，所以最后输出顺序为4 3 2 1 0，但在闭包条件下，右侧函数参数为空，i保存的为for中i的地址，由于i的值一直在改变，所以最后调用时打印出来的值均为最后的值4，即：4 4 4 4 4\n参考文章：\n\n延迟调用（defer）\nGolang 中的闭包和defer\n\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go切片踩坑记录","url":"/2022-07-18/5a8d87932712/","content":"今日刷力扣，写一个二叉树的前序遍历代码如下：\npackage BiTreetype TreeNode struct &#123;    Val   int    Left  *TreeNode    Right *TreeNode&#125;func preorderTraversal(root *TreeNode) []int &#123;    var result []int    traversal(root, result)    return result&#125;func traversal(node *TreeNode, result []int) &#123;    if node == nil &#123;        return    &#125;    result = append(result, node.Val)    traversal(node.Left, result)    traversal(node.Right, result)&#125;\n\ngo的传递方式只有值传递一种，但切片是引用类型，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n但是本题力扣上运行时输出结果却为[]（正确输出：1 2 3），便引起了笔者的思考\n首先打印result前后的地址\nfunc preorderTraversal(root *TreeNode) []int &#123;    var result []int    fmt.Printf(&quot;初始地址：%p\\n&quot;, result)    traversal(root, result)    fmt.Printf(&quot;返回的地址：%p\\n&quot;, result)    return result&#125;func traversal(node *TreeNode, result []int) &#123;    fmt.Printf(&quot;传入函数的地址为：%p\\n&quot;, result)    if node == nil &#123;        return    &#125;    result = append(result, node.Val)    fmt.Println(result)    fmt.Printf(&quot;append后的地址为：%p\\n&quot;, result)    traversal(node.Left, result)    traversal(node.Right, result)&#125;\n\n初始地址：0x0传入函数的地址为：0x0[1]append后的地址为：0xc0000140a0传入函数的地址为：0xc0000140a0传入函数的地址为：0xc0000140a0[1 2]append后的地址为：0xc0000140b0传入函数的地址为：0xc0000140b0[1 2 3]append后的地址为：0xc000074020传入函数的地址为：0xc000074020传入函数的地址为：0xc000074020传入函数的地址为：0xc0000140b0返回的地址：0x0\n\n从第二行可以看出传递的确实是指针，在递归的时候result的值确实再改变，而值得我们注意的是append前后地址的变化。\n当切片需要扩容时会创建新的数组，这会导致和原有切片的分离，也就是说现在改变的切片已经不再是原来的地址了，但是append时我们将它重新赋给了result，所以traversal函数内的result始终指向正确的地址，而preorderTraversal中的result仍时原来的地址，所以最终的结果为[]，关于切片的底层实现详见链接。\n解决方法：\n第一种是traversal中返回result\nfunc preorderTraversal(root *TreeNode) []int &#123;    var result []int    result = traversal(root, result)    return result&#125;func traversal(node *TreeNode,result []int) []int &#123;    if node == nil &#123;        return result    &#125;    result = append(result, node.Val)    result = traversal(node.Left, result)    result = traversal(node.Right, result)    return result&#125;\n\n第二种为力扣给出的题解\nfunc preorderTraversal(root *TreeNode) (vals []int) &#123;    var preorder func(*TreeNode)    preorder = func(node *TreeNode) &#123;        if node == nil &#123;            return        &#125;        vals = append(vals, node.Val)        preorder(node.Left)        preorder(node.Right)    &#125;    preorder(root)    return&#125;","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Go语言踩坑小记","url":"/2022-05-31/6721e810741b/","content":"时区被这个傻卵玩意折磨了一晚上，转换成SQL语句后自己放mySQL运行是正确的，但它自己运行就打死也不对，后来发现是时区的问题，我的那个数后面是+0000，mySQL里面的是+0800( UTC:零时区 +0000， China: 东八区 +0800)\n就是说转化的时候要把时区改成当地时区\ntimestamp1, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, dateStr)// 没有设置，为默认时区+0000timestamp2, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, dateStr, time.Local)//设置为本地时区\n\n时间格式化Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go语言的诞生时间 2006-01-02 15:04:05 -0700 MST（感觉有什么大病）\n例如：\ncurrentTime := time.Now()fmt.Println(&quot;YYYY.MM.DD : &quot;, currentTime.Format(&quot;2006.01.02 15:04:05&quot;))\n\nint int32 int64参考文章\nint   类型大小为 8 字节int8  类型大小为 1 字节int16 类型大小为 2 字节int32 类型大小为 4 字节int64 类型大小为 8 字节\n\ngo语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节; 如果是64位操作系统，int类型的大小就是8个字节\n由于GO语言中各int类型的取值范围不同，各int类型间进行数据转换时，会存在数据截断的问题，在使用过程中要引起注意\nint8:   -128 ~ 127int16:  -32768 ~ 32767int32:  -2147483648 ~ 2147483647int64:  -9223372036854775808 ~ 9223372036854775807uint8:  0 ~ 255uint16: 0 ~ 65535uint32: 0 ~ 4294967295uint64: 0 ~ 18446744073709551615\n\nGoland同一个包下无法调用其他文件问题描述project-main.go-router.go\n\npackage都是main，且router中需要调用的已大写，但运行时就是显示调不到\n分析对比在终端使用go build main.go无法正常调用，使用go build可以正常使用。\n直接在文件上右键运行相当于go build xxx.go\n解决方法\n编辑配置，运行种类设置为目录，选择运行入口所在的目录即可\ngin框架c.JSON并不会return，记着看看后面是不是需要接return\n","categories":["技术","语言","golang"],"tags":["go"]},{"title":"Java初始化二维数组的三种方式","url":"/2022-04-16/00338497e1f2/","content":"出处\n//第一种方式：int a[][]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//第二种方式；int[][] ints = new int[4][2];ints[i][j] =__; //分别赋值//第三种方式：第二维的长度可以动态申请int[][] arr3 = new int[5][];//五行的长度for(int i=0; i&lt;arr3.length; ++i)&#123;    arr3[i]=new int[i+1];   //列的长度每次都变化。每次都要重新申请空间(长度)    for(int j=0; j&lt;arr3[i].length; ++j)        arr3[i][j]= i+j;&#125;","categories":["技术","语言","java"],"tags":["Java"]},{"title":"java学习笔记","url":"/2023-11-27/bd32b3914914/","content":"[TOC]\n记录一下学习java时觉得重点或一时没记住的知识点，方便日后复习，持续更新，有东西就加\njava基础认识javaJava介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。\n解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。\n而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。\n对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。\n\nJava SE(Standard Edition): 标准版，包含标准的JVM和标准库 \nJava EE(Enterprise Edition): 企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等 \nJava ME(Micro Edition): 针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”\n\n┌───────────────────────────┐│Java EE                    ││    ┌────────────────────┐ ││    │Java SE             │ ││    │    ┌─────────────┐ │ ││    │    │   Java ME   │ │ ││    │    └─────────────┘ │ ││    └────────────────────┘ │└───────────────────────────┘\n\n\nJRE(Java Runtime Environment): 运行Java字节码的虚拟机\nJDK(Java Development Kit)\n\n如果只有Java源码，要编译成Java字节码，就需要JDK，JDK除了包含JRE，还提供了编译器、调试器等开发工具。\n┌─    ┌──────────────────────────────────┐│     │     Compiler, debugger, etc.     ││     └──────────────────────────────────┘JDK ┌─ ┌──────────────────────────────────┐│   │  │                                  ││  JRE │      JVM + Runtime Library       ││   │  │                                  │└─  └─ └──────────────────────────────────┘┌───────┐┌───────┐┌───────┐┌───────┐│Windows││ Linux ││ macOS ││others │└───────┘└───────┘└───────┘└───────┘\n\n\nJSR规范：Java Specification Request\nJCP组织：Java Community Process\n\n为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。\n所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。\n一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：\n\nRI：Reference Implementation\nTCK：Technology Compatibility Kit\n\n比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。\n通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。\n运行一个Demo，文件名为Hello.java，代码如下\npublic class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\n\njavac命令将Hello.java文件编译成字节码文件Hello.class，然后用java命令执行这个字节码文件\nD:\\Desktop\\Java_project&gt;javac Hello.javaD:\\Desktop\\Java_project&gt;dir2023/11/30  16:05    &lt;DIR&gt;          .2023/11/29  22:19    &lt;DIR&gt;          ..2023/11/30  16:05               417 Hello.class2023/11/30  16:04               122 Hello.javaD:\\Desktop\\Java_project&gt;java HelloHello, world!\n\n注意：给虚拟机传递的参数Hello是我们定义的类名，虚拟机自动查找对应的class文件并执行,\nJava 11之后，可以通过java Hello.java可以直接运行一个单文件源码，需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的。所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。\n\n一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致； \n使用javac可以将.java源码编译成.class字节码； \n使用java可以运行一个已编译的Java程序，参数是类名。\n\n基础语法Java是面向对象的语言，一个程序的基本单位就是class，类名要求：必须以英文字母开头(大写)，后接字母，数字和下划线的组合\nJava入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。\n方法名也有命名规则，命名和class一样，但是首字母小写，在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束。\npublic class Hello &#123;    public static void main(String[] args) &#123; // 方法名是main        System.out.println(&quot;Hello, world!&quot;); // 语句分号结束    &#125;&#125;\n\n注释有三种：\n// 单行注释/*多行注释这是个注释还是个注释*//** * 可以用来自动创建文档的注释 *  * @auther tbghg */\n\n第三种以/**开头，以*/结束，如果有多行，每行通常以星号开头，需要写在类和方法的定义处，可以用于自动创建文档。\n数据类型基本类型基本类型如下：\n\n整数类型：byte，short，int，long \n浮点数类型：float，double \n字符类型：char \n布尔类型：boolean\n\n计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit，不同数据类型所占字节数：\n\nbyte      1字节    -128 ~ 127\nshort     2字节    -32768 ~ 32767\nchar      2字节\nint       4字节    -2147483648 ~ 2147483647\nfloat     4字节\nlong      8字节    -9223372036854775808 ~ 9223372036854775807\ndouble    8字节\n\npublic class Main &#123;    public static void main(String[] args) &#123;        int i = 2147483647;        int i2 = -2147483648;        int i3 = 2_000_000_000; // 加下划线更容易识别        int i4 = 0xff0000; // 十六进制表示的16711680        int i5 = 0b1000000000; // 二进制表示的512        long n1 = 9000000000000000000L; // long型的结尾需要加L        long n2 = 900; // 没有加L，此处900为int，但int类型可以赋值给long        int i6 = 900L; // 错误：不能把long型赋值给int                        float f1 = 3.14f;        float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38        float f3 = 1.0; // 错误：不带f结尾的是double类型，不能赋值给float                double d = 1.79e308;        double d2 = -1.79e308;        double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324                // Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。        boolean b1 = true;        boolean b2 = false;        boolean isGreater = 5 &gt; 3; // 计算结果为true        int age = 12;        boolean isAdult = age &gt;= 18; // 计算结果为false                // 字符类型char表示一个字符。字符使用单引号。一个char保存一个Unicode字符        char a = &#x27;A&#x27;;    // Unicode编码，都占用两字节        char zh = &#x27;中&#x27;;  // Unicode编码，都占用两字节                System.out.println(a);        System.out.println(zh);                // 可以直接用转义字符\\u+Unicode编码来表示一个字符，必须使用十六进制        char c3 = &#x27;\\u0041&#x27;; // &#x27;A&#x27;，因为十六进制0041 = 十进制65        char c4 = &#x27;\\u4e2d&#x27;; // &#x27;中&#x27;，因为十六进制4e2d = 十进制20013                System.out.println(c3);        System.out.println(c4);    &#125;&#125;\n\n整数运算：\n\n整数的除法对于除数为0时运行时将报错，但编译不会报错\n整数除法不能整除会舍弃小数\n溢出不会出错，却会得到一个奇怪的结果\ni++ ++i &lt;&lt; &gt;&gt; &gt;&gt;&gt;无符号右移 &amp; | ~非 ^异或\n类型不统一时，会自动转换：在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型\n支持强制转换，如short s = (short) i\n\n浮点数运算：\n\n只能进行加减乘除这些数值计算，不能做位运算和移位运算\n浮点数常常无法精确表示，如0.1，二进制是无限循环小数，但0.5又可以精确地表示，因此，浮点数比较大小有时是不准确的(见下方代码)\n其他与整形运算相似\n\npublic class Main &#123;    public static void main(String[] args) &#123;        // 0.1在二进制是无限循环小数，只能存储一个近似值，所以x与y不相等        double x = 1.0 / 10;        double y = 1 - 9.0 / 10;        // 观察x和y是否相等:        System.out.println(x);        System.out.println(y);        System.out.println(x == y);        // 0.5在二进制中可精确表示，所以x与y相等        x = 5.0 / 10;        y = 1 - 5.0 / 10;        System.out.println(x);        System.out.println(y);        System.out.println(x == y);    &#125;&#125;/* output:0.10.09999999999999998false0.50.5true*/\n\n如果非要比较，可以设置一个阈值，看二者相差是否在这之间：\n// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) &#123;    // 可以认为相等&#125; else &#123;    // 不相等&#125;\n\n布尔运算：\n\n短路运算：如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果\n支持三元运算符：b ? x : y\n\n引用类型除了基本类型，剩下的都是引用类型，最常用的是String，引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置\nString，用双引号”…”表示字符串。一个字符串可以存储0个到任意个字符，转义：\n\n&quot; 表示字符”\n&#39; 表示字符’\n\\ 表示字符\\\n\\n 表示换行符\n\\r 表示回车符\n\\t 表示Tab\n\\u#### 表示一个Unicode编码的字符\n\n字符串拼接可直接使用+。如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。\n从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了：\npublic class Main &#123;    public static void main(String[] args) &#123;        // 末尾会带上换行，总共五行        String s = &quot;&quot;&quot;                   SELECT * FROM                     users                   WHERE id &gt; 100                   ORDER BY name DESC                   &quot;&quot;&quot;;                   // 末尾没换行，共四行        String s2 = &quot;&quot;&quot;                   SELECT * FROM                     users                   WHERE id &gt; 100                   ORDER BY name DESC&quot;&quot;&quot;;        System.out.println(s);    &#125;&#125;\n\n引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：\nString s1 = null; // s1是nullString s2 = s1; // s2也是nullString s3 = &quot;&quot;; // s3指向空字符串，不是null\n\n常量：定义变量的时候，如果加上final修饰符，这个变量就变成了常量，常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写。\nfinal double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error!\n\n有些时候，类型的名字太长，写起来比较麻烦。例如：\nStringBuilder sb = new StringBuilder();\n\n这个时候，如果想省略变量类型，可以使用var关键字，编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder\nvar sb = new StringBuilder();\n\n多行语句用{ }括起来，括号内部是自身的范围，在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。\npublic class Main &#123;    public static void main(String[] args) &#123;        &#123;            int i = 0; // 变量i从这里开始定义            &#123;                int x = 1; // 变量x从这里开始定义                &#123;                    String s = &quot;hello&quot;; // 变量s从这里开始定义                &#125; // 变量s作用域到此结束                //                System.out.println(s);  // 报错，无法解析符号 &#x27;s&#x27;                                // 注意，这是一个新的变量s，它和上面的变量同名，                // 但是因为作用域不同，它们是两个不同的变量:                String s = &quot;hi&quot;;                            &#125; // 变量x和s作用域到此结束        &#125; // 变量i作用域到此结束    &#125;&#125;\n\n数组：\npublic class Main &#123;    public static void main(String[] args) &#123;        // 5位同学的成绩:        int[] ns = new int[5];        System.out.println(ns.length); // 5                // 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小        int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;                // 可以进一步简写为        int[] ns = &#123; 68, 79, 91, 85, 62 &#125;;    &#125;&#125;\n\n\n数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false\n数组一旦创建后，大小就不可改变\n\n流程控制&#x2F;&#x2F; todo 输入输出输入输出：这块之后系统整理下\nif判断语句：\nif (条件) &#123;    // 条件满足时执行&#125; else if (条件) &#123;&#125; else &#123;&#125;\n\n\n引用类型判断内容相等要使用equals()，注意避免NullPointerException【重点】\n浮点数判断相等不能直接用&#x3D;&#x3D;运算符\n不推荐省略花括号{}  一条语句时大括号可以省，但不推荐\n\npublic class Main &#123;    public static void main(String[] args) &#123;        String s1 = &quot;hello&quot;;        String s2 = &quot;HELLO&quot;.toLowerCase();        // 引用类型 使用equals判断相等        if (s1.equals(s2)) &#123;            System.out.println(&quot;s1 equals s2&quot;);        &#125;                String s3 = null;        // 必须先判断null，否则会报NullPointerException错误        if (s3 != null &amp;&amp; s3.equals(&quot;hello&quot;)) &#123;            System.out.println(&quot;hello&quot;);        &#125;    &#125;&#125;\n\nswitch-case语句\n\nswitch的计算结果必须是整型、字符串或枚举类型\ncase语句具有穿透性，要带break，可以打开fall-through警告\n不要漏掉default，可以打开missing default警告\nJava 14开始，switch语句正式升级为表达式，使用-&gt;格式时，不再需要break，允许携带返回值，通过yield提前中断(类似于return)\n\npublic class Main &#123;    public static void main(String[] args) &#123;        String fruit = &quot;orange&quot;;        int opt = switch (fruit) &#123;            // 直接返回1            case &quot;apple&quot; -&gt; 1;            // 直接返回2            case &quot;pear&quot;, &quot;mango&quot; -&gt; 2;            // 整个代码块用&#123;&#125;包裹，yield可提前结束switch-case语句，并返回结果            default -&gt; &#123;                int code = fruit.hashCode();                yield code; // switch语句返回值            &#125;        &#125;;        System.out.println(&quot;opt = &quot; + opt);    &#125;&#125;\n\n循环语句\nwhile (条件表达式) &#123;    循环语句&#125;do &#123;    执行循环语句&#125; while (条件表达式);for (初始条件; 循环检测条件; 循环后更新计数器) &#123;    // 执行语句&#125;// 遍历数组时可使用for-each，n为ns中的元素for (int n : ns) &#123;    // 执行语句&#125;// 当然，也是支持break、continue的\n\n数组操作\nimport java.util.Arrays;public class Main &#123;    public static void main(String[] args) &#123;        int[] ns = &#123; 1, 1, 8, 3, 5, 4 &#125;;                // 1. 遍历                // 直接打印，打印出来的是JVM中的地址，如        System.out.println(ns);                for (int n : ns) &#123;            System.out.print(n+&quot; &quot;);        &#125;        System.out.println();                // java提供了Arrays.toString方法便于打印        System.out.println(Arrays.toString(ns));                /* output:        [I@b4c966a        1 1 8 3 5 4         [1, 1, 8, 3, 5, 4]        */                // 2. 排序                Arrays.sort(ns);        if (Arrays.toString(ns).equals(&quot;[1, 1, 3, 4, 5, 8]&quot;)) &#123;            System.out.println(&quot;排序正确&quot;);        &#125;                // 3. 二维数组                int[][] ns2 = &#123;                &#123; 1, 2, 3, 4 &#125;,                &#123; 5, 6, 7, 8 &#125;,                &#123; 9, 10, 11, 12 &#125;        &#125;;        // 可以两层for遍历        for (int[] arr : ns2) &#123;            for (int n : arr) &#123;                System.out.print(n);                System.out.print(&quot; &quot;);            &#125;            System.out.println();        &#125;        // 可以Arrays.deepToString()打印        System.out.println(Arrays.deepToString(ns2));                /* output:        1 2 3 4         5 6 7 8         9 10 11 12         [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]        */    &#125;&#125;\n\n面向对象Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP\n\n一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 \nclass和instance是“模版”和“实例”的关系，定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例 \nclass定义的field，在每个instance都会拥有各自的field，且互不干扰 \n通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance\n指向instance的变量都是引用变量\n\n方法修饰符 方法返回类型 方法名(方法参数列表) &#123;    若干方法语句;    return 方法返回值;&#125;\n\n\n方法内部可以使用this访问当前实例\n方法支持可变参数，如public void setNames(String... names) &#123;&#125;\n可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null\nsetNames此时的参数names是String[]类型\n\n\n\n构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。\npublic class Main &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法        Person p2 = new Person(); // 也可以调用无参数构造方法    &#125;&#125;class Person &#123;    private String name;    private int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;\n\n\n实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例\n没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法\n可以定义多个构造方法，编译器根据参数自动判断\n可以在一个构造方法内部调用另一个构造方法，便于代码复用\n\n方法重载(overload)：如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。\n注意：方法重载的返回值类型通常都是相同的。\n方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。举个例子，String类提供了多个重载方法indexOf()，可以查找子串：\n\nint indexOf(int ch)：根据字符的Unicode码查找\nint indexOf(String str)：根据字符串查找\nint indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置\nint indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置\n\n类继承\n继承是面向对象编程的一种强大的代码复用方式\nJava只允许单继承，所有类最终的根类是Object\nprotected允许子类访问父类的字段和方法\n子类的构造方法可以通过super()调用父类的构造方法\n可以安全地向上转型为更抽象的类型\n可以强制向下转型，最好借助instanceof判断\nJava 14后instanceof判断完可直接赋值\n子类和父类的关系是is，has关系不能用继承，可考虑组合\n\n使用extends关键字来实现继承。超类（super class），父类（parent class），基类（base class） | 子类（subclass），扩展类（extended class） \n注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！\n子类无法访问父类的private字段或者private方法，为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问\n使用super可以指向父类（对应this），子类的构造方法必须调用父类的构造方法，方式为super()并携带上对应参数\n正常情况下，只要某个class没有final修饰符，那么任何类都可以从该class继承。从Java 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称。\n\n向上转型：把一个子类型安全地变为更加抽象的父类型【没问题】\n向下转型：把一个父类类型强制转型为子类类型【看原本是什么，如果原本就能转那没问题，否则会报错ClassCastException】\n\n向下转型举例：\nPerson p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException!\nPerson类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。\n因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。\n为了防止向下转型发生问题，一般先通过instanceof方法判断是否为该实例\nPerson p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // falseStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // trueStudent n = null;System.out.println(n instanceof Student); // false\n\n从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：\nObject obj = &quot;hello&quot;;if (obj instanceof String) &#123;    String s = (String) obj;    System.out.println(s.toUpperCase());&#125;\n\n可以改写如下：\npublic class Main &#123;    public static void main(String[] args) &#123;        Object obj = &quot;hello&quot;;        // instanceof判断完成后转换并赋到s中        if (obj instanceof String s) &#123;            // 可以直接使用变量s:            System.out.println(s.toUpperCase());        &#125;    &#125;&#125;\n\n多态\n子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为\nJava的方法调用总是作用于运行期对象的实际类型，这种行为称为多态\nfinal修饰符有多种作用\nfinal修饰的方法可以阻止被覆写\nfinal修饰的class可以阻止被继承\nfinal修饰的field必须在创建对象时初始化，随后不可修改\n\n\n\n重载overload方法签名不同，覆写(重写)override方法签名不同相同\n加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。\n多态的特性就是，运行期才能动态决定调用的子类方法。多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。\npublic class Main &#123;    public static void main(String[] args) &#123;        Person p = new Student();        p.run(); // 应该打印Person.run还是Student.run?        p.runTwice(p);    &#125;&#125;class Person &#123;    public void run() &#123;        System.out.println(&quot;Person.run&quot;);    &#125;    public void runTwice(Person p) &#123;        // run方法有可能会被重写，我们并不知道执行时是person的还是重写后student的，只有根据运行时期实际类型才知道        p.run();        p.run();    &#125;    // 被final修饰，无法重写    public final String hello() &#123;        return &quot;Hello, &quot; + name;    &#125;&#125;class Student extends Person &#123;    @Override    public void run() &#123;        System.out.println(&quot;Student.run&quot;);    &#125;&#125;// final修饰的类无法被继承final class Apple &#123;    // 可直接赋值，也可在构造方法中赋值，之后不能再修改该字段    public final String name = &quot;Unamed&quot;;&#125;\n\n抽象类如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：\nclass Person &#123;    public abstract void run();&#125;\n\n把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。\n必须把Person类本身也声明为abstract，才能正确编译它：\nabstract class Person &#123;    public String name;    public abstract void run();&#125;\n\n我们无法实例化一个抽象类：Person p = new Person(); // 编译错误。抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。\n当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例，这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：\nPerson s = new Student();Person t = new Teacher();// 不关心Person变量的具体子类型:s.run();t.run();\n\n这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。\n面向抽象编程的本质就是：\n\n上层代码只定义规范（例如：abstract class Person）\n不需要子类就可以实现业务逻辑（正常编译）\n具体的业务逻辑由不同的子类实现，调用者并不关心\n\n接口如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：interface\n所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。\ninterface Person &#123;    void run();    String getName();&#125;\n\n当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子：\nclass Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;    @Override    public void run() &#123;        System.out.println(this.name + &quot; run&quot;);    &#125;    @Override    public String getName() &#123;        return this.name;    &#125;&#125;\n\n在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface：class Student implements Person, Hello &#123;...&#125;\n\n\n\n\nabstract class\ninterface\n\n\n\n继承\n只能extends一个class\n可以implements多个interface\n\n\n字段\n可以定义实例字段\n不能定义实例字段，可定义静态字段且为final类型\n\n\n抽象方法\n可以定义抽象方法\n可以定义抽象方法\n\n\n非抽象方法\n可以定义非抽象方法\n可以定义default方法\n\n\n在接口中，可以定义default方法。实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。\ndefault方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。\npublic class Main &#123;    public static void main(String[] args) &#123;        Person p = new Student(&quot;Xiao Ming&quot;);        p.run();    &#125;&#125;interface Person &#123;    String getName();    default void run() &#123;        System.out.println(getName() + &quot; run&quot;);    &#125;&#125;class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;\n\n\n","categories":["技术","语言","java"],"tags":["java"]},{"title":"python遍历时删除","url":"/2022-04-02/82a366021ce1/","content":"\n这个东西和我程序中另一个bug一起出现了，导致调了仨小时（对，就这玩意）\n","categories":["技术","语言","python"]},{"title":"如何使用pyinstaller进行打包","url":"/2021-06-29/2c1620318523/","content":"\n今天当我再次进行python打包时又一次地愣住了，又一次地打开了百度……，这时我大概明白该写篇博客记录一下了。\n\n转载自此文章，只做了一些部分修改\nPyinstallerpyinstaller是python的一个第三方模块，使用它可以将python程序打包为可执行文件，实现打包后的程序在没有python环境的机器上也可以运行。\npyinstaller安装：\npip installer pyinstaller\n通常我们打包程序时，会遇到两种情况：\n\n打包一个python脚本文件\n打包一个python项目程序\n\n打包一个python脚本程序对于只有一个python脚本的简单程序，打包操作很方便，直接使用命令行的方式，输入相关指令即可。\n对于一个摄氏温度转华氏温度的小程序（temp.py），我们可以这样做：\n# 摄氏温度转华氏温度temp = input(&quot;请输入摄氏温度：&quot;)new_temp = 9/5 * int(temp) + 32print(f&quot;华氏温度为：&#123;new_temp&#125;F&quot;)q = input(&quot;按任意键退出：&quot;)\n\n首先，打开终端cmd, 进入temp.py文件所在的路径，输入指令：pyinstaller -F temp.py\n打包结束后，将在当前目录下生成两个文件夹（bulid、dist）和一个文件temp.spec，现在不需要理会文件夹bulid和文件temp.spec\n我们需要的打包后的可执行文件在文件夹dist中，双击即可运行，实现打包。\n补充：如果想修改可执行文件的图标，使用指令：pyinstaller -i icon.ico -F temp.py\n打包结束后，在dist文件夹下降出现temp.exe。你可能会发现它的图标并不是你想要的，这没有关系，你将它重命名或者拷贝到其他地方，你会发现它的图标立刻变成你期待的样子，祝你好运。\n打包一个python项目程序对于常用到的py项目程序，包含许多文件夹和py文件，以及配套的资源文件。这种情况下在终端中使用指令的方式打包程序本身也是可以实现的，但是此时打包操作就变得非常复杂，它需要你理解不同指令参数的确切意思，时不时你将入坑爬不起来，苦不堪言。 这段时间使用pygame写了一个像素鸟的游戏，想分享给别人体验，就使用了pyinstaller将程序打包成exe文件。这里分享给大家，希望对你能有所帮助。\n这种情况下，一个简单的打包方式，就是通过pyinstaller提供的spec文件实现程序打包。\n下面通过一个基于pygame实现的FlappyBird介绍该项目的打包流程。\n该项目包含六个文件夹，其中：bin、conf、core包含所有的python脚本文件，项目入口程序在bin\\setup.py，所有音频文件在audios文件夹下，所有的字体文件在fonts文件夹下，所有的图片文件在images文件夹下。\n第一步：打开终端进入FlappyBird路径下，输入指令：pyinstaller -F bin\\setup.py，回车，程序结束后，发现当前目录下生成两个文件夹（bulid、dist）和一个文件setup.spec，现在删除两个文件夹，只保留setup.spec文件。\nsetup.spec\n# -*- mode: python ; coding: utf-8 -*-block_cipher = Nonea = Analysis([&#x27;bin\\\\setup.py&#x27;],\t# 此列表存放项目设计的所有python脚本文件             pathex=[&#x27;C:\\\\Users\\\\15057\\\\Desktop\\\\FlappyBird&#x27;], # 此列表为项目绝对路径             binaries=[],             datas=[],\t\t# 此列表存放所有资源文件，每个文件是一个2元组元素             hiddenimports=[],             hookspath=[],             runtime_hooks=[],             excludes=[],             win_no_prefer_redirects=False,             win_private_assemblies=False,             cipher=block_cipher,             noarchive=False)pyz = PYZ(a.pure, a.zipped_data,             cipher=block_cipher)exe = EXE(pyz,          a.scripts,          a.binaries,          a.zipfiles,          a.datas,          [],          name=&#x27;setup&#x27;,\t\t# 打包程序的名字          debug=False,          bootloader_ignore_signals=False,          strip=False,          upx=True,          upx_exclude=[],          runtime_tmpdir=None,          console=True )\t# 此处console=True表示，打包后的可执行文件双击运行时屏幕会出现一个cmd窗口，不影响原程序运行# 如果想要修改程序图标，使用在EXE()中加入 icon=&#x27;xxxxx&#x27;, 切记：绝对路径\n\n第二步：修改setup.spec文件，修改后的文件如下:\n# -*- mode: python ; coding: utf-8 -*-block_cipher = Nonepy_files = [    &#x27;bin\\\\setup.py&#x27;,    &#x27;conf\\\\settings.py&#x27;,    &#x27;core\\\\main.py&#x27;,    &#x27;core\\\\base.py&#x27;,    &#x27;core\\\\bird.py&#x27;,    &#x27;core\\\\pipe.py&#x27;,    &#x27;core\\\\score.py&#x27;,]add_files = [    (&#x27;fonts\\\\font.ttf&#x27;, &#x27;fonts&#x27;),    (&#x27;images\\\\*.png&#x27;, &#x27;images&#x27;),    (&#x27;images\\\\flappy.ico&#x27;, &#x27;images&#x27;),    (&#x27;audios\\\\*.wav&#x27;, &#x27;audios&#x27;),]a = Analysis(py_files,             pathex=[&#x27;C:\\\\Users\\\\15057\\\\Desktop\\\\FlappyBird&#x27;],             binaries=[],             datas=add_files,             hiddenimports=[],             hookspath=[],             runtime_hooks=[],             excludes=[],             win_no_prefer_redirects=False,             win_private_assemblies=False,             cipher=block_cipher,             noarchive=False)pyz = PYZ(a.pure, a.zipped_data,             cipher=block_cipher)exe = EXE(pyz,          a.scripts,          a.binaries,          a.zipfiles,          a.datas,          [],          name=&#x27;FlappBird&#x27;,          debug=False,          bootloader_ignore_signals=False,          strip=False,          upx=True,          upx_exclude=[],          runtime_tmpdir=None,          console=False,          icon=&#x27;C:\\\\Users\\\\15057\\\\Desktop\\\\FlappyBird\\\\images\\\\flappy.ico&#x27; )\n\n修改位置：\n\n添加py_files列表，包含项目需要的所有python脚本\n添加add_files列表，包含涉及到的所有资源文件，每个文件是2元组的形式存放\nname&#x3D;’FlappBird’, 制定可执行程序名字\nconsole&#x3D;False， 制定可执行程序执行时不显示控制台窗口\nicon&#x3D;’C:\\Users\\15057\\Desktop\\FlappyBird\\images\\flappy.ico’， 设置程序图标，ico格式文件（16*16）\n\n第三步：执行setup.spec文件。项目路径下输入指令：pyinstaller -F setup.spec，\n回车，程序结束后，新增dist文件夹，且该文件夹下新增FlappyBird.exe，最终，打包结束。\n补充打包，可以使用许多指令，指令都差不多，不同的是使用不用的参数，如 -F、-i等，不同的参数有不同的意义。这些可以在网上找到相关解释说明，这里就赘述了。\n值得说明的一点是，使用spec文件打包程序时，使用-F或者使用-w，生成的spec文件内容有一点点不同。\n这里大家注意即可，因为使用-F打包时默认只生成一个单独的可执行文件，如这里的FlappyBird.exe； 而使用-w打包时会生成一个文件夹，该文件夹里面包含一些库文件和FlappyBird.exe，这里的exe需要依赖这些库文件，即资源文件。在生成的spec文件中，会多一点内容。但是基本不影响打包流程和打包思路。\n笔者补充去除不必要的模块import有时需要让pyinstaller不打包某些用不到的模块，可通过在excludes&#x3D;[]中添加此模块实现，如\nexcludes=[&#x27;zmq&#x27;]\n\n常用参数及含义\n\n\n参数\n命令\n含义\n\n\n\n-D\npyinstaller -D demo.py\n默认选项。除了主程序demo.exe外，还会在在dist文件夹中生成很多依赖文件，推荐使用。\n\n\n-c\npyinstaller -c demo.py\n默认选项。使用控制台，只对windows有效。\n\n\n-F\npyinstaller -F demo.py\n只在dist文件夹中生成一个程序demo.exe文件，适用于没有多依赖.py文件的单个文件。\n\n\n-w\npyinstaller -w demo.py\n不使用控制台，只对windows有效。\n\n\n-p\npyinstaller -p D:\\project\\demo.py\n设置导入路径。\n\n\n-i\npyinstaller -i D:\\icons\\demo.ico demo.py\n给生成的demo.exe文件设置一个自定义的图标。\n\n\n","categories":["技术","语言","python"],"tags":["python"]}]